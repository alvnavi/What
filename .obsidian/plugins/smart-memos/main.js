/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/smart-chat-model/adapters/anthropic.js
var require_anthropic = __commonJS({
  "node_modules/smart-chat-model/adapters/anthropic.js"(exports) {
    var AnthropicAdapter = class {
      /**
       * Prepares the request body for the Anthropic API by converting ChatML format to a format compatible with Anthropic.
       * @param {Object} opts - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Anthropic API.
       */
      prepare_request_body(opts) {
        return chatml_to_anthropic(opts);
      }
      /**
       * Counts the tokens in the input by estimating them, as the Anthropic model does not provide a direct method.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The estimated number of tokens in the input.
       */
      async count_tokens(input) {
        return this.estimate_tokens(input);
      }
      /**
       * Estimates the number of tokens in the input based on a rough average token size.
       * @param {string|Object} input - The input text or object to estimate tokens in.
       * @returns {number} The estimated number of tokens.
       */
      estimate_tokens(input) {
        if (typeof input === "object")
          input = JSON.stringify(input);
        return Math.ceil(input.length / 6);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        return json.content.find((msg) => msg.type === "tool_use");
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object} The input of the tool call.
       */
      get_tool_call_content(tool_call) {
        return tool_call.input;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        return tool_call.name;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.content) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = this.get_message(json)) == null ? void 0 : _b[(_a = this.get_message(json)) == null ? void 0 : _a.type];
      }
    };
    exports.AnthropicAdapter = AnthropicAdapter;
    function chatml_to_anthropic(opts) {
      let tool_counter = 0;
      const messages = opts.messages.filter((msg) => msg.role !== "system").map((m) => {
        if (m.role === "tool") {
          return { role: "user", content: [
            {
              type: "tool_result",
              tool_use_id: `tool-${tool_counter}`,
              content: m.content
            }
          ] };
        }
        if (m.role === "assistant" && m.tool_calls) {
          tool_counter++;
          const out2 = {
            role: m.role,
            content: m.tool_calls.map((c) => ({
              type: "tool_use",
              id: `tool-${tool_counter}`,
              name: c.function.name,
              input: typeof c.function.arguments === "string" ? JSON.parse(c.function.arguments) : c.function.arguments
            }))
          };
          if (m.content) {
            if (typeof m.content === "string")
              out2.content.push({ type: "text", text: m.content });
            else
              m.content.forEach((c) => out2.content.push(c));
          }
          return out2;
        }
        if (typeof m.content === "string")
          return { role: m.role, content: m.content };
        if (Array.isArray(m.content)) {
          const content = m.content.map((c) => {
            if (c.type === "text")
              return { type: "text", text: c.text };
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let media_type = image_url.split(":")[1].split(";")[0];
              if (media_type === "image/jpg")
                media_type = "image/jpeg";
              return { type: "image", source: { type: "base64", media_type, data: image_url.split(",")[1] } };
            }
          });
          return { role: m.role, content };
        }
        return m;
      });
      const { model, max_tokens, temperature, tools, tool_choice } = opts;
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "<context>\n" + opts.messages[last_system_idx].content + "\n</context>\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      console.log(messages);
      const out = {
        messages,
        model,
        max_tokens,
        temperature
      };
      if (tools) {
        out.tools = tools.map((tool) => ({
          name: tool.function.name,
          description: tool.function.description,
          input_schema: tool.function.parameters
        }));
        if ((tool_choice == null ? void 0 : tool_choice.type) === "function") {
          const tool_prompt = `Use the "${tool_choice.function.name}" tool!`;
          const last_user_idx = out.messages.findLastIndex((msg) => msg.role === "user");
          out.messages[last_user_idx].content += "\n" + tool_prompt;
          out.system = `Required: use the "${tool_choice.function.name}" tool!`;
        }
      }
      const last_non_context_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (last_non_context_system_idx > -1)
        out.system = opts.messages[last_non_context_system_idx].content;
      return out;
    }
    exports.chatml_to_anthropic = chatml_to_anthropic;
  }
});

// node_modules/smart-chat-model/adapters/cohere.js
var require_cohere = __commonJS({
  "node_modules/smart-chat-model/adapters/cohere.js"(exports) {
    var CohereAdapter = class {
      /**
       * Converts a ChatML object to a format suitable for a request to the Cohere API.
       * @param {Object} chatml - The ChatML object containing the chat history and other parameters.
       * @returns {Object} The request body formatted for the Cohere API.
       */
      prepare_request_body(chatml) {
        return chatml_to_cohere(chatml);
      }
      /**
       * Extracts the message content from a JSON response from the Cohere API.
       * @param {Object} json - The JSON response object from which to extract the text content.
       * @returns {string} The extracted text content from the response.
       */
      get_message_content(json) {
        return json.text;
      }
      /**
       * Processes streaming data received from the Cohere API and extracts text chunks.
       * This method handles the accumulation of text data over multiple events and manages the state of the stream.
       * @param {Object} event - The event object containing streaming data.
       * @returns {string} The accumulated text chunk extracted from the stream.
       */
      get_text_chunk_from_stream(event) {
        if (!this.last_line_index)
          this.last_line_index = 0;
        clearTimeout(this.last_line_timeout);
        this.last_line_timeout = setTimeout(() => {
          this.last_line_index = 0;
        }, 1e4);
        const data = event.source.xhr.responseText;
        const lines = data.split("\n").slice(this.last_line_index);
        console.log(lines);
        this.last_line_index += lines.length;
        const text_chunk = lines.filter((line) => line.trim() !== "").map((line) => {
          console.log(line);
          const json = JSON.parse(line);
          if (json.event_type === "stream-end") {
            console.log("stream-end");
            this.end_of_stream = true;
            setTimeout(() => {
              this.end_of_stream = false;
            }, 3e3);
            return "";
          }
          return json.text;
        }).join("");
        console.log(text_chunk);
        return text_chunk;
      }
      /**
       * Determines if the end of the stream has been reached based on the event data.
       * @param {Object} event - The event object that may indicate the end of the stream.
       * @returns {boolean} True if the end of the stream is indicated, false otherwise.
       */
      is_end_of_stream(event) {
        return this.end_of_stream;
      }
    };
    exports.CohereAdapter = CohereAdapter;
    function chatml_to_cohere(chatml) {
      const cohere = {
        model: chatml.model,
        // skip last user message
        chat_history: chatml.messages.slice(0, -1).map((message) => ({
          role: message.role,
          message: parse_message_content_to_string(message)
        })),
        message: parse_message_content_to_string(chatml.messages[chatml.messages.length - 1]),
        temperature: chatml.temperature
        // stream: chatml.stream // currently not supported
      };
      return cohere;
    }
    exports.chatml_to_cohere = chatml_to_cohere;
    function parse_message_content_to_string(message) {
      return Array.isArray(message.content) ? message.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") : message.content;
    }
  }
});

// node_modules/smart-chat-model/adapters/gemini.js
var require_gemini = __commonJS({
  "node_modules/smart-chat-model/adapters/gemini.js"(exports) {
    var GeminiAdapter = class {
      /**
       * Constructs a GeminiAdapter instance with a specified model configuration.
       * @param {Object} model - The model configuration object.
       */
      constructor(model) {
        this.model = model;
      }
      /**
       * Prepares the request body for the Gemini API by converting ChatML format to a format compatible with Gemini.
       * @param {Object} body - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Gemini API.
       */
      prepare_request_body(body) {
        return chatml_to_gemini(body);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        var _a, _b, _c, _d, _e;
        return (_e = (_d = (_c = (_b = (_a = json.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.functionCall;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string|null} The name of the tool, or null if not available.
       */
      get_tool_name(tool_call) {
        return tool_call == null ? void 0 : tool_call.name;
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object|null} The input of the tool call, or null if not available.
       */
      get_tool_call_content(tool_call) {
        return tool_call == null ? void 0 : tool_call.args;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        var _a;
        return (_a = json.candidates) == null ? void 0 : _a[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        var _a, _b;
        return (_b = (_a = this.get_message(json)) == null ? void 0 : _a.content) == null ? void 0 : _b.parts.map((part) => part.text).join("");
      }
      /**
       * Handles escaped newlines in a streaming text chunk.
       * @param {Object} event - The streaming event containing the data.
       * @returns {string} The text chunk with escaped newlines replaced.
       */
      get_text_chunk_from_stream(event) {
        return event.data.replace(/\\n/g, "\n");
      }
      /**
       * Determines if the streaming response has ended based on the readyState of the XMLHttpRequest.
       * @param {Object} event - The streaming event.
       * @returns {boolean} True if the stream has ended, false otherwise.
       */
      is_end_of_stream(event) {
        return event.source.xhr.readyState === 4;
      }
      /**
       * Counts the tokens in the input by making an API request to the Gemini token counting endpoint.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The total number of tokens in the input.
       */
      async count_tokens(input) {
        var _a;
        const req = {
          url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:countTokens?key=${this.model.api_key}`,
          method: "POST",
          headers: { "Content-Type": "application/json" }
        };
        let body;
        if (typeof input === "string")
          body = chatml_to_gemini({ messages: [{ role: "user", content: input }] });
        else if (Array.isArray(input))
          body = chatml_to_gemini({ messages: input });
        else if (typeof input === "object")
          body = chatml_to_gemini(input);
        else
          return console.error("Invalid input for count_tokens", input);
        delete body.generationConfig;
        delete body.safetySettings;
        req.body = JSON.stringify(body);
        const resp = await this.model.request_adapter(req);
        return (_a = resp == null ? void 0 : resp.json) == null ? void 0 : _a.totalTokens;
      }
      /**
       * Getter for the standard API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for non-streaming requests.
       */
      get endpoint() {
        return this.model.config.endpoint.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
      /**
       * Getter for the streaming API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for streaming requests.
       */
      get endpoint_streaming() {
        return this.model.config.endpoint_streaming.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
    };
    exports.GeminiAdapter = GeminiAdapter;
    function chatml_to_gemini(opts) {
      const messages = opts.messages.filter((msg) => msg.role !== "system");
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "---BEGIN IMPORTANT CONTEXT---\n" + opts.messages[last_system_idx].content + "\n---END IMPORTANT CONTEXT---\n\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      const body = {
        contents: messages.filter((msg) => msg.role !== "system").map((msg) => {
          const content = {};
          content.role = msg.role === "assistant" ? "model" : msg.role;
          content.parts = !Array.isArray(msg.content) ? [{ text: msg.content }] : msg.content.map((c) => {
            if (c.type === "text") {
              return { text: c.text };
            }
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let mime_type = image_url.split(":")[1].split(";")[0];
              if (mime_type === "image/jpg")
                mime_type = "image/jpeg";
              return { inline_data: { mime_type, data: image_url.split(",")[1] } };
            }
          });
          return content;
          ({
            role: msg.role === "assistant" ? "model" : msg.role,
            parts: Array.isArray(msg.content) ? [{ text: msg.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") }] : [{ text: msg.content }]
          });
        }),
        generationConfig: {
          temperature: opts.temperature || 0.9,
          topK: opts.topK || 1,
          topP: opts.topP || 1,
          maxOutputTokens: opts.max_tokens || 2048,
          stopSequences: opts.stopSequences || [],
          candidate_count: opts.n || 1
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_NONE"
          }
        ]
      };
      const system_instructions = opts.messages.filter((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (system_instructions.length > 0)
        body.systemInstruction = { parts: system_instructions.map((msg) => ({ text: msg.content })) };
      if (opts.tools) {
        body.tools = [{
          function_declarations: opts.tools.map((tool) => ({
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }))
        }];
        if (opts.tool_choice) {
          if (opts.tool_choice !== "auto") {
            if (opts.model.includes("1.5-pro")) {
              body.tool_config = {
                function_calling_config: {
                  mode: "ANY",
                  allowed_function_names: opts.tools.map((tool) => tool.function.name)
                }
              };
            } else {
              body.systemInstruction = {
                role: "user",
                parts: [
                  {
                    text: `IMPORTANT: You must use the "${body.tools[0].function_declarations[0].name}" function tool!`
                  }
                ]
              };
              const tool_prompt = `IMPORTANT: You must use the "${body.tools[0].function_declarations[0].name}" function tool!`;
              const last_user_idx = body.contents.findLastIndex((msg) => msg.role === "user");
              body.contents[last_user_idx].parts[0].text += "\n\n" + tool_prompt;
            }
          }
        }
      }
      return body;
    }
    exports.chatml_to_gemini = chatml_to_gemini;
  }
});

// node_modules/smart-chat-model/adapters.js
var require_adapters = __commonJS({
  "node_modules/smart-chat-model/adapters.js"(exports) {
    var { AnthropicAdapter } = require_anthropic();
    var { CohereAdapter } = require_cohere();
    var { GeminiAdapter } = require_gemini();
    exports.Anthropic = AnthropicAdapter;
    exports.Cohere = CohereAdapter;
    exports.Gemini = GeminiAdapter;
  }
});

// node_modules/smart-chat-model/platforms.json
var require_platforms = __commonJS({
  "node_modules/smart-chat-model/platforms.json"(exports, module2) {
    module2.exports = {
      openai: {
        description: "OpenAI",
        type: "API",
        endpoint: "https://api.openai.com/v1/chat/completions",
        streaming: true,
        actions: true,
        fetch_models: true,
        default_model: "gpt-3.5-turbo",
        signup_url: "https://platform.openai.com/api-keys"
      },
      google_gemini: {
        description: "Google Gemini",
        type: "API",
        api_key_header: "none",
        endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
        endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
        streaming: true,
        actions: true,
        adapter: "Gemini",
        fetch_models: true,
        default_model: "gemini-1.0-pro",
        signup_url: "https://ai.google.dev/"
      },
      open_router: {
        description: "Open Router",
        type: "API",
        endpoint: "https://openrouter.ai/api/v1/chat/completions",
        streaming: true,
        fetch_models: true,
        default_model: "mistralai/mistral-7b-instruct:free",
        signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
      },
      cohere: {
        description: "Cohere Command-R",
        type: "API",
        endpoint: "https://api.cohere.ai/v1/chat",
        streaming: false,
        adapter: "Cohere",
        fetch_models: true,
        default_model: "command-r",
        signup_url: "https://dashboard.cohere.com/welcome/register?redirect_uri=%2Fapi-keys"
      },
      anthropic: {
        description: "Anthropic Claude",
        type: "API",
        endpoint: "https://api.anthropic.com/v1/messages",
        streaming: false,
        api_key_header: "x-api-key",
        headers: {
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "tools-2024-04-04"
        },
        adapter: "Anthropic",
        actions: true,
        fetch_models: true,
        default_model: "claude-3-sonnet-20240229",
        signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
      },
      custom_local: {
        description: "Custom Local (OpenAI format)",
        type: "API"
      },
      custom_api: {
        description: "Custom API (OpenAI format)",
        type: "API"
      }
    };
  }
});

// node_modules/smart-chat-model/utils/is_valid_tool_call.js
var require_is_valid_tool_call = __commonJS({
  "node_modules/smart-chat-model/utils/is_valid_tool_call.js"(exports) {
    function is_valid_tool_call(tool, tool_call_content) {
      var _a;
      const props = tool.function.parameters.properties;
      if (typeof props !== "undefined" && Object.keys(tool_call_content).length === 0)
        throw new Error(`Invalid tool call: object is empty`);
      Object.entries(tool_call_content).forEach(([key, value]) => {
        if (!props[key])
          throw new Error(`Invalid tool call: missing key ${key} in tool spec`, props);
        if (Array.isArray(value) && props[key].type === "array") {
          const itemType = typeof value[0];
          if (!value.every((item) => typeof item === itemType))
            throw new Error(`Invalid tool call: array items are not of the same type`);
          if (props[key].items.type !== itemType)
            throw new Error(`Invalid tool call: array items are not of the same type as the spec`);
        } else if (props[key].type !== typeof value) {
          if (props[key].type === "number" && typeof value === "string") {
            if (isNaN(Number(value)))
              throw new Error(`Invalid tool call: value ${value} is not a valid number`);
            tool_call_content[key] = Number(value);
          } else
            throw new Error(`Invalid tool call: value ${value} is not of type ${props[key].type}`);
        }
        if (props[key].enum && !props[key].enum.includes(value))
          throw new Error(`Invalid tool call: value ${value} is not in enum ${props[key].enum}`);
      });
      (_a = tool.function.parameters.required) == null ? void 0 : _a.forEach((key) => {
        if (!tool_call_content[key])
          throw new Error(`Invalid tool call: missing required key ${key}`);
      });
      return true;
    }
    exports.is_valid_tool_call = is_valid_tool_call;
  }
});

// node_modules/smart-chat-model/streamer.js
var require_streamer = __commonJS({
  "node_modules/smart-chat-model/streamer.js"(exports) {
    var _setReadyState, setReadyState_fn, _onStreamFailure, onStreamFailure_fn, _onStreamAbort, onStreamAbort_fn, _onStreamProgress, onStreamProgress_fn, _onStreamLoaded, onStreamLoaded_fn, _parseEventChunk, parseEventChunk_fn, _checkStreamClosed, checkStreamClosed_fn;
    var SmartStreamer = class {
      constructor(url, options = {}) {
        // private methods
        __privateAdd(this, _setReadyState);
        __privateAdd(this, _onStreamFailure);
        __privateAdd(this, _onStreamAbort);
        __privateAdd(this, _onStreamProgress);
        __privateAdd(this, _onStreamLoaded);
        __privateAdd(this, _parseEventChunk);
        __privateAdd(this, _checkStreamClosed);
        const {
          method = "GET",
          headers = {},
          body = null,
          withCredentials = false
        } = options;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.body = body;
        this.withCredentials = withCredentials;
        this.listeners = {};
        this.readyState = this.CONNECTING;
        this.progress = 0;
        this.chunk = "";
        this.last_event_id = "";
        this.xhr = null;
        this.FIELD_SEPARATOR = ":";
        this.INITIALIZING = -1;
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSED = 2;
      }
      /**
       * Adds an event listener for the specified event type.
       *
       * @param {string} type - The type of the event.
       * @param {Function} listener - The listener function to be called when the event is triggered.
       */
      addEventListener(type, listener) {
        if (!this.listeners[type])
          this.listeners[type] = [];
        if (!this.listeners[type].includes(listener))
          this.listeners[type].push(listener);
      }
      /**
       * Removes an event listener from the SmartStreamer instance.
       *
       * @param {string} type - The type of event to remove the listener from.
       * @param {Function} listener - The listener function to remove.
       */
      removeEventListener(type, listener) {
        if (!this.listeners[type])
          return;
        this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
        if (this.listeners[type].length === 0)
          delete this.listeners[type];
      }
      /**
       * Dispatches an event to the appropriate event handlers.
       *
       * @param {Event} event - The event to be dispatched.
       * @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
       */
      dispatchEvent(event) {
        if (!event)
          return true;
        event.source = this;
        const onHandler = "on" + event.type;
        if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
          this[onHandler].call(this, event);
          if (event.defaultPrevented)
            return false;
        }
        if (this.listeners[event.type]) {
          this.listeners[event.type].forEach((callback) => {
            callback(event);
            return !event.defaultPrevented;
          });
        }
        return true;
      }
      /**
       * Initiates the streaming process.
       */
      stream() {
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CONNECTING);
        this.xhr = new XMLHttpRequest();
        this.xhr.addEventListener("progress", __privateMethod(this, _onStreamProgress, onStreamProgress_fn).bind(this));
        this.xhr.addEventListener("load", __privateMethod(this, _onStreamLoaded, onStreamLoaded_fn).bind(this));
        this.xhr.addEventListener("readystatechange", __privateMethod(this, _checkStreamClosed, checkStreamClosed_fn).bind(this));
        this.xhr.addEventListener("error", __privateMethod(this, _onStreamFailure, onStreamFailure_fn).bind(this));
        this.xhr.addEventListener("abort", __privateMethod(this, _onStreamAbort, onStreamAbort_fn).bind(this));
        this.xhr.open(this.method, this.url);
        for (const header in this.headers) {
          this.xhr.setRequestHeader(header, this.headers[header]);
        }
        if (this.last_event_id)
          this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
        this.xhr.withCredentials = this.withCredentials;
        this.xhr.send(this.body);
      }
      /**
       * Ends the streamer connection.
       * Aborts the current XHR request and sets the ready state to CLOSED.
       */
      end() {
        if (this.readyState === this.CLOSED)
          return;
        this.xhr.abort();
        this.xhr = null;
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
      }
    };
    _setReadyState = new WeakSet();
    setReadyState_fn = function(state) {
      const event = new CustomEvent("readyStateChange");
      event.readyState = state;
      this.readyState = state;
      this.dispatchEvent(event);
    };
    _onStreamFailure = new WeakSet();
    onStreamFailure_fn = function(e) {
      const event = new CustomEvent("error");
      event.data = e.currentTarget.response;
      this.dispatchEvent(event);
      this.end();
    };
    _onStreamAbort = new WeakSet();
    onStreamAbort_fn = function(e) {
      const event = new CustomEvent("abort");
      this.end();
    };
    _onStreamProgress = new WeakSet();
    onStreamProgress_fn = function(e) {
      if (!this.xhr)
        return;
      if (this.xhr.status !== 200) {
        __privateMethod(this, _onStreamFailure, onStreamFailure_fn).call(this, e);
        return;
      }
      if (this.readyState === this.CONNECTING) {
        this.dispatchEvent(new CustomEvent("open"));
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.OPEN);
      }
      const data = this.xhr.responseText.substring(this.progress);
      this.progress += data.length;
      data.split(/(\r\n|\r|\n)/g).forEach((part) => {
        if (part.trim().length === 0) {
          this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk.trim()));
          this.chunk = "";
        } else {
          this.chunk += part;
        }
      });
    };
    _onStreamLoaded = new WeakSet();
    onStreamLoaded_fn = function(e) {
      __privateMethod(this, _onStreamProgress, onStreamProgress_fn).call(this, e);
      this.dispatchEvent(__privateMethod(this, _parseEventChunk, parseEventChunk_fn).call(this, this.chunk));
      this.chunk = "";
    };
    _parseEventChunk = new WeakSet();
    parseEventChunk_fn = function(chunk) {
      if (!chunk || chunk.length === 0)
        return null;
      const e = { id: null, retry: null, data: "", event: "message", text: "" };
      chunk.split(/(\r\n|\r|\n)/).forEach((line) => {
        line = line.trim();
        const index = line.indexOf(this.FIELD_SEPARATOR);
        if (index <= 0)
          return;
        const field = line.substring(0, index).replace(/^"|"$/g, "");
        if (!["id", "retry", "data", "event", "text"].includes(field))
          return;
        const value = line.substring(index + 1).trim().replace(/^"|"$/g, "");
        e.data += value;
      });
      if (e.id)
        this.last_event_id = e.id;
      const event = new CustomEvent(e.event || "message");
      event.id = e.id;
      event.data = e.data || "";
      event.last_event_id = this.last_event_id;
      return event;
    };
    _checkStreamClosed = new WeakSet();
    checkStreamClosed_fn = function() {
      if (!this.xhr)
        return;
      if (this.xhr.readyState === XMLHttpRequest.DONE)
        __privateMethod(this, _setReadyState, setReadyState_fn).call(this, this.CLOSED);
    };
    exports.SmartStreamer = SmartStreamer;
  }
});

// node_modules/smart-chat-model/models/open_router.js
var require_open_router = __commonJS({
  "node_modules/smart-chat-model/models/open_router.js"(exports) {
    async function fetch_open_router_models() {
      try {
        const response = await fetch("https://openrouter.ai/api/v1/models");
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.data.map((model) => ({
          model_name: model.id,
          key: model.id,
          max_input_tokens: model.context_length,
          description: model.name,
          actions: model.description.includes("tool use") || model.description.includes("function call"),
          multimodal: model.architecture.modality === "multimodal",
          raw: model
        }));
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_open_router_models = fetch_open_router_models;
  }
});

// node_modules/smart-chat-model/models/openai.js
var require_openai = __commonJS({
  "node_modules/smart-chat-model/models/openai.js"(exports) {
    var model_context = {
      "gpt-3.5-turbo-0125": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-0301": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-0613": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-1106": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-16k": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-3.5-turbo-16k-0613": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-4-0125-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-0314": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-0613": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-1106-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-1106-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k-0314": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-32k-0613": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-turbo-2024-04-09": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-turbo-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-3.5-turbo": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-4-turbo": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4o": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4": {
        "context": 8192,
        "max_out": 8192
      }
    };
    async function fetch_openai_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          headers: {
            "Authorization": `Bearer ${api_key}`
          }
        });
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.data.filter((model) => model.id.startsWith("gpt-") && !model.id.includes("-instruct")).map((model) => {
          const out = {
            model_name: model.id,
            key: model.id,
            multimodal: model.id.includes("vision") || model.id.includes("gpt-4-turbo")
          };
          const m = Object.entries(model_context).find((m2) => m2[0] === model.id || model.id.startsWith(m2[0] + "-"));
          if (m) {
            out.max_input_tokens = m[1].context;
            out.description = `context: ${m[1].context}, output: ${m[1].max_out}`;
          }
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_openai_models = fetch_openai_models;
  }
});

// node_modules/smart-chat-model/models/google_gemini.js
var require_google_gemini = __commonJS({
  "node_modules/smart-chat-model/models/google_gemini.js"(exports) {
    async function fetch_google_gemini_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models?key=" + api_key);
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("models/gemini")).map((model) => {
          const out = {
            model_name: model.name.split("/").pop(),
            key: model.name.split("/").pop(),
            max_input_tokens: model.inputTokenLimit,
            max_output_tokens: model.maxOutputTokens,
            description: model.description,
            multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
            raw: model
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_google_gemini_models = fetch_google_gemini_models;
  }
});

// node_modules/smart-chat-model/models/cohere.js
var require_cohere2 = __commonJS({
  "node_modules/smart-chat-model/models/cohere.js"(exports) {
    async function fetch_cohere_models(api_key) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        const response = await fetch("https://api.cohere.ai/v1/models", {
          headers: {
            "Authorization": `Bearer ${api_key}`
          }
        });
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("command-")).map((model) => {
          const out = {
            model_name: model.name,
            key: model.name,
            max_input_tokens: model.context_length,
            tokenizer_url: model.tokenizer_url,
            finetuned: model.finetuned,
            description: `Max input tokens: ${model.context_length}, Finetuned: ${model.finetuned}`
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports.fetch_cohere_models = fetch_cohere_models;
  }
});

// node_modules/smart-chat-model/models/anthropic.js
var require_anthropic2 = __commonJS({
  "node_modules/smart-chat-model/models/anthropic.js"(exports) {
    async function fetch_anthropic_models() {
      return [
        {
          "key": "claude-3-opus-20240229",
          "model_name": "claude-3-opus-20240229",
          "description": "Anthropic's Claude Opus",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-sonnet-20240229",
          "model_name": "claude-3-sonnet-20240229",
          "description": "Anthropic's Claude Sonnet",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-haiku-20240307",
          "model_name": "claude-3-haiku-20240307",
          "description": "Anthropic's Claude Haiku",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        }
      ];
    }
    exports.fetch_anthropic_models = fetch_anthropic_models;
  }
});

// node_modules/smart-chat-model/models/fetch.js
var require_fetch = __commonJS({
  "node_modules/smart-chat-model/models/fetch.js"(exports) {
    var { fetch_open_router_models } = require_open_router();
    var { fetch_openai_models } = require_openai();
    var { fetch_google_gemini_models } = require_google_gemini();
    var { fetch_cohere_models } = require_cohere2();
    var { fetch_anthropic_models } = require_anthropic2();
    exports.open_router = fetch_open_router_models;
    exports.openai = fetch_openai_models;
    exports.google_gemini = fetch_google_gemini_models;
    exports.cohere = fetch_cohere_models;
    exports.anthropic = fetch_anthropic_models;
  }
});

// node_modules/smart-chat-model/smart_chat_model.js
var require_smart_chat_model = __commonJS({
  "node_modules/smart-chat-model/smart_chat_model.js"(exports) {
    var adapters = require_adapters();
    var platforms = require_platforms();
    var { is_valid_tool_call } = require_is_valid_tool_call();
    var { SmartStreamer } = require_streamer();
    var fetch_models = require_fetch();
    var SmartChatModel2 = class {
      /**
       * Constructs an instance of SmartChatModel with specified environment, model key, and options.
       * @param {Object} main - The main environment context, typically containing configurations and state.
       * @param {string} platform_key - Key to select the specific model configuration from models.json.
       * @param {Object} model_config - Optional parameters to override model configurations.
       */
      constructor(main, platform_key, model_config = {}) {
        this.env = main;
        this.main = this.env;
        this.config = {
          ...platforms[platform_key] || {},
          ...model_config
          // override default platform config
        };
        this.platform_key = platform_key;
        this.active_stream = null;
        this._request_adapter = null;
        this.platforms = platforms;
        if (this.config.adapter)
          this.adapter = new adapters[this.config.adapter](this);
        console.log(this.adapter);
      }
      static get models() {
        return platforms;
      }
      get default_opts() {
        return {
          temperature: 0.3,
          top_p: 1,
          presence_penalty: 0,
          frequency_penalty: 0,
          n: 1,
          model: this.model_name,
          max_tokens: this.max_output_tokens
        };
      }
      async request_middlewares(opts) {
        return opts;
      }
      /**
       * Completes the chat interaction by processing the provided options, making an API request, and handling the response.
       * This method supports both streaming and non-streaming responses, and can handle tool calls if specified in the response.
       *
       * @param {Object} opts - The options for the chat completion which may include settings like temperature, max tokens, etc.
       * @param {boolean} render - Flag to determine if the response should be rendered in the UI.
       * @returns {Promise<string|void>} - Returns the chat response content or handles tool outputs recursively. In case of errors, it may return an error message.
       */
      async complete(opts = {}, render = true) {
        var _a, _b, _c, _d, _e;
        if (!this.base_model_config) {
          this.base_model_config = await this.get_base_model_config();
          this.config = {
            ...this.base_model_config,
            ...this.config
          };
        }
        opts = {
          ...this.default_opts,
          messages: ((_b = await ((_a = this.current) == null ? void 0 : _a.get_chat_ml())) == null ? void 0 : _b.messages) || [],
          ...opts
        };
        if (opts.stream !== false && this.config.streaming && !((_c = this.current) == null ? void 0 : _c.tool_choice))
          opts.stream = true;
        else
          opts.stream = false;
        opts = await this.request_middlewares(JSON.parse(JSON.stringify(opts)));
        const req = {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.api_key}`
          },
          method: "POST"
        };
        if (this.config.headers)
          req.headers = { ...req.headers, ...this.config.headers };
        if (this.config.api_key_header) {
          if (this.config.api_key_header !== "none")
            req.headers[this.config.api_key_header] = this.api_key;
          delete req.headers.Authorization;
        }
        const body = typeof ((_d = this.env.actions) == null ? void 0 : _d.prepare_request_body) === "function" ? this.env.actions.prepare_request_body(opts) : { ...opts };
        req.body = JSON.stringify(typeof ((_e = this.adapter) == null ? void 0 : _e.prepare_request_body) === "function" ? this.adapter.prepare_request_body(body) : body);
        console.log(req);
        try {
          if (opts.stream)
            return await this.stream(req);
          const resp_json = await this.request(req);
          if (resp_json.error) {
            console.error(resp_json.error);
            if (render)
              this.done_handler("*API Error. See console logs for details.*");
            return;
          }
          const tool_call = this.get_tool_call(resp_json);
          if (tool_call) {
            this.env.chats.current.tool_choice = null;
            const tool_name = this.get_tool_name(tool_call);
            const tool_call_content = this.get_tool_call_content(tool_call);
            const tool = body.tools.find((t) => t.function.name === tool_name);
            if (is_valid_tool_call(tool, tool_call_content)) {
              await this.current.add_message({ role: "assistant", tool_calls: [{
                function: {
                  name: tool_name,
                  arguments: JSON.stringify(tool_call_content)
                }
              }] });
              const tool_handler = this.get_tool_handler(tool_name);
              if (!tool_handler)
                return console.error(`Tool ${tool_name} not found`);
              const tool_output = await tool_handler(this.env, tool_call_content);
              if (tool_output) {
                await this.current.add_tool_output(tool_name, tool_output);
                this.current.tool_choice = "none";
                return this.complete({});
              }
            } else {
              console.error(`Invalid tool call: ${tool_call}`);
              if (render)
                this.done_handler("*Invalid tool call. See console logs for details.*");
              return "*Invalid tool call. See console logs for details.*";
            }
          }
          if (render)
            this.done_handler(this.get_message_content(resp_json));
          return this.get_message_content(resp_json);
        } catch (err) {
          console.error(err);
        }
      }
      // HANDLE TOOLS
      /**
       * Retrieves the tool handler function based on the tool name from the environment's actions.
       * This method can be overridden to use custom logic for handling tools.
       * 
       * @param {string} tool_name - The name of the tool for which the handler is to be retrieved.
       * @returns {Function} The handler function for the specified tool.
       */
      get_tool_handler(tool_name) {
        return this.env.actions.actions[tool_name].handler;
      }
      /**
       * Extracts the tool call information from a JSON response. This method supports adapter-specific logic.
       * If no adapter method is provided, it defaults to the expected OpenAI JSON format.
       * 
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object} The first tool call found in the response.
       */
      get_tool_call(json) {
        var _a, _b, _c;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call) === "function")
          return this.adapter.get_tool_call(json);
        return (_c = (_b = json.choices) == null ? void 0 : _b[0].message.tool_calls) == null ? void 0 : _c[0];
      }
      /**
       * Determines the tool name from a tool call object. Supports adapter-specific implementations.
       * Defaults to extracting the name directly from the tool call structure.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the tool name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_name) === "function")
          return this.adapter.get_tool_name(tool_call);
        return tool_call.function.name;
      }
      /**
       * Extracts the tool call content from a tool call object. Supports adapter-specific logic.
       * Defaults to parsing the 'arguments' field of the tool call function as JSON.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the content.
       * @returns {Object} The parsed arguments of the tool call.
       */
      get_tool_call_content(tool_call) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_tool_call_content) === "function")
          return this.adapter.get_tool_call_content(tool_call);
        return JSON.parse(tool_call.function.arguments);
      }
      // HANDLE MESSAGES
      /**
       * Retrieves the message object from a JSON response. Supports adapter-specific implementations.
       * Defaults to handling both OpenAI and Ollama formats by checking for message structures in 'choices'.
       * 
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object} The message object extracted from the response.
       */
      get_message(json) {
        var _a, _b;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message) === "function")
          return this.adapter.get_message(json);
        return ((_b = json.choices) == null ? void 0 : _b[0].message) || json.message;
      }
      /**
       * Extracts the content of a message from a JSON response. Supports adapter-specific implementations.
       * This method relies on `get_message` to first retrieve the message object.
       * 
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string} The content of the message.
       */
      get_message_content(json) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_message_content) === "function")
          return this.adapter.get_message_content(json);
        return this.get_message(json).content;
      }
      async request(req) {
        req.url = this.endpoint;
        req.throw = false;
        const resp = this._request_adapter ? await this._request_adapter(req) : await fetch(this.endpoint, req);
        console.log(resp);
        const resp_json = await this.get_resp_json(resp);
        console.log(resp_json);
        return resp_json;
      }
      async get_resp_json(resp) {
        return typeof resp.json === "function" ? await resp.json() : await resp.json;
      }
      get request_adapter() {
        return this._request_adapter;
      }
      async stream(req) {
        console.log("Streaming Request: ");
        console.log(req);
        const full_text = await new Promise((resolve, reject) => {
          try {
            this.active_stream = new SmartStreamer(this.endpoint_streaming, req);
            let curr_text = "";
            this.active_stream.addEventListener("message", (e) => {
              if (this.is_end_of_stream(e)) {
                this.stop_stream();
                return resolve(curr_text);
              }
              let text_chunk = this.get_text_chunk_from_stream(e);
              if (!text_chunk)
                return;
              curr_text += text_chunk;
              this.chunk_handler(text_chunk);
            });
            this.active_stream.addEventListener("readystatechange", (e) => {
              if (e.readyState >= 2)
                console.log("ReadyState: " + e.readyState);
            });
            this.active_stream.addEventListener("error", (e) => {
              console.error(e);
              this.done_handler("*API Error. See console logs for details.*");
              this.stop_stream();
              reject(e);
            });
            this.active_stream.stream();
          } catch (err) {
            console.error(err);
            this.stop_stream();
            reject(err);
          }
        });
        this.done_handler(full_text);
        return full_text;
      }
      get_text_chunk_from_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.get_text_chunk_from_stream) === "function")
          return this.adapter.get_text_chunk_from_stream(event);
        let resp = null;
        let text_chunk = "";
        try {
          resp = JSON.parse(event.data);
          text_chunk = resp.choices[0].delta.content;
        } catch (err) {
          console.log(err);
          console.log(event.data);
          if (event.data.indexOf("}{") > -1)
            event.data = event.data.replace(/}{/g, "},{");
          resp = JSON.parse(`[${event.data}]`);
          resp.forEach((r) => {
            if (r.choices)
              text_chunk += r.choices[0].delta.content;
          });
        }
        return text_chunk;
      }
      is_end_of_stream(event) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.is_end_of_stream) === "function")
          return this.adapter.is_end_of_stream(event);
        return event.data === "[DONE]";
      }
      stop_stream() {
        if (this.active_stream) {
          this.active_stream.end();
          this.active_stream = null;
        }
      }
      done_handler(full_str) {
        if (typeof this.main.done_handler === "function")
          this.main.done_handler(full_str);
      }
      chunk_handler(text_chunk) {
        if (typeof this.main.chunk_handler === "function")
          this.main.chunk_handler(text_chunk);
      }
      async count_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.count_tokens) === "function")
          return await this.adapter.count_tokens(input);
        return this.estimate_tokens(input);
      }
      estimate_tokens(input) {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.estimate_tokens) === "function")
          return this.adapter.estimate_tokens(input);
        if (typeof input === "object")
          input = JSON.stringify(input);
        return input.length / 4;
      }
      async test_api_key() {
        console.log(this.api_key);
        try {
          const request = {
            messages: [
              { role: "user", content: "Hello" }
            ],
            temperature: 0,
            max_tokens: 100,
            stream: false,
            n: 1
          };
          if (this.config.fetch_models) {
            request.model = this.config.default_model;
          }
          const resp = await this.complete(request, false);
          console.log(resp);
          if (!resp)
            return false;
          return true;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      async get_models() {
        var _a;
        if (((_a = this.platforms[this.platform_key]) == null ? void 0 : _a.fetch_models) && typeof fetch_models[this.platform_key] === "function") {
          const models = await fetch_models[this.platform_key](this.api_key);
          if (models) {
            models.sort((a, b) => a.model_name.localeCompare(b.model_name));
            return models;
          } else
            console.error(`No models found for ${this.platform_key}`, models);
        }
        return [];
      }
      async get_base_model_config() {
        const models = await this.get_models();
        return models.find((m) => m.key === this.model_name);
      }
      // getters
      get api_key() {
        return this.config.api_key;
      }
      get current() {
        var _a;
        return (_a = this.env.chats) == null ? void 0 : _a.current;
      }
      // use endpoint of combine protocol, hostname, port, and path
      get endpoint() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint) !== "undefined")
          return this.adapter.endpoint.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint || this.config.protocol + "://" + this.config.hostname + (this.config.port ? ":" + this.config.port : "") + this.endpoint_path;
      }
      get endpoint_streaming() {
        var _a;
        if (typeof ((_a = this.adapter) == null ? void 0 : _a.endpoint_streaming) !== "undefined")
          return this.adapter.endpoint_streaming.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint_streaming || this.endpoint;
      }
      get endpoint_path() {
        return this.config.path.startsWith("/") ? this.config.path : "/" + this.config.path;
      }
      get max_input_tokens() {
        return this.config.max_input_tokens;
      }
      get max_output_tokens() {
        return this.config.max_output_tokens;
      }
      get model_name() {
        return this.config.model_name || this.config.default_model;
      }
      get multimodal() {
        var _a;
        return typeof ((_a = this.adapter) == null ? void 0 : _a.multimodal) !== "undefined" ? this.adapter.multimodal : this.config.multimodal;
      }
    };
    exports.SmartChatModel = SmartChatModel2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SmartMemosPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// SmartMemosAudioRecordModal.ts
var import_obsidian = require("obsidian");
var SmartMemosAudioRecordModal = class extends import_obsidian.Modal {
  // Flag to track reset state
  constructor(app, handleAudioRecording) {
    super(app);
    this.mediaRecorder = null;
    this.chunks = [];
    this.isRecording = false;
    this.intervalId = null;
    this.startTime = 0;
    this.elapsedTime = 0;
    this.isResetting = false;
    this.handleAudioRecording = handleAudioRecording;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    if (!contentEl || !modalEl) {
      console.error("contentEl or modalEl is null");
      return;
    }
    modalEl.addClass("smart-memo-recording");
    const headerTimerContainer = contentEl.createDiv({ cls: "smart-memo-header-timer-container" });
    const header = headerTimerContainer.createEl("h2", { text: "Recording...", cls: "smart-memo-recording-header" });
    this.timer = headerTimerContainer.createEl("div", { cls: "smart-memo-timer", text: "00:00" });
    contentEl.addClass("smart-memo-audio-record-modal-content");
    const redDotContainer = contentEl.createDiv({ cls: "smart-memo-red-dot-container" });
    this.redDot = redDotContainer.createDiv({ cls: "smart-memo-red-dot" });
    const controlGroupWrapper = contentEl.createDiv({ cls: "smart-memo-control-group-wrapper" });
    const controlGroup = controlGroupWrapper.createDiv({ cls: "smart-memo-modal-button-group" });
    const playPauseButton = controlGroup.createEl("button", { cls: "smart-memo-modal-button smart-memo-flex" });
    const stopButton = controlGroup.createEl("button", { cls: "smart-memo-modal-button smart-memo-flex" });
    (0, import_obsidian.setIcon)(playPauseButton, "pause");
    (0, import_obsidian.setIcon)(stopButton, "square");
    stopButton.addEventListener("click", async () => {
      const audioFile = await this.stopRecording();
      this.handleAudioRecording(audioFile, false);
    });
    playPauseButton.addEventListener("click", () => {
      if (this.isRecording) {
        this.pauseRecording();
        (0, import_obsidian.setIcon)(playPauseButton, "circle");
        header.textContent = "Paused";
        modalEl.addClass("smart-memo-paused");
        modalEl.removeClass("smart-memo-recording");
      } else {
        this.resumeOrStartRecording();
        (0, import_obsidian.setIcon)(playPauseButton, "pause");
        header.textContent = "Recording...";
        modalEl.removeClass("smart-memo-paused");
        modalEl.addClass("smart-memo-recording");
      }
      this.isRecording = !this.isRecording;
    });
    const transcribeButton = controlGroupWrapper.createEl("button", { cls: "smart-memo-modal-button smart-memo-full-width-button smart-memo-transcribe-button" });
    transcribeButton.addEventListener("click", async () => {
      const audioFile = await this.stopRecording();
      this.handleAudioRecording(audioFile, true);
    });
    (0, import_obsidian.setIcon)(transcribeButton, "file-text");
    const buttonText = document.createTextNode(" Smart Transcribe");
    transcribeButton.appendChild(buttonText);
    const svgElement = transcribeButton.querySelector("svg");
    if (svgElement) {
      svgElement.style.marginRight = "10px";
    }
    const resetButton = contentEl.createEl("button", { cls: "smart-memo-modal-button smart-memo-full-width-button smart-memo-reset-button", text: "Restart" });
    resetButton.addEventListener("click", () => {
      this.hardReset();
      (0, import_obsidian.setIcon)(playPauseButton, "circle");
      header.textContent = "Ready to Record";
      this.isRecording = false;
      modalEl.addClass("smart-memo-paused");
      modalEl.removeClass("smart-memo-recording");
      this.redDot.classList.remove("smart-memo-pulse-animation");
    });
    this.startRecording();
    this.isRecording = true;
    this.redDot.classList.add("smart-memo-pulse-animation");
    const activeElement = document.activeElement;
    if (activeElement) {
      activeElement.blur();
    }
  }
  startRecording() {
    navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
      this.mediaRecorder = new MediaRecorder(stream);
      this.setupMediaRecorder();
      this.mediaRecorder.start(1e3);
      this.startTime = Date.now();
      this.startTimer();
      this.mediaRecorder.addEventListener("dataavailable", this.onDataAvailable.bind(this));
    }).catch((error) => {
      console.error("Error accessing microphone:", error);
      this.reject(error);
    });
  }
  setupMediaRecorder() {
    if (this.mediaRecorder) {
      this.mediaRecorder.addEventListener("stop", this.onStop.bind(this));
    }
  }
  onDataAvailable(event) {
    if (this.isResetting) {
      return;
    }
    this.chunks.push(event.data);
  }
  onStop() {
    if (this.isResetting) {
      this.isResetting = false;
      return;
    }
    const blob = new Blob(this.chunks, { type: "audio/wav" });
    if (this.resolve) {
      this.resolve(blob);
      this.close();
    } else {
      console.error("Resolve function is not defined");
    }
  }
  pauseRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      this.mediaRecorder.pause();
      this.stopTimer();
      this.elapsedTime += Date.now() - this.startTime;
      this.redDot.classList.remove("smart-memo-pulse-animation");
    }
  }
  resumeOrStartRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "paused") {
      this.mediaRecorder.resume();
    } else {
      this.startRecording();
    }
    this.startTime = Date.now();
    this.startTimer();
    this.redDot.classList.add("smart-memo-pulse-animation");
  }
  hardReset() {
    if (this.mediaRecorder) {
      this.mediaRecorder.stop();
      this.mediaRecorder.onstop = null;
      this.mediaRecorder.ondataavailable = null;
      this.mediaRecorder = null;
    }
    this.isResetting = true;
    this.chunks = [];
    this.elapsedTime = 0;
    this.stopTimer();
    this.timer.textContent = "00:00";
    this.redDot.classList.remove("smart-memo-pulse-animation");
  }
  stopRecording() {
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      if (this.mediaRecorder) {
        this.mediaRecorder.addEventListener("stop", this.onStop.bind(this));
        this.mediaRecorder.stop();
        this.stopTimer();
      } else {
        resolve(null);
      }
    });
  }
  startTimer() {
    this.stopTimer();
    this.intervalId = window.setInterval(() => {
      const elapsedTimeInSeconds = Math.floor(this.elapsedTime / 1e3) + Math.floor((Date.now() - this.startTime) / 1e3);
      const minutes = Math.floor(elapsedTimeInSeconds / 60);
      const seconds = elapsedTimeInSeconds % 60;
      this.timer.textContent = `${this.padNumber(minutes)}:${this.padNumber(seconds)}`;
    }, 1e3);
  }
  stopTimer() {
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  padNumber(num) {
    return num.toString().padStart(2, "0");
  }
  open() {
    super.open();
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};

// Utils.ts
var import_obsidian2 = require("obsidian");
async function saveFile(app, audioBlob, fileName, path) {
  try {
    const normalizedPath = (0, import_obsidian2.normalizePath)(path);
    const filePath = `${normalizedPath}/${fileName}`;
    await ensureDirectoryExists(app, normalizedPath);
    const arrayBuffer = await audioBlob.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    const file = await app.vault.createBinary(filePath, uint8Array);
    if (!file) {
      throw new Error("File creation failed and returned null");
    }
    return file;
  } catch (error) {
    console.error("Error saving audio file:", error);
    throw error;
  }
}
async function ensureDirectoryExists(app, folderPath) {
  const parts = folderPath.split("/");
  let currentPath = "";
  for (const part of parts) {
    currentPath = currentPath ? `${currentPath}/${part}` : part;
    try {
      const folder = app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await app.vault.createFolder(currentPath);
      } else if (folder instanceof import_obsidian2.TFolder) {
        console.log(`Folder already exists: ${currentPath}`);
      } else {
        throw new Error(`${currentPath} is not a folder`);
      }
    } catch (error) {
      if (error.message.includes("Folder already exists")) {
        console.log(`Handled existing folder: ${currentPath}`);
      } else {
        console.error(`Error ensuring directory exists: ${error.message}`);
        throw error;
      }
    }
  }
}

// main.ts
var { SmartChatModel } = require_smart_chat_model();
var DEFAULT_SETTINGS = {
  model: "gpt-4-0613",
  apiKey: "",
  prompt: `You are an expert note-making AI for obsidian who specializes in the Linking Your Thinking (LYK) strategy.  The following is a transcription of recording of someone talking aloud or people in a conversation. There may be a lot of random things said given fluidity of conversation or thought process and the microphone's ability to pick up all audio.  Give me detailed notes in markdown language on what was said in the most easy-to-understand, detailed, and conceptual format.  Include any helpful information that can conceptualize the notes further or enhance the ideas, and then summarize what was said.  Do not mention "the speaker" anywhere in your response.  The notes your write should be written as if I were writting them. Finally, ensure to end with code for a mermaid chart that shows an enlightening concept map combining both the transcription and the information you added to it.  The following is the transcribed audio:

`,
  includeTranscript: true,
  recordingFilePath: ""
};
var MODELS = [
  "gpt-3.5-turbo-16k",
  "gpt-3.5-turbo-0613",
  "text-davinci-003",
  "text-davinci-002",
  "code-davinci-002",
  "code-davinci-001",
  "gpt-4-0613",
  "gpt-4-32k-0613",
  "gpt-4o"
];
var SmartMemosPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.apiKey = "sk-as123mkqwenjasdasdj12...";
    this.model = "gpt-4-0613";
  }
  async onload() {
    await this.loadSettings();
    const app_json = await this.app.vault.adapter.read(".obsidian/app.json");
    this.appJsonObj = JSON.parse(app_json);
    this.addCommand({
      id: "open-transcript-modal",
      name: "Smart transcribe",
      editorCallback: (editor, view) => {
        this.commandGenerateTranscript(editor);
      }
    });
    this.addCommand({
      id: "record-smart-memo",
      name: "Record smart memo",
      editorCallback: async (editor, view) => {
        this.audioFile = await new SmartMemosAudioRecordModal(this.app, this.handleAudioRecording.bind(this)).open();
      }
    });
    this.registerMarkdownPostProcessor((el, ctx) => {
      const audioLinks = el.querySelectorAll('a.internal-link[data-href$=".wav"]');
      console.log("audio links: ", audioLinks);
      audioLinks.forEach((link) => {
        console.log("linksss");
        const href = link.getAttribute("data-href");
        if (href === null) {
          console.error("Failed to get the href attribute from the link element.");
          return;
        }
        const abstractFile = this.app.vault.getAbstractFileByPath(href);
        if (!(abstractFile instanceof import_obsidian3.TFile)) {
          console.error("The path does not point to a valid file in the vault.");
          return;
        }
        const audio = document.createElement("audio");
        audio.src = this.app.vault.getResourcePath(abstractFile);
        audio.controls = true;
        audio.addEventListener("loadedmetadata", () => {
          if (audio.parentNode) {
            const durationDisplay = document.createElement("span");
            durationDisplay.textContent = `Duration: ${audio.duration.toFixed(2)} seconds`;
            audio.parentNode.insertBefore(durationDisplay, audio.nextSibling);
          }
        });
        audio.load();
        link.replaceWith(audio);
      });
    });
    this.addRibbonIcon("microphone", "Record smart memo", async (evt) => {
      this.audioFile = await new SmartMemosAudioRecordModal(this.app, this.handleAudioRecording.bind(this)).open();
    });
    this.addSettingTab(new SmartMemosSettingTab(this.app, this));
  }
  // Add a new method to handle the audio recording and processing
  async handleAudioRecording(audioFile, transcribe) {
    try {
      console.log("Handling audio recording:", audioFile);
      if (!audioFile) {
        console.log("No audio was recorded.");
        return;
      }
      this.audioFile = audioFile;
      const fileName = `recording-${Date.now()}.wav`;
      const file = await saveFile(this.app, this.audioFile, fileName, this.settings.recordingFilePath);
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (activeView) {
        const editor = activeView.editor;
        const cursor = editor.getCursor();
        const link = `![[${file.path}]]`;
        editor.replaceRange(link, cursor);
        editor.replaceRange("", { line: cursor.line, ch: cursor.ch }, { line: cursor.line, ch: cursor.ch });
      }
      if (transcribe) {
        this.transcribeRecording(file);
      }
      console.log(file);
    } catch (error) {
      console.error("Error handling audio recording:", error);
      new import_obsidian3.Notice("Failed to handle audio recording");
    }
  }
  // Add a new method to transcribe the audio file and generate text
  async transcribeRecording(audioFile) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      console.error("No active Markdown view found.");
      return;
    }
    const editor = activeView.editor;
    this.app.vault.readBinary(audioFile).then((audioBuffer) => {
      if (this.writing) {
        new import_obsidian3.Notice("Generator is already in progress.");
        return;
      }
      this.writing = true;
      new import_obsidian3.Notice("Generating transcript...");
      const fileType = audioFile.extension;
      this.generateTranscript(audioBuffer, fileType).then((result) => {
        this.transcript = result;
        const prompt = this.settings.prompt + result;
        new import_obsidian3.Notice("Transcript generated...");
        this.generateText(prompt, editor, editor.getCursor("to").line);
      }).catch((error) => {
        console.warn(error.message);
        new import_obsidian3.Notice(error.message);
        this.writing = false;
      });
    });
  }
  writeText(editor, LnToWrite, text) {
    const newLine = this.getNextNewLine(editor, LnToWrite);
    editor.setLine(newLine, "\n" + text.trim() + "\n");
    return newLine;
  }
  getNextNewLine(editor, Ln) {
    let newLine = Ln;
    while (editor.getLine(newLine).trim().length > 0) {
      if (newLine == editor.lastLine())
        editor.setLine(newLine, editor.getLine(newLine) + "\n");
      newLine++;
    }
    return newLine;
  }
  commandGenerateTranscript(editor) {
    const position = editor.getCursor();
    const text = editor.getRange({ line: 0, ch: 0 }, position);
    const regex = [
      /(?<=\[\[)(([^[\]])+)\.(mp3|mp4|mpeg|mpga|m4a|wav|webm)(?=]])/g,
      /(?<=\[(.*)]\()(([^[\]])+)\.(mp3|mp4|mpeg|mpga|m4a|wav|webm)(?=\))/g
    ];
    this.findFilePath(text, regex).then((path) => {
      const fileType = path.split(".").pop();
      if (fileType == void 0 || fileType == null || fileType == "") {
        new import_obsidian3.Notice("No audio file found");
      } else {
        this.app.vault.adapter.exists(path).then((exists) => {
          if (!exists)
            throw new Error(path + " does not exist");
          this.app.vault.adapter.readBinary(path).then((audioBuffer) => {
            if (this.writing) {
              new import_obsidian3.Notice("Generator is already in progress.");
              return;
            }
            this.writing = true;
            new import_obsidian3.Notice("Generating transcript...");
            this.generateTranscript(audioBuffer, fileType).then((result) => {
              this.transcript = result;
              const prompt = this.settings.prompt + result;
              new import_obsidian3.Notice("Transcript generated...");
              this.generateText(prompt, editor, editor.getCursor("to").line);
            }).catch((error) => {
              console.warn(error.message);
              new import_obsidian3.Notice(error.message);
              this.writing = false;
            });
          });
        });
      }
    }).catch((error) => {
      console.warn(error.message);
      new import_obsidian3.Notice(error.message);
    });
  }
  async findFilePath(text, regex) {
    console.log("dir text: ", text);
    let filename = "";
    let result;
    for (const reg of regex) {
      while ((result = reg.exec(text)) !== null) {
        filename = (0, import_obsidian3.normalizePath)(decodeURI(result[0])).trim();
      }
    }
    if (filename === "")
      throw new Error("No file found in the text.");
    console.log("file name: ", filename);
    const fullPath = filename;
    console.log("full path: ", fullPath);
    const fileExists = this.app.vault.getAbstractFileByPath(fullPath) instanceof import_obsidian3.TAbstractFile;
    if (fileExists)
      return fullPath;
    const allFiles = this.app.vault.getFiles();
    const foundFile = allFiles.find((file) => file.name === filename.split("/").pop());
    if (foundFile)
      return foundFile.path;
    throw new Error("File not found");
  }
  async generateTranscript(audioBuffer, filetype) {
    if (this.settings.apiKey.length <= 1)
      throw new Error("OpenAI API Key is not provided.");
    const N = 16;
    const randomBoundryString = "WebKitFormBoundary" + Array(N + 1).join((Math.random().toString(36) + "00000000000000000").slice(2, 18)).slice(0, N);
    const pre_string = `------${randomBoundryString}\r
Content-Disposition: form-data; name="file"; filename="audio.mp3"\r
Content-Type: "application/octet-stream"\r
\r
`;
    const post_string = `\r
------${randomBoundryString}\r
Content-Disposition: form-data; name="model"\r
\r
whisper-1\r
------${randomBoundryString}--\r
`;
    const pre_string_encoded = new TextEncoder().encode(pre_string);
    const post_string_encoded = new TextEncoder().encode(post_string);
    const chunkSize = 20 * 1024 * 1024;
    const numChunks = Math.ceil(audioBuffer.byteLength / chunkSize);
    if (numChunks < 2) {
      new import_obsidian3.Notice(`Transcribing audio...`);
    } else {
      new import_obsidian3.Notice(`Transcribing audio in ${numChunks} chunks. This may take a minute or two...`);
    }
    let results = [];
    for (let i = 0; i < numChunks; i++) {
      new import_obsidian3.Notice(`Transcribing chunk #${i + 1}...`);
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, audioBuffer.byteLength);
      const chunk = audioBuffer.slice(start, end);
      const concatenated = await new Blob([pre_string_encoded, chunk, post_string_encoded]).arrayBuffer();
      const options = {
        url: "https://api.openai.com/v1/audio/transcriptions",
        method: "POST",
        contentType: `multipart/form-data; boundary=----${randomBoundryString}`,
        headers: {
          "Authorization": "Bearer " + this.settings.apiKey
        },
        body: concatenated
      };
      const response = await (0, import_obsidian3.requestUrl)(options).catch((error) => {
        if (error.message.includes("401"))
          throw new Error("OpenAI API Key is not valid.");
        else
          throw error;
      });
      if ("text" in response.json) {
        results.push(response.json.text);
      } else
        throw new Error("Error. " + JSON.stringify(response.json));
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    }
    return results.join(" ");
  }
  async generateText(prompt, editor, currentLn, contextPrompt) {
    if (prompt.length < 1)
      throw new Error("Cannot find prompt.");
    if (this.settings.apiKey.length <= 1)
      throw new Error("OpenAI API Key is not provided.");
    prompt = prompt + ".";
    let newPrompt = prompt;
    const messages = [];
    messages.push({
      role: "user",
      content: newPrompt
    });
    new import_obsidian3.Notice(`Performing customized superhuman analysis...`);
    let LnToWrite = this.getNextNewLine(editor, currentLn);
    let lastLine = LnToWrite;
    const mock_env = {
      chunk_handler: (chunk) => {
        editor.setLine(LnToWrite, editor.getLine(LnToWrite) + chunk);
        if (chunk.includes("\n")) {
          LnToWrite = this.getNextNewLine(editor, LnToWrite);
        }
      },
      done_handler: (final_resp) => {
        LnToWrite = this.getNextNewLine(editor, lastLine);
        if (this.settings.includeTranscript) {
          editor.setLine(LnToWrite, editor.getLine(LnToWrite) + "\n# Transcript\n" + this.transcript);
        }
      }
    };
    const smart_chat_model = new SmartChatModel(
      mock_env,
      "openai",
      {
        api_key: this.settings.apiKey,
        model: this.settings.model
      }
    );
    const resp = await smart_chat_model.complete({ messages });
    this.writing = false;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SmartMemosSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("OpenAI api key").setDesc("Ex: sk-as123mkqwenjasdasdj12...").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.apiKey).setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Model").setDesc("Select the model to use for note-generation").addDropdown((dropdown) => {
      dropdown.addOptions(MODELS.reduce((models, model) => {
        models[model] = model;
        return models;
      }, {}));
      dropdown.setValue(this.plugin.settings.model);
      dropdown.onChange(async (value) => {
        this.plugin.settings.model = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Custom transcription-to-notes prompt").setDesc("Prompt that will be sent to Chatpgt right before adding your transcribed audio").addTextArea((text) => {
      if (text.inputEl) {
        text.inputEl.classList.add("smart-memo-text-box");
      }
      text.setPlaceholder(
        "Act as my personal secretary and worlds greatest entreprenuer and know I will put these notes in my personal obsidian where I have all my notes linked by categories, tags, etc. The following is a transcription of recording of someone talking aloud or people in a conversation. May be a lot of random things that are said given fluidity of conversation and the microphone ability to pick up all audio. Make outline of all topics and points within a structured hierarchy. Make sure to include any quantifiable information said such as the cost of headphones being $400.  Then go into to detail with summaries that explain things more eloquently. Finally, Create a mermaid chart code that complements the outline.\n\n"
      ).setValue(this.plugin.settings.prompt).onChange(async (value) => {
        this.plugin.settings.prompt = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Include Transcript").setDesc("Toggle this setting if you want to include the raw transcript on top of custom notes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTranscript).onChange(async (value) => {
      this.plugin.settings.includeTranscript = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Recording File Path").setDesc('Specify the file path where recordings will be saved. Ex. If you want to put recordings in Resources folder then path is "Resources" (Defaults to root)').addText((text) => text.setPlaceholder("Ex. Resources (if in Resources)").setValue(this.plugin.settings.recordingFilePath || "").onChange(async (value) => {
      this.plugin.settings.recordingFilePath = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvYWRhcHRlcnMvYW50aHJvcGljLmpzIiwgIm5vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL2FkYXB0ZXJzL2NvaGVyZS5qcyIsICJub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9hZGFwdGVycy9nZW1pbmkuanMiLCAibm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvYWRhcHRlcnMuanMiLCAibm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvcGxhdGZvcm1zLmpzb24iLCAibm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvdXRpbHMvaXNfdmFsaWRfdG9vbF9jYWxsLmpzIiwgIm5vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL3N0cmVhbWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9vcGVuX3JvdXRlci5qcyIsICJub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvb3BlbmFpLmpzIiwgIm5vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9nb29nbGVfZ2VtaW5pLmpzIiwgIm5vZGVfbW9kdWxlcy9zbWFydC1jaGF0LW1vZGVsL21vZGVscy9jb2hlcmUuanMiLCAibm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvbW9kZWxzL2FudGhyb3BpYy5qcyIsICJub2RlX21vZHVsZXMvc21hcnQtY2hhdC1tb2RlbC9tb2RlbHMvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL3NtYXJ0LWNoYXQtbW9kZWwvc21hcnRfY2hhdF9tb2RlbC5qcyIsICJtYWluLnRzIiwgIlNtYXJ0TWVtb3NBdWRpb1JlY29yZE1vZGFsLnRzIiwgIlV0aWxzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcclxuICogQW50aHJvcGljQWRhcHRlciBjbGFzcyBwcm92aWRlcyBtZXRob2RzIHRvIGFkYXB0IHRoZSBjaGF0IG1vZGVsIGludGVyYWN0aW9ucyBzcGVjaWZpY2FsbHkgZm9yIHRoZSBBbnRocm9waWMgbW9kZWwuXHJcbiAqIEl0IGluY2x1ZGVzIG1ldGhvZHMgdG8gcHJlcGFyZSByZXF1ZXN0IGJvZGllcywgY291bnQgYW5kIGVzdGltYXRlIHRva2VucywgYW5kIGhhbmRsZSB0b29sIGNhbGxzIGFuZCBtZXNzYWdlcy5cclxuICovXHJcbmNsYXNzIEFudGhyb3BpY0FkYXB0ZXIge1xyXG4gIC8qKlxyXG4gICAqIFByZXBhcmVzIHRoZSByZXF1ZXN0IGJvZHkgZm9yIHRoZSBBbnRocm9waWMgQVBJIGJ5IGNvbnZlcnRpbmcgQ2hhdE1MIGZvcm1hdCB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggQW50aHJvcGljLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgbWVzc2FnZXMgYW5kIG90aGVyIHBhcmFtZXRlcnMgaW4gQ2hhdE1MIGZvcm1hdC5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVxdWVzdCBib2R5IGZvcm1hdHRlZCBmb3IgdGhlIEFudGhyb3BpYyBBUEkuXHJcbiAgICovXHJcbiAgcHJlcGFyZV9yZXF1ZXN0X2JvZHkob3B0cykgeyByZXR1cm4gY2hhdG1sX3RvX2FudGhyb3BpYyhvcHRzKTsgfVxyXG4gIC8qKlxyXG4gICAqIENvdW50cyB0aGUgdG9rZW5zIGluIHRoZSBpbnB1dCBieSBlc3RpbWF0aW5nIHRoZW0sIGFzIHRoZSBBbnRocm9waWMgbW9kZWwgZG9lcyBub3QgcHJvdmlkZSBhIGRpcmVjdCBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCB0ZXh0IG9yIG9iamVjdCB0byBjb3VudCB0b2tlbnMgaW4uXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gVGhlIGVzdGltYXRlZCBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dC5cclxuICAgKi9cclxuICBhc3luYyBjb3VudF90b2tlbnMoaW5wdXQpIHtcclxuICAgIC8vIEN1cnJlbnRseSwgdGhlIEFudGhyb3BpYyBtb2RlbCBkb2VzIG5vdCBwcm92aWRlIGEgd2F5IHRvIGNvdW50IHRva2Vuc1xyXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfdG9rZW5zKGlucHV0KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dCBiYXNlZCBvbiBhIHJvdWdoIGF2ZXJhZ2UgdG9rZW4gc2l6ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IHRleHQgb3Igb2JqZWN0IHRvIGVzdGltYXRlIHRva2VucyBpbi5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZXN0aW1hdGVkIG51bWJlciBvZiB0b2tlbnMuXHJcbiAgICovXHJcbiAgZXN0aW1hdGVfdG9rZW5zKGlucHV0KXtcclxuICAgIGlmKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIGlucHV0ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xyXG4gICAgLy8gTm90ZTogVGhlIGRpdmlzaW9uIGJ5IDYgaXMgYSByb3VnaCBlc3RpbWF0ZSBiYXNlZCBvbiBvYnNlcnZlZCBhdmVyYWdlIHRva2VuIHNpemUuXHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDYpOyAvLyBVc2UgTWF0aC5jZWlsIGZvciBhIG1vcmUgYWNjdXJhdGUgY291bnRcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdHMgdGhlIGZpcnN0IHRvb2wgY2FsbCBmcm9tIHRoZSBKU09OIHJlc3BvbnNlIGNvbnRlbnQuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHRvb2wgY2FsbC5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaXJzdCB0b29sIGNhbGwgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cclxuICAgKi9cclxuICBnZXRfdG9vbF9jYWxsKGpzb24pe1xyXG4gICAgcmV0dXJuIGpzb24uY29udGVudC5maW5kKG1zZyA9PiBtc2cudHlwZSA9PT0gJ3Rvb2xfdXNlJyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgY29udGVudCBvZiBhIHRvb2wgY2FsbC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBpbnB1dC5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaW5wdXQgb2YgdGhlIHRvb2wgY2FsbC5cclxuICAgKi9cclxuICBnZXRfdG9vbF9jYWxsX2NvbnRlbnQodG9vbF9jYWxsKXtcclxuICAgIHJldHVybiB0b29sX2NhbGwuaW5wdXQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyB0aGUgbmFtZSBvZiB0aGUgdG9vbCBmcm9tIGEgdG9vbCBjYWxsIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBuYW1lLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0b29sLlxyXG4gICAqL1xyXG4gIGdldF90b29sX25hbWUodG9vbF9jYWxsKXtcclxuICAgIHJldHVybiB0b29sX2NhbGwubmFtZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdHMgdGhlIGZpcnN0IG1lc3NhZ2UgZnJvbSB0aGUgSlNPTiByZXNwb25zZSBjb250ZW50LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBtZXNzYWdlLlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpcnN0IG1lc3NhZ2UgZm91bmQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cclxuICAgKi9cclxuICBnZXRfbWVzc2FnZShqc29uKXsgcmV0dXJuIGpzb24uY29udGVudD8uWzBdOyB9XHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlIGZyb20gdGhlIEpTT04gcmVzcG9uc2UuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UgY29udGVudC5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlLCBvciBudWxsIGlmIG5vIG1lc3NhZ2UgaXMgZm91bmQuXHJcbiAgICovXHJcbiAgZ2V0X21lc3NhZ2VfY29udGVudChqc29uKSB7IHJldHVybiB0aGlzLmdldF9tZXNzYWdlKGpzb24pPy5bdGhpcy5nZXRfbWVzc2FnZShqc29uKT8udHlwZV07IH1cclxufVxyXG5leHBvcnRzLkFudGhyb3BpY0FkYXB0ZXIgPSBBbnRocm9waWNBZGFwdGVyO1xyXG4vLyBodHRwczovL2RvY3MuYW50aHJvcGljLmNvbS9jbGF1ZGUvcmVmZXJlbmNlL21lc3NhZ2VzX3Bvc3RcclxuLyoqXHJcbiAqIENvbnZlcnQgYSBDaGF0TUwgb2JqZWN0IHRvIGFuIEFudGhyb3BpYyBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgQ2hhdE1MIG9iamVjdFxyXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gYW4gQW50aHJvcGljIG9iamVjdC4gSXQgZmlsdGVycyBvdXQgc3lzdGVtIG1lc3NhZ2VzIGFuZCBhZGRzIGEgc3lzdGVtIG1lc3NhZ2UgcHJpb3IgdG8gdGhlIGxhc3QgdXNlciBtZXNzYWdlLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIFRoZSBBbnRocm9waWMgb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBjaGF0bWxfdG9fYW50aHJvcGljKG9wdHMpIHtcclxuICBsZXQgdG9vbF9jb3VudGVyID0gMDtcclxuICBjb25zdCBtZXNzYWdlcyA9IG9wdHMubWVzc2FnZXNcclxuICAgIC5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJylcclxuICAgIC5tYXAobSA9PiB7XHJcbiAgICAgIGlmKG0ucm9sZSA9PT0gJ3Rvb2wnKXtcclxuICAgICAgICByZXR1cm4geyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogJ3Rvb2xfcmVzdWx0JyxcclxuICAgICAgICAgICAgdG9vbF91c2VfaWQ6IGB0b29sLSR7dG9vbF9jb3VudGVyfWAsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IG0uY29udGVudFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF19O1xyXG4gICAgICB9XHJcbiAgICAgIGlmKG0ucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiYgbS50b29sX2NhbGxzKXtcclxuICAgICAgICB0b29sX2NvdW50ZXIrKztcclxuICAgICAgICBjb25zdCBvdXQgPSB7XHJcbiAgICAgICAgICByb2xlOiBtLnJvbGUsIFxyXG4gICAgICAgICAgY29udGVudDogbS50b29sX2NhbGxzLm1hcChjID0+ICh7XHJcbiAgICAgICAgICAgIHR5cGU6ICd0b29sX3VzZScsXHJcbiAgICAgICAgICAgIGlkOiBgdG9vbC0ke3Rvb2xfY291bnRlcn1gLFxyXG4gICAgICAgICAgICBuYW1lOiBjLmZ1bmN0aW9uLm5hbWUsXHJcbiAgICAgICAgICAgIGlucHV0OiAodHlwZW9mIGMuZnVuY3Rpb24uYXJndW1lbnRzID09PSAnc3RyaW5nJykgPyBKU09OLnBhcnNlKGMuZnVuY3Rpb24uYXJndW1lbnRzKSA6IGMuZnVuY3Rpb24uYXJndW1lbnRzXHJcbiAgICAgICAgICB9KSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmKG0uY29udGVudCl7XHJcbiAgICAgICAgICBpZih0eXBlb2YgbS5jb250ZW50ID09PSAnc3RyaW5nJykgb3V0LmNvbnRlbnQucHVzaCh7dHlwZTogJ3RleHQnLCB0ZXh0OiBtLmNvbnRlbnR9KTtcclxuICAgICAgICAgIGVsc2UgbS5jb250ZW50LmZvckVhY2goYyA9PiBvdXQuY29udGVudC5wdXNoKGMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgfVxyXG4gICAgICBpZih0eXBlb2YgbS5jb250ZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIHsgcm9sZTogbS5yb2xlLCBjb250ZW50OiBtLmNvbnRlbnQgfTtcclxuICAgICAgaWYoQXJyYXkuaXNBcnJheShtLmNvbnRlbnQpKXtcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gbS5jb250ZW50Lm1hcChjID0+IHtcclxuICAgICAgICAgIGlmKGMudHlwZSA9PT0gJ3RleHQnKSByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdGV4dDogYy50ZXh0fTtcclxuICAgICAgICAgIGlmKGMudHlwZSA9PT0gJ2ltYWdlX3VybCcpe1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZV91cmwgPSBjLmltYWdlX3VybC51cmw7XHJcbiAgICAgICAgICAgIGxldCBtZWRpYV90eXBlID0gaW1hZ2VfdXJsLnNwbGl0KFwiOlwiKVsxXS5zcGxpdChcIjtcIilbMF07XHJcbiAgICAgICAgICAgIGlmKG1lZGlhX3R5cGUgPT09ICdpbWFnZS9qcGcnKSBtZWRpYV90eXBlID0gJ2ltYWdlL2pwZWcnO1xyXG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdpbWFnZScsIHNvdXJjZToge3R5cGU6ICdiYXNlNjQnLCBtZWRpYV90eXBlOiBtZWRpYV90eXBlLCBkYXRhOiBpbWFnZV91cmwuc3BsaXQoXCIsXCIpWzFdfX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgcm9sZTogbS5yb2xlLCBjb250ZW50IH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9KVxyXG4gIDtcclxuICBjb25zdCB7IG1vZGVsLCBtYXhfdG9rZW5zLCB0ZW1wZXJhdHVyZSwgdG9vbHMsIHRvb2xfY2hvaWNlIH0gPSBvcHRzO1xyXG4gIC8vIERPOiBoYW5kbGVkIGJldHRlciAoU21hcnQgQ29ubmVjdGlvbnMgc3BlY2lmaWMpXHJcbiAgLy8gZ2V0IGluZGV4IG9mIGxhc3Qgc3lzdGVtIG1lc3NhZ2VcclxuICBjb25zdCBsYXN0X3N5c3RlbV9pZHggPSBvcHRzLm1lc3NhZ2VzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAnc3lzdGVtJyAmJiBtc2cuY29udGVudC5pbmNsdWRlcygnLS0tQkVHSU4nKSk7XHJcbiAgaWYgKGxhc3Rfc3lzdGVtX2lkeCA+IC0xKSB7XHJcbiAgICBjb25zdCBzeXN0ZW1fcHJvbXB0ID0gJzxjb250ZXh0PlxcbicgKyBvcHRzLm1lc3NhZ2VzW2xhc3Rfc3lzdGVtX2lkeF0uY29udGVudCArICdcXG48L2NvbnRleHQ+XFxuJztcclxuICAgIG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQgPSBzeXN0ZW1fcHJvbXB0ICsgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudDtcclxuICB9XHJcbiAgY29uc29sZS5sb2cobWVzc2FnZXMpO1xyXG4gIGNvbnN0IG91dCA9IHtcclxuICAgIG1lc3NhZ2VzLFxyXG4gICAgbW9kZWwsXHJcbiAgICBtYXhfdG9rZW5zLFxyXG4gICAgdGVtcGVyYXR1cmUsXHJcbiAgfVxyXG4gIGlmKHRvb2xzKXtcclxuICAgIG91dC50b29scyA9IHRvb2xzLm1hcCh0b29sID0+ICh7XHJcbiAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcclxuICAgICAgZGVzY3JpcHRpb246IHRvb2wuZnVuY3Rpb24uZGVzY3JpcHRpb24sXHJcbiAgICAgIGlucHV0X3NjaGVtYTogdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzLFxyXG4gICAgfSkpO1xyXG4gICAgaWYodG9vbF9jaG9pY2U/LnR5cGUgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAvLyBhZGQgXCJVc2UgdGhlICR7dG9vbC5uYW1lfSB0b29sXCIgdG8gdGhlIGxhc3QgdXNlciBtZXNzYWdlXHJcbiAgICAgIGNvbnN0IHRvb2xfcHJvbXB0ID0gYFVzZSB0aGUgXCIke3Rvb2xfY2hvaWNlLmZ1bmN0aW9uLm5hbWV9XCIgdG9vbCFgO1xyXG4gICAgICBjb25zdCBsYXN0X3VzZXJfaWR4ID0gb3V0Lm1lc3NhZ2VzLmZpbmRMYXN0SW5kZXgobXNnID0+IG1zZy5yb2xlID09PSAndXNlcicpO1xyXG4gICAgICBvdXQubWVzc2FnZXNbbGFzdF91c2VyX2lkeF0uY29udGVudCArPSAnXFxuJyArIHRvb2xfcHJvbXB0O1xyXG4gICAgICBvdXQuc3lzdGVtID0gYFJlcXVpcmVkOiB1c2UgdGhlIFwiJHt0b29sX2Nob2ljZS5mdW5jdGlvbi5uYW1lfVwiIHRvb2whYDtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gRE86IGhhbmRsZWQgYmV0dGVyIChTbWFydCBDb25uZWN0aW9ucyBzcGVjaWZpYylcclxuICAvLyBpZiBzeXN0ZW0gbWVzc2FnZSBleGlzdHMgcHJpb3IgdG8gbGFzdF9zeXN0ZW1faWR4IEFORCBkb2VzIG5vdCBpbmNsdWRlIFwiLS0tQkVHSU5cIiB0aGVuIGFkZCB0byBib2R5LnN5c3RlbVxyXG4gIGNvbnN0IGxhc3Rfbm9uX2NvbnRleHRfc3lzdGVtX2lkeCA9IG9wdHMubWVzc2FnZXMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICdzeXN0ZW0nICYmICFtc2cuY29udGVudC5pbmNsdWRlcygnLS0tQkVHSU4nKSk7XHJcbiAgaWYobGFzdF9ub25fY29udGV4dF9zeXN0ZW1faWR4ID4gLTEpIG91dC5zeXN0ZW0gPSBvcHRzLm1lc3NhZ2VzW2xhc3Rfbm9uX2NvbnRleHRfc3lzdGVtX2lkeF0uY29udGVudDtcclxuICByZXR1cm4gb3V0O1xyXG59XHJcbmV4cG9ydHMuY2hhdG1sX3RvX2FudGhyb3BpYyA9IGNoYXRtbF90b19hbnRocm9waWM7XHJcblxyXG4iLCAiLyoqXHJcbiAqIENvaGVyZUFkYXB0ZXIgY2xhc3MgaXMgZGVzaWduZWQgdG8gYWRhcHQgdGhlIFNtYXJ0Q2hhdE1vZGVsJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGUgQ29oZXJlIEFQSS5cclxuICogSXQgcHJvdmlkZXMgbWV0aG9kcyB0byBwcmVwYXJlIHJlcXVlc3QgYm9kaWVzLCBoYW5kbGUgc3RyZWFtaW5nIGRhdGEsIGFuZCBleHRyYWN0IG1lc3NhZ2UgY29udGVudCBmcm9tIHJlc3BvbnNlcy5cclxuICovXHJcbmNsYXNzIENvaGVyZUFkYXB0ZXIge1xyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIGEgQ2hhdE1MIG9iamVjdCB0byBhIGZvcm1hdCBzdWl0YWJsZSBmb3IgYSByZXF1ZXN0IHRvIHRoZSBDb2hlcmUgQVBJLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGF0bWwgLSBUaGUgQ2hhdE1MIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGF0IGhpc3RvcnkgYW5kIG90aGVyIHBhcmFtZXRlcnMuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlcXVlc3QgYm9keSBmb3JtYXR0ZWQgZm9yIHRoZSBDb2hlcmUgQVBJLlxyXG4gICAqL1xyXG4gIHByZXBhcmVfcmVxdWVzdF9ib2R5KGNoYXRtbCkgeyByZXR1cm4gY2hhdG1sX3RvX2NvaGVyZShjaGF0bWwpOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3RzIHRoZSBtZXNzYWdlIGNvbnRlbnQgZnJvbSBhIEpTT04gcmVzcG9uc2UgZnJvbSB0aGUgQ29oZXJlIEFQSS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHRleHQgY29udGVudC5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZXh0cmFjdGVkIHRleHQgY29udGVudCBmcm9tIHRoZSByZXNwb25zZS5cclxuICAgKi9cclxuICBnZXRfbWVzc2FnZV9jb250ZW50KGpzb24pIHsgcmV0dXJuIGpzb24udGV4dDsgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzZXMgc3RyZWFtaW5nIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgQ29oZXJlIEFQSSBhbmQgZXh0cmFjdHMgdGV4dCBjaHVua3MuXHJcbiAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgYWNjdW11bGF0aW9uIG9mIHRleHQgZGF0YSBvdmVyIG11bHRpcGxlIGV2ZW50cyBhbmQgbWFuYWdlcyB0aGUgc3RhdGUgb2YgdGhlIHN0cmVhbS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgc3RyZWFtaW5nIGRhdGEuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFjY3VtdWxhdGVkIHRleHQgY2h1bmsgZXh0cmFjdGVkIGZyb20gdGhlIHN0cmVhbS5cclxuICAgKi9cclxuICBnZXRfdGV4dF9jaHVua19mcm9tX3N0cmVhbShldmVudCkge1xyXG4gICAgaWYoIXRoaXMubGFzdF9saW5lX2luZGV4KSB0aGlzLmxhc3RfbGluZV9pbmRleCA9IDA7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sYXN0X2xpbmVfdGltZW91dCk7XHJcbiAgICB0aGlzLmxhc3RfbGluZV90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5sYXN0X2xpbmVfaW5kZXggPSAwO1xyXG4gICAgfSwgMTAwMDApO1xyXG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LnNvdXJjZS54aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgLy8gc3BsaXQgYnkgbmV3bGluZSBhbmQgZ2V0IGxhc3RcclxuICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdCgnXFxuJykuc2xpY2UodGhpcy5sYXN0X2xpbmVfaW5kZXgpO1xyXG4gICAgY29uc29sZS5sb2cobGluZXMpO1xyXG4gICAgdGhpcy5sYXN0X2xpbmVfaW5kZXggKz0gbGluZXMubGVuZ3RoO1xyXG4gICAgY29uc3QgdGV4dF9jaHVuayA9IGxpbmVzXHJcbiAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS50cmltKCkgIT09ICcnKVxyXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobGluZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGxpbmUpO1xyXG4gICAgICAgICAgICBpZihqc29uLmV2ZW50X3R5cGUgPT09ICdzdHJlYW0tZW5kJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3N0cmVhbS1lbmQnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kX29mX3N0cmVhbSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZF9vZl9zdHJlYW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIDMwMDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uLnRleHQ7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuam9pbignJyk7XHJcbiAgICBjb25zb2xlLmxvZyh0ZXh0X2NodW5rKTtcclxuICAgIHJldHVybiB0ZXh0X2NodW5rO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZW5kIG9mIHRoZSBzdHJlYW0gaGFzIGJlZW4gcmVhY2hlZCBiYXNlZCBvbiB0aGUgZXZlbnQgZGF0YS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRoYXQgbWF5IGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZW5kIG9mIHRoZSBzdHJlYW0gaXMgaW5kaWNhdGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICovXHJcbiAgaXNfZW5kX29mX3N0cmVhbShldmVudCkgeyByZXR1cm4gdGhpcy5lbmRfb2Zfc3RyZWFtOyB9XHJcbn1cclxuZXhwb3J0cy5Db2hlcmVBZGFwdGVyID0gQ29oZXJlQWRhcHRlcjtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgaW50byBhIGZvcm1hdCBzdWl0YWJsZSBmb3IgdGhlIENvaGVyZSBBUEkuXHJcbiAqIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgdGhlIGRhdGEgYnkgc3RydWN0dXJpbmcgaXQgYWNjb3JkaW5nIHRvIHRoZSByZXF1aXJlbWVudHMgb2YgdGhlIENvaGVyZSBBUEksXHJcbiAqIGluY2x1ZGluZyB0aGUgbW9kZWwgdG8gdXNlLCB0aGUgY2hhdCBoaXN0b3J5IGV4Y2x1ZGluZyB0aGUgbGFzdCB1c2VyIG1lc3NhZ2UsIGFuZCB0aGUgbGFzdCBtZXNzYWdlIHNlcGFyYXRlbHkuXHJcbiAqIFxyXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhdG1sIC0gVGhlIENoYXRNTCBvYmplY3QgY29udGFpbmluZyB0aGUgbW9kZWwsIG1lc3NhZ2VzLCBhbmQgb3RoZXIgcGFyYW1ldGVycyBsaWtlIHRlbXBlcmF0dXJlLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZm9ybWF0dGVkIG9iamVjdCBmb3IgdGhlIENvaGVyZSBBUEkgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgbW9kZWwsIGNoYXQgaGlzdG9yeSwgbGFzdCBtZXNzYWdlLCBhbmQgdGVtcGVyYXR1cmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGF0bWxfdG9fY29oZXJlKGNoYXRtbCkge1xyXG4gICAgY29uc3QgY29oZXJlID0ge1xyXG4gICAgICAgIG1vZGVsOiBjaGF0bWwubW9kZWwsXHJcbiAgICAgICAgLy8gc2tpcCBsYXN0IHVzZXIgbWVzc2FnZVxyXG4gICAgICAgIGNoYXRfaGlzdG9yeTogY2hhdG1sLm1lc3NhZ2VzXHJcbiAgICAgICAgICAgIC5zbGljZSgwLCAtMSlcclxuICAgICAgICAgICAgLm1hcCgobWVzc2FnZSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIHJvbGU6IG1lc3NhZ2Uucm9sZSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnNlX21lc3NhZ2VfY29udGVudF90b19zdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICxcclxuICAgICAgICBtZXNzYWdlOiBwYXJzZV9tZXNzYWdlX2NvbnRlbnRfdG9fc3RyaW5nKGNoYXRtbC5tZXNzYWdlc1tjaGF0bWwubWVzc2FnZXMubGVuZ3RoIC0gMV0pLFxyXG4gICAgICAgIHRlbXBlcmF0dXJlOiBjaGF0bWwudGVtcGVyYXR1cmUsXHJcbiAgICAgICAgLy8gc3RyZWFtOiBjaGF0bWwuc3RyZWFtIC8vIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNvaGVyZTtcclxufVxyXG5leHBvcnRzLmNoYXRtbF90b19jb2hlcmUgPSBjaGF0bWxfdG9fY29oZXJlO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VfbWVzc2FnZV9jb250ZW50X3RvX3N0cmluZyhtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpID8gbWVzc2FnZS5jb250ZW50LmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ3RleHQnKS5tYXAoYyA9PiBjLnRleHQpLmpvaW4oJ1xcbicpIDogbWVzc2FnZS5jb250ZW50O1xyXG59XHJcblxyXG4iLCAiLyoqXHJcbiAqIEdlbWluaUFkYXB0ZXIgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyB0byBhZGFwdCB0aGUgY2hhdCBtb2RlbCBpbnRlcmFjdGlvbnMgc3BlY2lmaWNhbGx5IGZvciB0aGUgR2VtaW5pIG1vZGVsLlxyXG4gKiBJdCBpbmNsdWRlcyBtZXRob2RzIHRvIHByZXBhcmUgcmVxdWVzdCBib2RpZXMsIGhhbmRsZSB0b29sIGNhbGxzIGFuZCBtZXNzYWdlcywgYW5kIG1hbmFnZSBzdHJlYW1pbmcgcmVzcG9uc2VzLlxyXG4gKi9cclxuY2xhc3MgR2VtaW5pQWRhcHRlciB7XHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0cyBhIEdlbWluaUFkYXB0ZXIgaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBtb2RlbCBjb25maWd1cmF0aW9uLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCAtIFRoZSBtb2RlbCBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihtb2RlbCkgeyB0aGlzLm1vZGVsID0gbW9kZWw7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlcGFyZXMgdGhlIHJlcXVlc3QgYm9keSBmb3IgdGhlIEdlbWluaSBBUEkgYnkgY29udmVydGluZyBDaGF0TUwgZm9ybWF0IHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBHZW1pbmkuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHkgLSBUaGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBtZXNzYWdlcyBhbmQgb3RoZXIgcGFyYW1ldGVycyBpbiBDaGF0TUwgZm9ybWF0LlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXF1ZXN0IGJvZHkgZm9ybWF0dGVkIGZvciB0aGUgR2VtaW5pIEFQSS5cclxuICAgKi9cclxuICBwcmVwYXJlX3JlcXVlc3RfYm9keShib2R5KSB7IHJldHVybiBjaGF0bWxfdG9fZ2VtaW5pKGJvZHkpOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCB0b29sIGNhbGwgZnJvbSB0aGUgSlNPTiByZXNwb25zZSBjb250ZW50LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSB0b29sIGNhbGwuXHJcbiAgICogQHJldHVybnMge09iamVjdHxudWxsfSBUaGUgZmlyc3QgdG9vbCBjYWxsIGZvdW5kLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXHJcbiAgICovXHJcbiAgZ2V0X3Rvb2xfY2FsbChqc29uKSB7IHJldHVybiBqc29uLmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHM/LlswXT8uZnVuY3Rpb25DYWxsOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyB0aGUgbmFtZSBvZiB0aGUgdG9vbCBmcm9tIGEgdG9vbCBjYWxsIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBuYW1lLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVGhlIG5hbWUgb2YgdGhlIHRvb2wsIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS5cclxuICAgKi9cclxuICBnZXRfdG9vbF9uYW1lKHRvb2xfY2FsbCkgeyByZXR1cm4gdG9vbF9jYWxsPy5uYW1lOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgY29udGVudCBvZiBhIHRvb2wgY2FsbC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsIC0gVGhlIHRvb2wgY2FsbCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBpbnB1dC5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBpbnB1dCBvZiB0aGUgdG9vbCBjYWxsLCBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuXHJcbiAgICovXHJcbiAgZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCkgeyByZXR1cm4gdG9vbF9jYWxsPy5hcmdzOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCBtZXNzYWdlIGZyb20gdGhlIEpTT04gcmVzcG9uc2UgY29udGVudC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZS5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaXJzdCBtZXNzYWdlIGZvdW5kLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXHJcbiAgICovXHJcbiAgZ2V0X21lc3NhZ2UoanNvbikgeyByZXR1cm4ganNvbi5jYW5kaWRhdGVzPy5bMF07IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlIGZyb20gdGhlIEpTT04gcmVzcG9uc2UuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiByZXNwb25zZSBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIG1lc3NhZ2UgY29udGVudC5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBjb250ZW50IG9mIHRoZSBmaXJzdCBtZXNzYWdlLCBvciBudWxsIGlmIG5vIG1lc3NhZ2UgaXMgZm91bmQuXHJcbiAgICovXHJcbiAgZ2V0X21lc3NhZ2VfY29udGVudChqc29uKSB7IHJldHVybiB0aGlzLmdldF9tZXNzYWdlKGpzb24pPy5jb250ZW50Py5wYXJ0cy5tYXAocGFydCA9PiBwYXJ0LnRleHQpLmpvaW4oJycpOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgZXNjYXBlZCBuZXdsaW5lcyBpbiBhIHN0cmVhbWluZyB0ZXh0IGNodW5rLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBzdHJlYW1pbmcgZXZlbnQgY29udGFpbmluZyB0aGUgZGF0YS5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdGV4dCBjaHVuayB3aXRoIGVzY2FwZWQgbmV3bGluZXMgcmVwbGFjZWQuXHJcbiAgICovXHJcbiAgZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0oZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmRhdGEucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgaWYgdGhlIHN0cmVhbWluZyByZXNwb25zZSBoYXMgZW5kZWQgYmFzZWQgb24gdGhlIHJlYWR5U3RhdGUgb2YgdGhlIFhNTEh0dHBSZXF1ZXN0LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBzdHJlYW1pbmcgZXZlbnQuXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cclxuICBpc19lbmRfb2Zfc3RyZWFtKGV2ZW50KSB7IHJldHVybiBldmVudC5zb3VyY2UueGhyLnJlYWR5U3RhdGUgPT09IDQ7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ291bnRzIHRoZSB0b2tlbnMgaW4gdGhlIGlucHV0IGJ5IG1ha2luZyBhbiBBUEkgcmVxdWVzdCB0byB0aGUgR2VtaW5pIHRva2VuIGNvdW50aW5nIGVuZHBvaW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgdGV4dCBvciBvYmplY3QgdG8gY291bnQgdG9rZW5zIGluLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IFRoZSB0b3RhbCBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBpbnB1dC5cclxuICAgKi9cclxuICBhc3luYyBjb3VudF90b2tlbnMoaW5wdXQpIHtcclxuICAgIGNvbnN0IHJlcSA9IHtcclxuICAgICAgdXJsOiBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktcHJvOmNvdW50VG9rZW5zP2tleT0ke3RoaXMubW9kZWwuYXBpX2tleX1gLFxyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICB9O1xyXG4gICAgbGV0IGJvZHk7XHJcbiAgICBpZih0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSBib2R5ID0gY2hhdG1sX3RvX2dlbWluaSh7IG1lc3NhZ2VzOiBbeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IGlucHV0IH1dIH0pO1xyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIGJvZHkgPSBjaGF0bWxfdG9fZ2VtaW5pKHsgbWVzc2FnZXM6IGlucHV0IH0pO1xyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgYm9keSA9IGNoYXRtbF90b19nZW1pbmkoaW5wdXQpO1xyXG4gICAgZWxzZSByZXR1cm4gY29uc29sZS5lcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIGNvdW50X3Rva2Vuc1wiLCBpbnB1dCk7XHJcbiAgICBkZWxldGUgYm9keS5nZW5lcmF0aW9uQ29uZmlnO1xyXG4gICAgZGVsZXRlIGJvZHkuc2FmZXR5U2V0dGluZ3M7XHJcbiAgICByZXEuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xyXG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMubW9kZWwucmVxdWVzdF9hZGFwdGVyKHJlcSk7XHJcbiAgICByZXR1cm4gcmVzcD8uanNvbj8udG90YWxUb2tlbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHRoZSBzdGFuZGFyZCBBUEkgZW5kcG9pbnQgd2l0aCB0aGUgQVBJIGtleSBhcHBlbmRlZC5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIGVuZHBvaW50IFVSTCBmb3Igbm9uLXN0cmVhbWluZyByZXF1ZXN0cy5cclxuICAgKi9cclxuICBnZXQgZW5kcG9pbnQoKSB7IHJldHVybiB0aGlzLm1vZGVsLmNvbmZpZy5lbmRwb2ludC5yZXBsYWNlKCdNT0RFTF9OQU1FJywgdGhpcy5tb2RlbC5tb2RlbF9uYW1lKSArIFwiP2tleT1cIiArIHRoaXMubW9kZWwuYXBpX2tleTsgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHRoZSBzdHJlYW1pbmcgQVBJIGVuZHBvaW50IHdpdGggdGhlIEFQSSBrZXkgYXBwZW5kZWQuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBlbmRwb2ludCBVUkwgZm9yIHN0cmVhbWluZyByZXF1ZXN0cy5cclxuICAgKi9cclxuICBnZXQgZW5kcG9pbnRfc3RyZWFtaW5nKCkgeyByZXR1cm4gdGhpcy5tb2RlbC5jb25maWcuZW5kcG9pbnRfc3RyZWFtaW5nLnJlcGxhY2UoJ01PREVMX05BTUUnLCB0aGlzLm1vZGVsLm1vZGVsX25hbWUpICsgXCI/a2V5PVwiICsgdGhpcy5tb2RlbC5hcGlfa2V5OyB9XHJcbn1cclxuZXhwb3J0cy5HZW1pbmlBZGFwdGVyID0gR2VtaW5pQWRhcHRlcjtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgQ2hhdE1MIG9iamVjdCB0byBhIEdlbWluaSBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgQ2hhdE1MIG9iamVjdFxyXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBhIENoYXRNTCBvYmplY3QgdG8gYSBHZW1pbmkgb2JqZWN0LiBJdCBmaWx0ZXJzIG91dCBzeXN0ZW0gbWVzc2FnZXMgYW5kIGFkZHMgYSBzeXN0ZW0gbWVzc2FnZSBwcmlvciB0byB0aGUgbGFzdCB1c2VyIG1lc3NhZ2UuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIEdlbWluaSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGNoYXRtbF90b19nZW1pbmkob3B0cykge1xyXG4gIC8vIC8vIGRlZXAgY29weSBtZXNzYWdlc1xyXG4gIC8vIGNvbnN0IG1lc3NhZ2VzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRzLm1lc3NhZ2VzKSkuZmlsdGVyKG1zZyA9PiBtc2cucm9sZSAhPT0gJ3N5c3RlbScpO1xyXG4gIC8vIC8vIG1lcmdlIHN5c3RlbSByb2xlcyBpbnRvbSBzdWJzZXF1ZW50IHVzZXIgcm9sZXNcclxuICAvLyBvcHRzLm1lc3NhZ2VzLmZvckVhY2goKG1zZywgaSkgPT4ge1xyXG4gIC8vICAgaWYgKG1zZy5yb2xlID09PSAnc3lzdGVtJykge1xyXG4gIC8vICAgICBpZiAoIW1lc3NhZ2VzW2kgKyAxXSkgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJTeXN0ZW0gbWVzc2FnZSB3aXRob3V0IHN1YnNlcXVlbnQgdXNlciBtZXNzYWdlXCIpO1xyXG4gIC8vICAgICBjb25zdCBzeXN0ZW1fcHJvbXB0ID0gJy0tLUJFR0lOIElNUE9SVEFOVCBDT05URVhULS0tXFxuJyArIG1zZy5jb250ZW50ICsgJ1xcbi0tLUVORCBJTVBPUlRBTlQgQ09OVEVYVC0tLVxcblxcbic7XHJcbiAgLy8gICAgIG1lc3NhZ2VzW2kgKyAxXS5jb250ZW50ID0gc3lzdGVtX3Byb21wdCArIChtZXNzYWdlc1tpICsgMV0uY29udGVudCB8fCAnJyk7XHJcbiAgLy8gICB9XHJcbiAgLy8gfSk7XHJcbiAgY29uc3QgbWVzc2FnZXMgPSBvcHRzLm1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gbXNnLnJvbGUgIT09ICdzeXN0ZW0nKTtcclxuICAvLyBETzogaGFuZGxlZCBiZXR0ZXIgKFNtYXJ0IENvbm5lY3Rpb25zIHNwZWNpZmljKVxyXG4gIC8vIGdldCBpbmRleCBvZiBsYXN0IHN5c3RlbSBtZXNzYWdlXHJcbiAgY29uc3QgbGFzdF9zeXN0ZW1faWR4ID0gb3B0cy5tZXNzYWdlcy5maW5kTGFzdEluZGV4KG1zZyA9PiBtc2cucm9sZSA9PT0gJ3N5c3RlbScgJiYgbXNnLmNvbnRlbnQuaW5jbHVkZXMoJy0tLUJFR0lOJykpO1xyXG4gIGlmIChsYXN0X3N5c3RlbV9pZHggPiAtMSkge1xyXG4gICAgY29uc3Qgc3lzdGVtX3Byb21wdCA9ICctLS1CRUdJTiBJTVBPUlRBTlQgQ09OVEVYVC0tLVxcbicgKyBvcHRzLm1lc3NhZ2VzW2xhc3Rfc3lzdGVtX2lkeF0uY29udGVudCArICdcXG4tLS1FTkQgSU1QT1JUQU5UIENPTlRFWFQtLS1cXG5cXG4nO1xyXG4gICAgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudCA9IHN5c3RlbV9wcm9tcHQgKyBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXS5jb250ZW50O1xyXG4gIH1cclxuICBjb25zdCBib2R5ID0ge1xyXG4gICAgY29udGVudHM6IG1lc3NhZ2VzXHJcbiAgICAgIC5maWx0ZXIobXNnID0+IG1zZy5yb2xlICE9PSAnc3lzdGVtJykgLy8gZmlsdGVyIG91dCBzeXN0ZW0gbWVzc2FnZXNcclxuICAgICAgLm1hcChtc2cgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB7fTtcclxuICAgICAgICBjb250ZW50LnJvbGUgPSBtc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcgPyAnbW9kZWwnIDogbXNnLnJvbGU7XHJcbiAgICAgICAgY29udGVudC5wYXJ0cyA9ICFBcnJheS5pc0FycmF5KG1zZy5jb250ZW50KSA/IFt7dGV4dDogbXNnLmNvbnRlbnR9XSA6IG1zZy5jb250ZW50Lm1hcChjID0+IHtcclxuICAgICAgICAgIGlmKGMudHlwZSA9PT0gJ3RleHQnKXtcclxuICAgICAgICAgICAgcmV0dXJuIHt0ZXh0OiBjLnRleHR9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYoYy50eXBlID09PSAnaW1hZ2VfdXJsJyl7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlX3VybCA9IGMuaW1hZ2VfdXJsLnVybDtcclxuICAgICAgICAgICAgbGV0IG1pbWVfdHlwZSA9IGltYWdlX3VybC5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdO1xyXG4gICAgICAgICAgICBpZihtaW1lX3R5cGUgPT09ICdpbWFnZS9qcGcnKSBtaW1lX3R5cGUgPSAnaW1hZ2UvanBlZyc7XHJcbiAgICAgICAgICAgIHJldHVybiB7aW5saW5lX2RhdGE6IHttaW1lX3R5cGU6IG1pbWVfdHlwZSwgZGF0YTogaW1hZ2VfdXJsLnNwbGl0KFwiLFwiKVsxXX19O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgICAgICh7XHJcbiAgICAgICAgICByb2xlOiBtc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcgPyAnbW9kZWwnIDogbXNnLnJvbGUsXHJcbiAgICAgICAgICBwYXJ0czogQXJyYXkuaXNBcnJheShtc2cuY29udGVudCkgPyBbe3RleHQ6IG1zZy5jb250ZW50LmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ3RleHQnKS5tYXAoYyA9PiBjLnRleHQpLmpvaW4oJ1xcbicpfV0gOiBbeyB0ZXh0OiBtc2cuY29udGVudCB9XVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICAsXHJcbiAgICBnZW5lcmF0aW9uQ29uZmlnOiB7XHJcbiAgICAgIHRlbXBlcmF0dXJlOiBvcHRzLnRlbXBlcmF0dXJlIHx8IDAuOSxcclxuICAgICAgdG9wSzogb3B0cy50b3BLIHx8IDEsXHJcbiAgICAgIHRvcFA6IG9wdHMudG9wUCB8fCAxLFxyXG4gICAgICBtYXhPdXRwdXRUb2tlbnM6IG9wdHMubWF4X3Rva2VucyB8fCAyMDQ4LFxyXG4gICAgICBzdG9wU2VxdWVuY2VzOiBvcHRzLnN0b3BTZXF1ZW5jZXMgfHwgW10sXHJcbiAgICAgIGNhbmRpZGF0ZV9jb3VudDogb3B0cy5uIHx8IDEsXHJcbiAgICB9LFxyXG4gICAgc2FmZXR5U2V0dGluZ3M6IFtcclxuICAgICAge1xyXG4gICAgICAgIGNhdGVnb3J5OiBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiLFxyXG4gICAgICAgIHRocmVzaG9sZDogXCJCTE9DS19OT05FXCJcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGNhdGVnb3J5OiBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIixcclxuICAgICAgICB0aHJlc2hvbGQ6IFwiQkxPQ0tfTk9ORVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBjYXRlZ29yeTogXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCIsXHJcbiAgICAgICAgdGhyZXNob2xkOiBcIkJMT0NLX05PTkVcIlxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgY2F0ZWdvcnk6IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiLFxyXG4gICAgICAgIHRocmVzaG9sZDogXCJCTE9DS19OT05FXCJcclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH07XHJcbiAgY29uc3Qgc3lzdGVtX2luc3RydWN0aW9ucyA9IG9wdHMubWVzc2FnZXMuZmlsdGVyKG1zZyA9PiBtc2cucm9sZSA9PT0gJ3N5c3RlbScgJiYgIW1zZy5jb250ZW50LmluY2x1ZGVzKCctLS1CRUdJTicpKTtcclxuICBpZihzeXN0ZW1faW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIGJvZHkuc3lzdGVtSW5zdHJ1Y3Rpb24gPSB7IHBhcnRzOiBzeXN0ZW1faW5zdHJ1Y3Rpb25zLm1hcChtc2cgPT4gKHsgdGV4dDogbXNnLmNvbnRlbnQgfSkpIH07XHJcbiAgaWYob3B0cy50b29scyl7XHJcbiAgICBib2R5LnRvb2xzID0gW3tcclxuICAgICAgZnVuY3Rpb25fZGVjbGFyYXRpb25zOiBvcHRzLnRvb2xzLm1hcCh0b29sID0+ICh7XHJcbiAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmZ1bmN0aW9uLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgIHBhcmFtZXRlcnM6IHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycyxcclxuICAgICAgfSkpXHJcbiAgICB9XTtcclxuICAgIGlmKG9wdHMudG9vbF9jaG9pY2Upe1xyXG4gICAgICBpZihvcHRzLnRvb2xfY2hvaWNlICE9PSAnYXV0bycpe1xyXG4gICAgICAgIGlmKG9wdHMubW9kZWwuaW5jbHVkZXMoJzEuNS1wcm8nKSl7IC8vIG1vZGU9QU5ZIG9ubHkgb24gMS41LXByb1xyXG4gICAgICAgICAgYm9keS50b29sX2NvbmZpZyA9IHtcclxuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbGluZ19jb25maWc6IHtcclxuICAgICAgICAgICAgICBtb2RlOiBcIkFOWVwiLFxyXG4gICAgICAgICAgICAgIGFsbG93ZWRfZnVuY3Rpb25fbmFtZXM6IG9wdHMudG9vbHMubWFwKHRvb2wgPT4gdG9vbC5mdW5jdGlvbi5uYW1lKSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9ZWxzZXsgLy8gaGFuZGxlcyAxLjAgYW5kIDEuNS1mbGFzaFxyXG4gICAgICAgICAgLy8gYm9keS5zeXN0ZW1faW5zdHJ1Y3Rpb24gPSB7XHJcbiAgICAgICAgICBib2R5LnN5c3RlbUluc3RydWN0aW9uID0ge1xyXG4gICAgICAgICAgICByb2xlOiAndXNlcicsXHJcbiAgICAgICAgICAgIHBhcnRzOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogYElNUE9SVEFOVDogWW91IG11c3QgdXNlIHRoZSBcIiR7Ym9keS50b29sc1swXS5mdW5jdGlvbl9kZWNsYXJhdGlvbnNbMF0ubmFtZX1cIiBmdW5jdGlvbiB0b29sIWBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBjb25zdCB0b29sX3Byb21wdCA9IGBJTVBPUlRBTlQ6IFlvdSBtdXN0IHVzZSB0aGUgXCIke2JvZHkudG9vbHNbMF0uZnVuY3Rpb25fZGVjbGFyYXRpb25zWzBdLm5hbWV9XCIgZnVuY3Rpb24gdG9vbCFgO1xyXG4gICAgICAgICAgY29uc3QgbGFzdF91c2VyX2lkeCA9IGJvZHkuY29udGVudHMuZmluZExhc3RJbmRleChtc2cgPT4gbXNnLnJvbGUgPT09ICd1c2VyJyk7XHJcbiAgICAgICAgICBib2R5LmNvbnRlbnRzW2xhc3RfdXNlcl9pZHhdLnBhcnRzWzBdLnRleHQgKz0gJ1xcblxcbicgKyB0b29sX3Byb21wdDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGJvZHk7XHJcbn1cclxuZXhwb3J0cy5jaGF0bWxfdG9fZ2VtaW5pID0gY2hhdG1sX3RvX2dlbWluaTsiLCAiY29uc3QgeyBBbnRocm9waWNBZGFwdGVyIH0gPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2FudGhyb3BpYycpO1xyXG5jb25zdCB7IENvaGVyZUFkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvY29oZXJlJyk7XHJcbmNvbnN0IHsgR2VtaW5pQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9hZGFwdGVycy9nZW1pbmknKTtcclxuZXhwb3J0cy5BbnRocm9waWMgPSBBbnRocm9waWNBZGFwdGVyO1xyXG5leHBvcnRzLkNvaGVyZSA9IENvaGVyZUFkYXB0ZXI7XHJcbmV4cG9ydHMuR2VtaW5pID0gR2VtaW5pQWRhcHRlcjtcclxuXHJcbiIsICJ7XHJcbiAgXCJvcGVuYWlcIjoge1xyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wZW5BSVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXHJcbiAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9jaGF0L2NvbXBsZXRpb25zXCIsXHJcbiAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxyXG4gICAgXCJhY3Rpb25zXCI6IHRydWUsXHJcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxyXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwiZ3B0LTMuNS10dXJib1wiLFxyXG4gICAgXCJzaWdudXBfdXJsXCI6IFwiaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2FwaS1rZXlzXCJcclxuICB9LFxyXG4gIFwiZ29vZ2xlX2dlbWluaVwiOiB7XHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiR29vZ2xlIEdlbWluaVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXHJcbiAgICBcImFwaV9rZXlfaGVhZGVyXCI6IFwibm9uZVwiLFxyXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHMvTU9ERUxfTkFNRTpnZW5lcmF0ZUNvbnRlbnRcIixcclxuICAgIFwiZW5kcG9pbnRfc3RyZWFtaW5nXCI6IFwiaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9NT0RFTF9OQU1FOnN0cmVhbUdlbmVyYXRlQ29udGVudFwiLFxyXG4gICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcclxuICAgIFwiYWN0aW9uc1wiOiB0cnVlLFxyXG4gICAgXCJhZGFwdGVyXCI6IFwiR2VtaW5pXCIsXHJcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxyXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwiZ2VtaW5pLTEuMC1wcm9cIixcclxuICAgIFwic2lnbnVwX3VybFwiOiBcImh0dHBzOi8vYWkuZ29vZ2xlLmRldi9cIlxyXG4gIH0sXHJcbiAgXCJvcGVuX3JvdXRlclwiOiB7XHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3BlbiBSb3V0ZXJcIixcclxuICAgIFwidHlwZVwiOiBcIkFQSVwiLFxyXG4gICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjEvY2hhdC9jb21wbGV0aW9uc1wiLFxyXG4gICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcclxuICAgIFwiZmV0Y2hfbW9kZWxzXCI6IHRydWUsXHJcbiAgICBcImRlZmF1bHRfbW9kZWxcIjogXCJtaXN0cmFsYWkvbWlzdHJhbC03Yi1pbnN0cnVjdDpmcmVlXCIsXHJcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL2FjY291bnRzLm9wZW5yb3V0ZXIuYWkvc2lnbi11cD9yZWRpcmVjdF91cmw9aHR0cHMlM0ElMkYlMkZvcGVucm91dGVyLmFpJTJGa2V5c1wiXHJcbiAgfSxcclxuICBcImNvaGVyZVwiOiB7XHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ29oZXJlIENvbW1hbmQtUlwiLFxyXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCIsXHJcbiAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly9hcGkuY29oZXJlLmFpL3YxL2NoYXRcIixcclxuICAgIFwic3RyZWFtaW5nXCI6IGZhbHNlLFxyXG4gICAgXCJhZGFwdGVyXCI6IFwiQ29oZXJlXCIsXHJcbiAgICBcImZldGNoX21vZGVsc1wiOiB0cnVlLFxyXG4gICAgXCJkZWZhdWx0X21vZGVsXCI6IFwiY29tbWFuZC1yXCIsXHJcbiAgICBcInNpZ251cF91cmxcIjogXCJodHRwczovL2Rhc2hib2FyZC5jb2hlcmUuY29tL3dlbGNvbWUvcmVnaXN0ZXI/cmVkaXJlY3RfdXJpPSUyRmFwaS1rZXlzXCJcclxuICB9LFxyXG4gIFwiYW50aHJvcGljXCI6IHtcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbnRocm9waWMgQ2xhdWRlXCIsXHJcbiAgICBcInR5cGVcIjogXCJBUElcIixcclxuICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL2FwaS5hbnRocm9waWMuY29tL3YxL21lc3NhZ2VzXCIsXHJcbiAgICBcInN0cmVhbWluZ1wiOiBmYWxzZSxcclxuICAgIFwiYXBpX2tleV9oZWFkZXJcIjogXCJ4LWFwaS1rZXlcIixcclxuICAgIFwiaGVhZGVyc1wiOiB7XHJcbiAgICAgIFwiYW50aHJvcGljLXZlcnNpb25cIjogXCIyMDIzLTA2LTAxXCIsXHJcbiAgICAgIFwiYW50aHJvcGljLWJldGFcIjogXCJ0b29scy0yMDI0LTA0LTA0XCJcclxuICAgIH0sXHJcbiAgICBcImFkYXB0ZXJcIjogXCJBbnRocm9waWNcIixcclxuICAgIFwiYWN0aW9uc1wiOiB0cnVlLFxyXG4gICAgXCJmZXRjaF9tb2RlbHNcIjogdHJ1ZSxcclxuICAgIFwiZGVmYXVsdF9tb2RlbFwiOiBcImNsYXVkZS0zLXNvbm5ldC0yMDI0MDIyOVwiLFxyXG4gICAgXCJzaWdudXBfdXJsXCI6IFwiaHR0cHM6Ly9jb25zb2xlLmFudGhyb3BpYy5jb20vbG9naW4/cmV0dXJuVG89JTJGc2V0dGluZ3MlMkZrZXlzXCJcclxuICB9LFxyXG4gIFwiY3VzdG9tX2xvY2FsXCI6IHtcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDdXN0b20gTG9jYWwgKE9wZW5BSSBmb3JtYXQpXCIsXHJcbiAgICBcInR5cGVcIjogXCJBUElcIlxyXG4gIH0sXHJcbiAgXCJjdXN0b21fYXBpXCI6IHtcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDdXN0b20gQVBJIChPcGVuQUkgZm9ybWF0KVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwiQVBJXCJcclxuICB9XHJcbn1cclxuXHJcbiIsICIvKipcclxuICAgY29uc3QgdG9vbHNfZXhhbXBsZSA9IFtcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIixcclxuICAgICAgXCJmdW5jdGlvblwiOiB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLFxyXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJHZXQgdGhlIGN1cnJlbnQgd2VhdGhlciBpbiBhIGdpdmVuIGxvY2F0aW9uXCIsXHJcbiAgICAgICAgXCJwYXJhbWV0ZXJzXCI6IHtcclxuICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcclxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiB7XHJcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjaXR5IGFuZCBzdGF0ZSwgZS5nLiBTYW4gRnJhbmNpc2NvLCBDQVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInVuaXRcIjoge1widHlwZVwiOiBcInN0cmluZ1wiLCBcImVudW1cIjogW1wiY2Vsc2l1c1wiLCBcImZhaHJlbmhlaXRcIl19LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIFwicmVxdWlyZWRcIjogW1wibG9jYXRpb25cIl0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsXHJcbiAgICBcImZ1bmN0aW9uXCI6IHtcclxuICAgICAgXCJuYW1lXCI6IFwibG9va3VwXCIsXHJcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZW1hbnRpYyBzZWFyY2hcIixcclxuICAgICAgXCJwYXJhbWV0ZXJzXCI6IHtcclxuICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcclxuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xyXG4gICAgICAgICAgXCJoeXBvdGhldGljYWxzXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5dO1xyXG4gKi9cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHRvb2wgY2FsbCBhZ2FpbnN0IGl0cyBzcGVjaWZpY2F0aW9uIHRvIGVuc3VyZSBhbGwgcGFyYW1ldGVycyBhcmUgY29ycmVjdC5cclxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgYWxsIHByb3ZpZGVkIGtleXMgaW4gdGhlIHRvb2wgY2FsbCBjb250ZW50IG1hdGNoIHRoZSBleHBlY3RlZCB0eXBlcyxcclxuICogaGFuZGxlcyB0eXBlIGNvZXJjaW9uIGZvciBudW1lcmljIHZhbHVlcywgdmFsaWRhdGVzIGFnYWluc3QgZW51bXMsIGFuZCBlbnN1cmVzIGFsbCByZXF1aXJlZFxyXG4gKiBwYXJhbWV0ZXJzIGFyZSBwcmVzZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbCAtIFRoZSB0b29sIG9iamVjdCBjb250YWluaW5nIHRoZSBmdW5jdGlvbiBzcGVjaWZpY2F0aW9uLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbF9jYWxsX2NvbnRlbnQgLSBUaGUgYWN0dWFsIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSB0b29sIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHRvb2wgY2FsbCBpcyB2YWxpZC5cclxuICogQHRocm93cyB7RXJyb3J9IC0gVGhyb3dzIGFuIGVycm9yIGlmIGFueSB2YWxpZGF0aW9uIGZhaWxzLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNfdmFsaWRfdG9vbF9jYWxsKHRvb2wsIHRvb2xfY2FsbF9jb250ZW50KSB7XHJcbiAgY29uc3QgcHJvcHMgPSB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMucHJvcGVydGllcztcclxuICBpZiAodHlwZW9mIHByb3BzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3Qua2V5cyh0b29sX2NhbGxfY29udGVudCkubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiBvYmplY3QgaXMgZW1wdHlgKTtcclxuICAvLyBjaGVjayBpZiBhbGwga2V5cyBhcmUgaW4gdG9vbCBzcGVjXHJcbiAgT2JqZWN0LmVudHJpZXModG9vbF9jYWxsX2NvbnRlbnQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgaWYgKCFwcm9wc1trZXldKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiBtaXNzaW5nIGtleSAke2tleX0gaW4gdG9vbCBzcGVjYCwgcHJvcHMpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHByb3BzW2tleV0udHlwZSA9PT0gJ2FycmF5Jykge1xyXG4gICAgICAvLyBjaGVjayBpZiBhbGwgaXRlbXMgaW4gdGhlIGFycmF5IGFyZSBvZiB0aGUgc2FtZSB0eXBlXHJcbiAgICAgIGNvbnN0IGl0ZW1UeXBlID0gdHlwZW9mIHZhbHVlWzBdO1xyXG4gICAgICBpZiAoIXZhbHVlLmV2ZXJ5KGl0ZW0gPT4gdHlwZW9mIGl0ZW0gPT09IGl0ZW1UeXBlKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogYXJyYXkgaXRlbXMgYXJlIG5vdCBvZiB0aGUgc2FtZSB0eXBlYCk7XHJcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBhcnJheSBpdGVtcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgc3BlY1xyXG4gICAgICBpZiAocHJvcHNba2V5XS5pdGVtcy50eXBlICE9PSBpdGVtVHlwZSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogYXJyYXkgaXRlbXMgYXJlIG5vdCBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBzcGVjYCk7XHJcbiAgICB9IGVsc2UgaWYgKHByb3BzW2tleV0udHlwZSAhPT0gdHlwZW9mIHZhbHVlKSB7XHJcbiAgICAgIGlmIChwcm9wc1trZXldLnR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlclxyXG4gICAgICAgIGlmIChpc05hTihOdW1iZXIodmFsdWUpKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogdmFsdWUgJHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyYCk7XHJcbiAgICAgICAgdG9vbF9jYWxsX2NvbnRlbnRba2V5XSA9IE51bWJlcih2YWx1ZSk7IC8vIGNvZXJjZSB0byBudW1iZXIgKHNob3VsZCBtdXRhdGUgdG9vbF9jYWxsX2NvbnRlbnQpXHJcbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjYWxsOiB2YWx1ZSAke3ZhbHVlfSBpcyBub3Qgb2YgdHlwZSAke3Byb3BzW2tleV0udHlwZX1gKTtcclxuICAgIH1cclxuICAgIGlmIChwcm9wc1trZXldLmVudW0gJiYgIXByb3BzW2tleV0uZW51bS5pbmNsdWRlcyh2YWx1ZSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IHZhbHVlICR7dmFsdWV9IGlzIG5vdCBpbiBlbnVtICR7cHJvcHNba2V5XS5lbnVtfWApO1xyXG4gIH0pO1xyXG4gIC8vIGNoZWNrIGlmIGFsbCByZXF1aXJlZCBrZXlzIGFyZSBwcmVzZW50XHJcbiAgdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzLnJlcXVpcmVkPy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBpZiAoIXRvb2xfY2FsbF9jb250ZW50W2tleV0pIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b29sIGNhbGw6IG1pc3NpbmcgcmVxdWlyZWQga2V5ICR7a2V5fWApO1xyXG4gIH0pO1xyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNfdmFsaWRfdG9vbF9jYWxsID0gaXNfdmFsaWRfdG9vbF9jYWxsO1xyXG4iLCAiY2xhc3MgU21hcnRTdHJlYW1lciB7XHJcbiAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbWV0aG9kID0gJ0dFVCcsXHJcbiAgICAgIGhlYWRlcnMgPSB7fSxcclxuICAgICAgYm9keSA9IG51bGwsXHJcbiAgICAgIHdpdGhDcmVkZW50aWFscyA9IGZhbHNlXHJcbiAgICB9ID0gb3B0aW9ucztcclxuXHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xyXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscztcclxuICAgIHRoaXMubGlzdGVuZXJzID0ge307XHJcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLkNPTk5FQ1RJTkc7XHJcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcclxuICAgIHRoaXMuY2h1bmsgPSAnJztcclxuICAgIHRoaXMubGFzdF9ldmVudF9pZCA9ICcnO1xyXG4gICAgdGhpcy54aHIgPSBudWxsO1xyXG4gICAgdGhpcy5GSUVMRF9TRVBBUkFUT1IgPSAnOic7XHJcbiAgICB0aGlzLklOSVRJQUxJWklORyA9IC0xO1xyXG4gICAgdGhpcy5DT05ORUNUSU5HID0gMDtcclxuICAgIHRoaXMuT1BFTiA9IDE7XHJcbiAgICB0aGlzLkNMT1NFRCA9IDI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAqL1xyXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XHJcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdLmluY2x1ZGVzKGxpc3RlbmVyKSkgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIFNtYXJ0U3RyZWFtZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUuXHJcbiAgICovXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkgcmV0dXJuO1xyXG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSB0aGlzLmxpc3RlbmVyc1t0eXBlXS5maWx0ZXIoKGNhbGxiYWNrKSA9PiBjYWxsYmFjayAhPT0gbGlzdGVuZXIpO1xyXG4gICAgaWYgKHRoaXMubGlzdGVuZXJzW3R5cGVdLmxlbmd0aCA9PT0gMCkgZGVsZXRlIHRoaXMubGlzdGVuZXJzW3R5cGVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyBhbiBldmVudCB0byB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2hFdmVudChldmVudCkge1xyXG4gICAgaWYgKCFldmVudCkgcmV0dXJuIHRydWU7XHJcbiAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xyXG4gICAgY29uc3Qgb25IYW5kbGVyID0gJ29uJyArIGV2ZW50LnR5cGU7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG9uSGFuZGxlcikpIHtcclxuICAgICAgdGhpc1tvbkhhbmRsZXJdLmNhbGwodGhpcywgZXZlbnQpO1xyXG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdKSB7XHJcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xyXG4gICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYXRlcyB0aGUgc3RyZWFtaW5nIHByb2Nlc3MuXHJcbiAgICovXHJcbiAgc3RyZWFtKCkge1xyXG4gICAgdGhpcy4jc2V0UmVhZHlTdGF0ZSh0aGlzLkNPTk5FQ1RJTkcpO1xyXG4gICAgdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy4jb25TdHJlYW1Qcm9ncmVzcy5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLiNvblN0cmVhbUxvYWRlZC5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCB0aGlzLiNjaGVja1N0cmVhbUNsb3NlZC5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jb25TdHJlYW1GYWlsdXJlLmJpbmQodGhpcykpO1xyXG4gICAgdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzLiNvblN0cmVhbUFib3J0LmJpbmQodGhpcykpO1xyXG4gICAgdGhpcy54aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwpO1xyXG4gICAgZm9yIChjb25zdCBoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XHJcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB0aGlzLmhlYWRlcnNbaGVhZGVyXSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5sYXN0X2V2ZW50X2lkKSB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKCdMYXN0LUV2ZW50LUlEJywgdGhpcy5sYXN0X2V2ZW50X2lkKTtcclxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xyXG4gICAgdGhpcy54aHIuc2VuZCh0aGlzLmJvZHkpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBFbmRzIHRoZSBzdHJlYW1lciBjb25uZWN0aW9uLlxyXG4gICAqIEFib3J0cyB0aGUgY3VycmVudCBYSFIgcmVxdWVzdCBhbmQgc2V0cyB0aGUgcmVhZHkgc3RhdGUgdG8gQ0xPU0VELlxyXG4gICAqL1xyXG4gIGVuZCgpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuQ0xPU0VEKSByZXR1cm47XHJcbiAgICB0aGlzLnhoci5hYm9ydCgpO1xyXG4gICAgdGhpcy54aHIgPSBudWxsO1xyXG4gICAgdGhpcy4jc2V0UmVhZHlTdGF0ZSh0aGlzLkNMT1NFRCk7XHJcbiAgfVxyXG5cclxuICAvLyBwcml2YXRlIG1ldGhvZHNcclxuICAjc2V0UmVhZHlTdGF0ZShzdGF0ZSkge1xyXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3JlYWR5U3RhdGVDaGFuZ2UnKTtcclxuICAgIGV2ZW50LnJlYWR5U3RhdGUgPSBzdGF0ZTtcclxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlO1xyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICB9XHJcbiAgI29uU3RyZWFtRmFpbHVyZShlKSB7XHJcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZXJyb3InKTtcclxuICAgIGV2ZW50LmRhdGEgPSBlLmN1cnJlbnRUYXJnZXQucmVzcG9uc2U7XHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgdGhpcy5lbmQoKTtcclxuICB9XHJcbiAgI29uU3RyZWFtQWJvcnQoZSkge1xyXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Fib3J0Jyk7XHJcbiAgICB0aGlzLmVuZCgpO1xyXG4gIH1cclxuICAjb25TdHJlYW1Qcm9ncmVzcyhlKSB7XHJcbiAgICBpZiAoIXRoaXMueGhyKSByZXR1cm47XHJcbiAgICBpZiAodGhpcy54aHIuc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgdGhpcy4jb25TdHJlYW1GYWlsdXJlKGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkNPTk5FQ1RJTkcpIHtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb3BlbicpKTtcclxuICAgICAgdGhpcy4jc2V0UmVhZHlTdGF0ZSh0aGlzLk9QRU4pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dC5zdWJzdHJpbmcodGhpcy5wcm9ncmVzcyk7XHJcbiAgICB0aGlzLnByb2dyZXNzICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgLy8gZGF0YS5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKXsyfS9nKS5mb3JFYWNoKChwYXJ0KSA9PiB7XHJcbiAgICBkYXRhLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pL2cpLmZvckVhY2goKHBhcnQpID0+IHtcclxuICAgICAgaWYgKHBhcnQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLiNwYXJzZUV2ZW50Q2h1bmsodGhpcy5jaHVuay50cmltKCkpKTtcclxuICAgICAgICB0aGlzLmNodW5rID0gJyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jaHVuayArPSBwYXJ0O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgI29uU3RyZWFtTG9hZGVkKGUpIHtcclxuICAgIHRoaXMuI29uU3RyZWFtUHJvZ3Jlc3MoZSk7XHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy4jcGFyc2VFdmVudENodW5rKHRoaXMuY2h1bmspKTtcclxuICAgIHRoaXMuY2h1bmsgPSAnJztcclxuICB9XHJcbiAgI3BhcnNlRXZlbnRDaHVuayhjaHVuaykge1xyXG4gICAgaWYgKCFjaHVuayB8fCBjaHVuay5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgZSA9IHsgaWQ6IG51bGwsIHJldHJ5OiBudWxsLCBkYXRhOiAnJywgZXZlbnQ6ICdtZXNzYWdlJywgdGV4dDogJycgfTtcclxuICAgIGNodW5rLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZm9yRWFjaCgobGluZSkgPT4ge1xyXG4gICAgICAvLyBsaW5lID0gbGluZS50cmltUmlnaHQoKTtcclxuICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xyXG4gICAgICBjb25zdCBpbmRleCA9IGxpbmUuaW5kZXhPZih0aGlzLkZJRUxEX1NFUEFSQVRPUik7XHJcbiAgICAgIGlmIChpbmRleCA8PSAwKSByZXR1cm47XHJcbiAgICAgIC8vIGNvbnN0IGZpZWxkID0gbGluZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xyXG4gICAgICAvLyBhbHNvIHJlbW92ZSBxdW90ZXNcclxuICAgICAgY29uc3QgZmllbGQgPSBsaW5lLnN1YnN0cmluZygwLCBpbmRleCkucmVwbGFjZSgvXlwifFwiJC9nLCAnJyk7XHJcbiAgICAgIGlmKCFbJ2lkJywgJ3JldHJ5JywgJ2RhdGEnLCAnZXZlbnQnLCAndGV4dCddLmluY2x1ZGVzKGZpZWxkKSkgcmV0dXJuO1xyXG4gICAgICAvLyBpZiAoIShmaWVsZCBpbiBlKSkgcmV0dXJuO1xyXG4gICAgICAvLyBjb25zdCB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGluZGV4ICsgMSkudHJpbUxlZnQoKTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyhpbmRleCArIDEpLnRyaW0oKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKTtcclxuICAgICAgLy8gaWYgKGZpZWxkID09PSAnZGF0YScpIGVbZmllbGRdICs9IHZhbHVlO1xyXG4gICAgICAvLyBlbHNlIGVbZmllbGRdID0gdmFsdWU7XHJcbiAgICAgIGUuZGF0YSArPSB2YWx1ZTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGUuaWQpIHRoaXMubGFzdF9ldmVudF9pZCA9IGUuaWQ7XHJcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChlLmV2ZW50IHx8ICdtZXNzYWdlJyk7XHJcbiAgICBldmVudC5pZCA9IGUuaWQ7XHJcbiAgICBldmVudC5kYXRhID0gZS5kYXRhIHx8ICcnO1xyXG4gICAgZXZlbnQubGFzdF9ldmVudF9pZCA9IHRoaXMubGFzdF9ldmVudF9pZDtcclxuICAgIHJldHVybiBldmVudDtcclxuICB9XHJcbiAgI2NoZWNrU3RyZWFtQ2xvc2VkKCkge1xyXG4gICAgaWYgKCF0aGlzLnhocikgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMueGhyLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHRoaXMuI3NldFJlYWR5U3RhdGUodGhpcy5DTE9TRUQpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydHMuU21hcnRTdHJlYW1lciA9IFNtYXJ0U3RyZWFtZXI7XHJcbiIsICJhc3luYyBmdW5jdGlvbiBmZXRjaF9vcGVuX3JvdXRlcl9tb2RlbHMoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjEvbW9kZWxzJyk7XHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ01vZGVsIGRhdGEgcmV0cmlldmVkOicsIGRhdGEpO1xyXG4gICAgcmV0dXJuIGRhdGEuZGF0YVxyXG4gICAgICAvLyAuZmlsdGVyKG1vZGVsID0+ICFtb2RlbC5pZC5pbmNsdWRlcygnaW5zdHJ1Y3QnKSlcclxuICAgICAgLm1hcChtb2RlbCA9PiAoe1xyXG4gICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLmlkLFxyXG4gICAgICAgIGtleTogbW9kZWwuaWQsXHJcbiAgICAgICAgbWF4X2lucHV0X3Rva2VuczogbW9kZWwuY29udGV4dF9sZW5ndGgsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IG1vZGVsLm5hbWUsXHJcbiAgICAgICAgYWN0aW9uczogbW9kZWwuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ3Rvb2wgdXNlJykgfHwgbW9kZWwuZGVzY3JpcHRpb24uaW5jbHVkZXMoJ2Z1bmN0aW9uIGNhbGwnKSxcclxuICAgICAgICBtdWx0aW1vZGFsOiBtb2RlbC5hcmNoaXRlY3R1cmUubW9kYWxpdHkgPT09ICdtdWx0aW1vZGFsJyxcclxuICAgICAgICByYXc6IG1vZGVsXHJcbiAgICAgIH0pKVxyXG4gICAgO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggbW9kZWwgZGF0YTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZmV0Y2hfb3Blbl9yb3V0ZXJfbW9kZWxzID0gZmV0Y2hfb3Blbl9yb3V0ZXJfbW9kZWxzOyIsICJjb25zdCBtb2RlbF9jb250ZXh0ID0ge1xyXG4gIFwiZ3B0LTMuNS10dXJiby0wMTI1XCI6IHtcclxuICAgIFwiY29udGV4dFwiOiAxNjM4NSxcclxuICAgIFwibWF4X291dFwiOiA0MDk2XHJcbiAgfSxcclxuICBcImdwdC0zLjUtdHVyYm8tMDMwMVwiOiB7XHJcbiAgICBcImNvbnRleHRcIjogNDA5NyxcclxuICAgIFwibWF4X291dFwiOiA0MDk3XHJcbiAgfSxcclxuICBcImdwdC0zLjUtdHVyYm8tMDYxM1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogNDA5NyxcclxuICAgIFwibWF4X291dFwiOiA0MDk3XHJcbiAgfSxcclxuICBcImdwdC0zLjUtdHVyYm8tMTEwNlwiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTYzODUsXHJcbiAgICBcIm1heF9vdXRcIjogNDA5NlxyXG4gIH0sXHJcbiAgXCJncHQtMy41LXR1cmJvLTE2a1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTYzODUsXHJcbiAgICBcIm1heF9vdXRcIjogMTYzODVcclxuICB9LFxyXG4gIFwiZ3B0LTMuNS10dXJiby0xNmstMDYxM1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTYzODUsXHJcbiAgICBcIm1heF9vdXRcIjogMTYzODVcclxuICB9LFxyXG4gIFwiZ3B0LTQtMDEyNS1wcmV2aWV3XCI6IHtcclxuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXHJcbiAgICBcIm1heF9vdXRcIjogNDA5NlxyXG4gIH0sXHJcbiAgXCJncHQtNC0wMzE0XCI6IHtcclxuICAgIFwiY29udGV4dFwiOiA4MTkyLFxyXG4gICAgXCJtYXhfb3V0XCI6IDgxOTJcclxuICB9LFxyXG4gIFwiZ3B0LTQtMDYxM1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogODE5MixcclxuICAgIFwibWF4X291dFwiOiA4MTkyXHJcbiAgfSxcclxuICBcImdwdC00LTExMDYtcHJldmlld1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxyXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcclxuICB9LFxyXG4gIFwiZ3B0LTQtMTEwNi12aXNpb24tcHJldmlld1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxyXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcclxuICB9LFxyXG4gIFwiZ3B0LTQtMzJrLTAzMTRcIjoge1xyXG4gICAgXCJjb250ZXh0XCI6IDMyNzY4LFxyXG4gICAgXCJtYXhfb3V0XCI6IDMyNzY4XHJcbiAgfSxcclxuICBcImdwdC00LTMyay0wNjEzXCI6IHtcclxuICAgIFwiY29udGV4dFwiOiAzMjc2OCxcclxuICAgIFwibWF4X291dFwiOiAzMjc2OFxyXG4gIH0sXHJcbiAgXCJncHQtNC10dXJiby0yMDI0LTA0LTA5XCI6IHtcclxuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXHJcbiAgICBcIm1heF9vdXRcIjogNDA5NlxyXG4gIH0sXHJcbiAgXCJncHQtNC10dXJiby1wcmV2aWV3XCI6IHtcclxuICAgIFwiY29udGV4dFwiOiAxMjgwMDAsXHJcbiAgICBcIm1heF9vdXRcIjogNDA5NlxyXG4gIH0sXHJcbiAgXCJncHQtNC12aXNpb24tcHJldmlld1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxyXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcclxuICB9LFxyXG4gIFwiZ3B0LTMuNS10dXJib1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTYzODUsXHJcbiAgICBcIm1heF9vdXRcIjogNDA5NlxyXG4gIH0sXHJcbiAgXCJncHQtNC10dXJib1wiOiB7XHJcbiAgICBcImNvbnRleHRcIjogMTI4MDAwLFxyXG4gICAgXCJtYXhfb3V0XCI6IDQwOTZcclxuICB9LFxyXG4gIFwiZ3B0LTQtMzJrXCI6IHtcclxuICAgIFwiY29udGV4dFwiOiAzMjc2OCxcclxuICAgIFwibWF4X291dFwiOiAzMjc2OFxyXG4gIH0sXHJcbiAgXCJncHQtNG9cIjoge1xyXG4gICAgXCJjb250ZXh0XCI6IDEyODAwMCxcclxuICAgIFwibWF4X291dFwiOiA0MDk2XHJcbiAgfSxcclxuICBcImdwdC00XCI6IHtcclxuICAgIFwiY29udGV4dFwiOiA4MTkyLFxyXG4gICAgXCJtYXhfb3V0XCI6IDgxOTJcclxuICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hfb3BlbmFpX21vZGVscyhhcGlfa2V5KSB7XHJcbiAgaWYgKCFhcGlfa2V5KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdObyBBUEkga2V5IHByb3ZpZGVkJyk7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL21vZGVscycsIHtcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FwaV9rZXl9YCxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVzcG9uc2Ugd2FzIG5vdCBvaycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnNvbGUubG9nKCdNb2RlbCBkYXRhIHJldHJpZXZlZDonLCBkYXRhKTtcclxuICAgIHJldHVybiBkYXRhLmRhdGFcclxuICAgICAgLmZpbHRlcihtb2RlbCA9PiBtb2RlbC5pZC5zdGFydHNXaXRoKCdncHQtJykgJiYgIW1vZGVsLmlkLmluY2x1ZGVzKCctaW5zdHJ1Y3QnKSlcclxuICAgICAgLm1hcChtb2RlbCA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3V0ID0ge1xyXG4gICAgICAgICAgbW9kZWxfbmFtZTogbW9kZWwuaWQsIFxyXG4gICAgICAgICAga2V5OiBtb2RlbC5pZCxcclxuICAgICAgICAgIG11bHRpbW9kYWw6IG1vZGVsLmlkLmluY2x1ZGVzKCd2aXNpb24nKSB8fCBtb2RlbC5pZC5pbmNsdWRlcygnZ3B0LTQtdHVyYm8nKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbSA9IE9iamVjdC5lbnRyaWVzKG1vZGVsX2NvbnRleHQpLmZpbmQobSA9PiBtWzBdID09PSBtb2RlbC5pZCB8fCBtb2RlbC5pZC5zdGFydHNXaXRoKG1bMF0gKyAnLScpKTtcclxuICAgICAgICBpZihtKSB7XHJcbiAgICAgICAgICBvdXQubWF4X2lucHV0X3Rva2VucyA9IG1bMV0uY29udGV4dDtcclxuICAgICAgICAgIG91dC5kZXNjcmlwdGlvbiA9IGBjb250ZXh0OiAke21bMV0uY29udGV4dH0sIG91dHB1dDogJHttWzFdLm1heF9vdXR9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgfSlcclxuICAgIDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG1vZGVsIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5leHBvcnRzLmZldGNoX29wZW5haV9tb2RlbHMgPSBmZXRjaF9vcGVuYWlfbW9kZWxzOyIsICJhc3luYyBmdW5jdGlvbiBmZXRjaF9nb29nbGVfZ2VtaW5pX21vZGVscyhhcGlfa2V5KSB7XHJcbiAgaWYgKCFhcGlfa2V5KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdObyBBUEkga2V5IHByb3ZpZGVkJyk7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzP2tleT0nICsgYXBpX2tleSk7XHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayByZXNwb25zZSB3YXMgbm90IG9rJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc29sZS5sb2coJ01vZGVsIGRhdGEgcmV0cmlldmVkOicsIGRhdGEpO1xyXG4gICAgcmV0dXJuIGRhdGEubW9kZWxzXHJcbiAgICAgIC5maWx0ZXIobW9kZWwgPT4gbW9kZWwubmFtZS5zdGFydHNXaXRoKCdtb2RlbHMvZ2VtaW5pJykpXHJcbiAgICAgIC5tYXAobW9kZWwgPT4ge1xyXG4gICAgICAgIGNvbnN0IG91dCA9IHtcclxuICAgICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLm5hbWUuc3BsaXQoJy8nKS5wb3AoKSwgXHJcbiAgICAgICAgICBrZXk6IG1vZGVsLm5hbWUuc3BsaXQoJy8nKS5wb3AoKSxcclxuICAgICAgICAgIG1heF9pbnB1dF90b2tlbnM6IG1vZGVsLmlucHV0VG9rZW5MaW1pdCxcclxuICAgICAgICAgIG1heF9vdXRwdXRfdG9rZW5zOiBtb2RlbC5tYXhPdXRwdXRUb2tlbnMsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICBtdWx0aW1vZGFsOiBtb2RlbC5uYW1lLmluY2x1ZGVzKCd2aXNpb24nKSB8fCBtb2RlbC5kZXNjcmlwdGlvbi5pbmNsdWRlcygnbXVsdGltb2RhbCcpLFxyXG4gICAgICAgICAgcmF3OiBtb2RlbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBtb2RlbCBkYXRhOicsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5mZXRjaF9nb29nbGVfZ2VtaW5pX21vZGVscyA9IGZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzOyIsICIvLyBjdXJsIC0tcmVxdWVzdCBHRVQgXFxcclxuLy8gICAtLXVybCBodHRwczovL2FwaS5jb2hlcmUuYWkvdjEvbW9kZWxzIFxcXHJcbi8vICAgLS1oZWFkZXIgJ2FjY2VwdDogYXBwbGljYXRpb24vanNvbicgXFxcclxuLy8gICAtLWhlYWRlciBcIkF1dGhvcml6YXRpb246IGJlYXJlciAkQ09fQVBJX0tFWVwiXHJcblxyXG5hc3luYyBmdW5jdGlvbiBmZXRjaF9jb2hlcmVfbW9kZWxzKGFwaV9rZXkpIHtcclxuICBpZiAoIWFwaV9rZXkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ05vIEFQSSBrZXkgcHJvdmlkZWQnKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLmNvaGVyZS5haS92MS9tb2RlbHMnLCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthcGlfa2V5fWAsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIHJlc3BvbnNlIHdhcyBub3Qgb2snKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygnTW9kZWwgZGF0YSByZXRyaWV2ZWQ6JywgZGF0YSk7XHJcbiAgICByZXR1cm4gZGF0YS5tb2RlbHNcclxuICAgICAgLmZpbHRlcihtb2RlbCA9PiBtb2RlbC5uYW1lLnN0YXJ0c1dpdGgoJ2NvbW1hbmQtJykpXHJcbiAgICAgIC5tYXAobW9kZWwgPT4ge1xyXG4gICAgICAgIGNvbnN0IG91dCA9IHtcclxuICAgICAgICAgIG1vZGVsX25hbWU6IG1vZGVsLm5hbWUsXHJcbiAgICAgICAgICBrZXk6IG1vZGVsLm5hbWUsXHJcbiAgICAgICAgICBtYXhfaW5wdXRfdG9rZW5zOiBtb2RlbC5jb250ZXh0X2xlbmd0aCxcclxuICAgICAgICAgIHRva2VuaXplcl91cmw6IG1vZGVsLnRva2VuaXplcl91cmwsXHJcbiAgICAgICAgICBmaW5ldHVuZWQ6IG1vZGVsLmZpbmV0dW5lZCxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgTWF4IGlucHV0IHRva2VuczogJHttb2RlbC5jb250ZXh0X2xlbmd0aH0sIEZpbmV0dW5lZDogJHttb2RlbC5maW5ldHVuZWR9YFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBtb2RlbCBkYXRhOicsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5mZXRjaF9jb2hlcmVfbW9kZWxzID0gZmV0Y2hfY29oZXJlX21vZGVscztcclxuXHJcbiIsICIvLyBmYWtlIGl0IGJlY2F1c2UgYW50aHJvcGljIGRvZXNuJ3QgaGF2ZSBtb2RlbCBsaXN0IEFQSSBlbmRwb2ludFxyXG5hc3luYyBmdW5jdGlvbiBmZXRjaF9hbnRocm9waWNfbW9kZWxzKCkge1xyXG4gIHJldHVybiBbe1xyXG4gICAgXCJrZXlcIjogXCJjbGF1ZGUtMy1vcHVzLTIwMjQwMjI5XCIsXHJcbiAgICBcIm1vZGVsX25hbWVcIjogXCJjbGF1ZGUtMy1vcHVzLTIwMjQwMjI5XCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgQ2xhdWRlIE9wdXNcIixcclxuICAgIFwibWF4X2lucHV0X3Rva2Vuc1wiOiAyMDAwMDAsXHJcbiAgICBcIm1heF9vdXRwdXRfdG9rZW5zXCI6IDQwMDAsXHJcbiAgICBcIm11bHRpbW9kYWxcIjogdHJ1ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAga2V5OiBcImNsYXVkZS0zLXNvbm5ldC0yMDI0MDIyOVwiLFxyXG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5XCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgQ2xhdWRlIFNvbm5ldFwiLFxyXG4gICAgXCJtYXhfaW5wdXRfdG9rZW5zXCI6IDIwMDAwMCxcclxuICAgIFwibWF4X291dHB1dF90b2tlbnNcIjogNDAwMCxcclxuICAgIFwibXVsdGltb2RhbFwiOiB0cnVlXHJcbiAgfSxcclxuICB7XHJcbiAgICBrZXk6IFwiY2xhdWRlLTMtaGFpa3UtMjAyNDAzMDdcIixcclxuICAgIFwibW9kZWxfbmFtZVwiOiBcImNsYXVkZS0zLWhhaWt1LTIwMjQwMzA3XCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW50aHJvcGljJ3MgQ2xhdWRlIEhhaWt1XCIsXHJcbiAgICBcIm1heF9pbnB1dF90b2tlbnNcIjogMjAwMDAwLFxyXG4gICAgXCJtYXhfb3V0cHV0X3Rva2Vuc1wiOiA0MDAwLFxyXG4gICAgXCJtdWx0aW1vZGFsXCI6IHRydWVcclxuICB9XTtcclxufVxyXG5leHBvcnRzLmZldGNoX2FudGhyb3BpY19tb2RlbHMgPSBmZXRjaF9hbnRocm9waWNfbW9kZWxzO1xyXG5cclxuIiwgImNvbnN0IHsgZmV0Y2hfb3Blbl9yb3V0ZXJfbW9kZWxzIH0gPSByZXF1aXJlKCcuL29wZW5fcm91dGVyJyk7XHJcbmNvbnN0IHsgZmV0Y2hfb3BlbmFpX21vZGVscyB9ID0gcmVxdWlyZSgnLi9vcGVuYWknKTtcclxuY29uc3QgeyBmZXRjaF9nb29nbGVfZ2VtaW5pX21vZGVscyB9ID0gcmVxdWlyZSgnLi9nb29nbGVfZ2VtaW5pJyk7XHJcbmNvbnN0IHsgZmV0Y2hfY29oZXJlX21vZGVscyB9ID0gcmVxdWlyZSgnLi9jb2hlcmUnKTtcclxuY29uc3QgeyBmZXRjaF9hbnRocm9waWNfbW9kZWxzIH0gPSByZXF1aXJlKCcuL2FudGhyb3BpYycpO1xyXG5leHBvcnRzLm9wZW5fcm91dGVyID0gZmV0Y2hfb3Blbl9yb3V0ZXJfbW9kZWxzO1xyXG5leHBvcnRzLm9wZW5haSA9IGZldGNoX29wZW5haV9tb2RlbHM7XHJcbmV4cG9ydHMuZ29vZ2xlX2dlbWluaSA9IGZldGNoX2dvb2dsZV9nZW1pbmlfbW9kZWxzO1xyXG5leHBvcnRzLmNvaGVyZSA9IGZldGNoX2NvaGVyZV9tb2RlbHM7XHJcbmV4cG9ydHMuYW50aHJvcGljID0gZmV0Y2hfYW50aHJvcGljX21vZGVscztcclxuXHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIEJyaWFuIEpvc2VwaCBQZXRyb1xyXG5cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbi8vIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcclxuLy8gTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxyXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cclxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG5jb25zdCBhZGFwdGVycyA9IHJlcXVpcmUoJy4vYWRhcHRlcnMnKTtcclxuY29uc3QgcGxhdGZvcm1zID0gcmVxdWlyZSgnLi9wbGF0Zm9ybXMuanNvbicpO1xyXG5jb25zdCB7IGlzX3ZhbGlkX3Rvb2xfY2FsbCB9ID0gcmVxdWlyZSgnLi91dGlscy9pc192YWxpZF90b29sX2NhbGwnKTtcclxuY29uc3QgeyBTbWFydFN0cmVhbWVyIH0gPSByZXF1aXJlKCcuL3N0cmVhbWVyJyk7XHJcbmNvbnN0IGZldGNoX21vZGVscyA9IHJlcXVpcmUoXCIuL21vZGVscy9mZXRjaFwiKTtcclxuLyoqXHJcbiAqIFNtYXJ0Q2hhdE1vZGVsIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdGllcyB0byBoYW5kbGUgY2hhdCBpbnRlcmFjdGlvbnMgd2l0aCB2YXJpb3VzIG1vZGVscyBhbmQgYWRhcHRlcnMuXHJcbiAqIEl0IHN1cHBvcnRzIHN0cmVhbWluZyBhbmQgbm9uLXN0cmVhbWluZyByZXNwb25zZXMsIHRvb2wgY2FsbHMsIGFuZCBjdXN0b21pemF0aW9ucyB0aHJvdWdoIG9wdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBTbWFydENoYXRNb2RlbCB7XHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiBTbWFydENoYXRNb2RlbCB3aXRoIHNwZWNpZmllZCBlbnZpcm9ubWVudCwgbW9kZWwga2V5LCBhbmQgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIGVudmlyb25tZW50IGNvbnRleHQsIHR5cGljYWxseSBjb250YWluaW5nIGNvbmZpZ3VyYXRpb25zIGFuZCBzdGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm1fa2V5IC0gS2V5IHRvIHNlbGVjdCB0aGUgc3BlY2lmaWMgbW9kZWwgY29uZmlndXJhdGlvbiBmcm9tIG1vZGVscy5qc29uLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9jb25maWcgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIG92ZXJyaWRlIG1vZGVsIGNvbmZpZ3VyYXRpb25zLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG1haW4sIHBsYXRmb3JtX2tleSwgbW9kZWxfY29uZmlnPXt9KSB7XHJcbiAgICB0aGlzLmVudiA9IG1haW47XHJcbiAgICB0aGlzLm1haW4gPSB0aGlzLmVudjsgLy8gREVQUkVDQVRFRFxyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgIC4uLihwbGF0Zm9ybXNbcGxhdGZvcm1fa2V5XSB8fCB7fSksXHJcbiAgICAgIC4uLm1vZGVsX2NvbmZpZywgLy8gb3ZlcnJpZGUgZGVmYXVsdCBwbGF0Zm9ybSBjb25maWdcclxuICAgIH1cclxuICAgIHRoaXMucGxhdGZvcm1fa2V5ID0gcGxhdGZvcm1fa2V5O1xyXG4gICAgdGhpcy5hY3RpdmVfc3RyZWFtID0gbnVsbDtcclxuICAgIHRoaXMuX3JlcXVlc3RfYWRhcHRlciA9IG51bGw7XHJcbiAgICB0aGlzLnBsYXRmb3JtcyA9IHBsYXRmb3JtcztcclxuICAgIGlmKHRoaXMuY29uZmlnLmFkYXB0ZXIpIHRoaXMuYWRhcHRlciA9IG5ldyBhZGFwdGVyc1t0aGlzLmNvbmZpZy5hZGFwdGVyXSh0aGlzKTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMuYWRhcHRlcik7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgbW9kZWxzKCkgeyByZXR1cm4gcGxhdGZvcm1zOyB9XHJcbiAgZ2V0IGRlZmF1bHRfb3B0cygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjMsXHJcbiAgICAgIHRvcF9wOiAxLFxyXG4gICAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxyXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcclxuICAgICAgbjogMSxcclxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxfbmFtZSxcclxuICAgICAgbWF4X3Rva2VuczogdGhpcy5tYXhfb3V0cHV0X3Rva2VucyxcclxuICAgIH07XHJcbiAgfVxyXG4gIGFzeW5jIHJlcXVlc3RfbWlkZGxld2FyZXMob3B0cykgeyByZXR1cm4gb3B0czsgfVxyXG4gIC8qKlxyXG4gICAqIENvbXBsZXRlcyB0aGUgY2hhdCBpbnRlcmFjdGlvbiBieSBwcm9jZXNzaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zLCBtYWtpbmcgYW4gQVBJIHJlcXVlc3QsIGFuZCBoYW5kbGluZyB0aGUgcmVzcG9uc2UuXHJcbiAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgYm90aCBzdHJlYW1pbmcgYW5kIG5vbi1zdHJlYW1pbmcgcmVzcG9uc2VzLCBhbmQgY2FuIGhhbmRsZSB0b29sIGNhbGxzIGlmIHNwZWNpZmllZCBpbiB0aGUgcmVzcG9uc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIGZvciB0aGUgY2hhdCBjb21wbGV0aW9uIHdoaWNoIG1heSBpbmNsdWRlIHNldHRpbmdzIGxpa2UgdGVtcGVyYXR1cmUsIG1heCB0b2tlbnMsIGV0Yy5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlciAtIEZsYWcgdG8gZGV0ZXJtaW5lIGlmIHRoZSByZXNwb25zZSBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIFVJLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3x2b2lkPn0gLSBSZXR1cm5zIHRoZSBjaGF0IHJlc3BvbnNlIGNvbnRlbnQgb3IgaGFuZGxlcyB0b29sIG91dHB1dHMgcmVjdXJzaXZlbHkuIEluIGNhc2Ugb2YgZXJyb3JzLCBpdCBtYXkgcmV0dXJuIGFuIGVycm9yIG1lc3NhZ2UuXHJcbiAgICovXHJcbiAgYXN5bmMgY29tcGxldGUob3B0cz17fSwgcmVuZGVyPXRydWUpIHtcclxuICAgIGlmKCF0aGlzLmJhc2VfbW9kZWxfY29uZmlnKXtcclxuICAgICAgdGhpcy5iYXNlX21vZGVsX2NvbmZpZyA9IGF3YWl0IHRoaXMuZ2V0X2Jhc2VfbW9kZWxfY29uZmlnKCk7XHJcbiAgICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgIC4uLnRoaXMuYmFzZV9tb2RlbF9jb25maWcsXHJcbiAgICAgICAgLi4udGhpcy5jb25maWcsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBvcHRzID0ge1xyXG4gICAgICAuLi50aGlzLmRlZmF1bHRfb3B0cyxcclxuICAgICAgbWVzc2FnZXM6IChhd2FpdCB0aGlzLmN1cnJlbnQ/LmdldF9jaGF0X21sKCkpPy5tZXNzYWdlcyB8fCBbXSxcclxuICAgICAgLi4ub3B0cyxcclxuICAgIH07XHJcbiAgICBpZihvcHRzLnN0cmVhbSAhPT0gZmFsc2UgJiYgdGhpcy5jb25maWcuc3RyZWFtaW5nICYmICF0aGlzLmN1cnJlbnQ/LnRvb2xfY2hvaWNlKSBvcHRzLnN0cmVhbSA9IHRydWU7IC8vIG5vIHN0cmVhbWluZyBpZiB0b29sX2Nob2ljZSBpcyBzZXRcclxuICAgIGVsc2Ugb3B0cy5zdHJlYW0gPSBmYWxzZTtcclxuICAgIG9wdHMgPSBhd2FpdCB0aGlzLnJlcXVlc3RfbWlkZGxld2FyZXMoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRzKSkpO1xyXG4gICAgY29uc3QgcmVxID0ge1xyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpX2tleX1gXHJcbiAgICAgIH0sXHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICB9O1xyXG4gICAgaWYgKHRoaXMuY29uZmlnLmhlYWRlcnMpIHJlcS5oZWFkZXJzID0geyAuLi5yZXEuaGVhZGVycywgLi4udGhpcy5jb25maWcuaGVhZGVycyB9O1xyXG4gICAgaWYgKHRoaXMuY29uZmlnLmFwaV9rZXlfaGVhZGVyKSB7XHJcbiAgICAgIGlmKHRoaXMuY29uZmlnLmFwaV9rZXlfaGVhZGVyICE9PSAnbm9uZScpIHJlcS5oZWFkZXJzW3RoaXMuY29uZmlnLmFwaV9rZXlfaGVhZGVyXSA9IHRoaXMuYXBpX2tleTtcclxuICAgICAgZGVsZXRlIHJlcS5oZWFkZXJzLkF1dGhvcml6YXRpb247XHJcbiAgICB9XHJcbiAgICAvLyBib2R5IGNvbnN0YW50IHN0b3JlcyBjaGF0bWwgZm9yIGxhdGVyXHJcbiAgICBjb25zdCBib2R5ID0gdHlwZW9mIHRoaXMuZW52LmFjdGlvbnM/LnByZXBhcmVfcmVxdWVzdF9ib2R5ID09PSAnZnVuY3Rpb24nID8gdGhpcy5lbnYuYWN0aW9ucy5wcmVwYXJlX3JlcXVlc3RfYm9keShvcHRzKSA6IHsgLi4ub3B0cyB9O1xyXG4gICAgLy8gYWRhcHRlciBjYW4gbW9kaWZ5IGJvZHkgYmFzZWQgb24gcGxhdGZvcm1cclxuICAgIHJlcS5ib2R5ID0gSlNPTi5zdHJpbmdpZnkodHlwZW9mIHRoaXMuYWRhcHRlcj8ucHJlcGFyZV9yZXF1ZXN0X2JvZHkgPT09ICdmdW5jdGlvbicgPyB0aGlzLmFkYXB0ZXIucHJlcGFyZV9yZXF1ZXN0X2JvZHkoYm9keSkgOiBib2R5KTtcclxuICAgIGNvbnNvbGUubG9nKHJlcSk7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZihvcHRzLnN0cmVhbSkgcmV0dXJuIGF3YWl0IHRoaXMuc3RyZWFtKHJlcSk7XHJcbiAgICAgIC8vIEhBTkRMRSBOT04tU1RSRUFNSU5HIChpbmNsdWRlcyBhbGwgZnVuY3Rpb24gY2FsbHMpXHJcbiAgICAgIGNvbnN0IHJlc3BfanNvbiA9IGF3YWl0IHRoaXMucmVxdWVzdChyZXEpO1xyXG4gICAgICBpZihyZXNwX2pzb24uZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKHJlc3BfanNvbi5lcnJvcik7XHJcbiAgICAgICAgaWYocmVuZGVyKSB0aGlzLmRvbmVfaGFuZGxlcihcIipBUEkgRXJyb3IuIFNlZSBjb25zb2xlIGxvZ3MgZm9yIGRldGFpbHMuKlwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgaXMgdG9vbF9jYWxsLCBoYW5kbGUgdG9vbF9jYWxsIGFuZCByZXR1cm5cclxuICAgICAgY29uc3QgdG9vbF9jYWxsID0gdGhpcy5nZXRfdG9vbF9jYWxsKHJlc3BfanNvbik7XHJcbiAgICAgIGlmKHRvb2xfY2FsbCl7XHJcbiAgICAgICAgdGhpcy5lbnYuY2hhdHMuY3VycmVudC50b29sX2Nob2ljZSA9IG51bGw7IC8vIElNUE9SVEFOVDogcHJldmVudCBpbmZpbml0ZSBsb29wXHJcbiAgICAgICAgLy8gaWYgKHRoaXMuY3VycmVudC50b29sX2Nob2ljZSAhPT0gXCJhdXRvXCIpIHRoaXMuY3VycmVudC50b29sX2Nob2ljZSA9IG51bGw7IC8vIHJlbW92ZSB0b29sX2Nob2ljZSBmcm9tIGN1cnJlbnQgaWYgbm90IGF1dG8gKHByZXZlbnQgaW5maW5pdGUgbG9vcClcclxuICAgICAgICBjb25zdCB0b29sX25hbWUgPSB0aGlzLmdldF90b29sX25hbWUodG9vbF9jYWxsKTtcclxuICAgICAgICBjb25zdCB0b29sX2NhbGxfY29udGVudCA9IHRoaXMuZ2V0X3Rvb2xfY2FsbF9jb250ZW50KHRvb2xfY2FsbCk7XHJcbiAgICAgICAgY29uc3QgdG9vbCA9IGJvZHkudG9vbHMuZmluZCgodCkgPT4gdC5mdW5jdGlvbi5uYW1lID09PSB0b29sX25hbWUpOyAvLyBwbGF0Zm9ybS1hZ25vc3RpY1xyXG4gICAgICAgIGlmKGlzX3ZhbGlkX3Rvb2xfY2FsbCh0b29sLCB0b29sX2NhbGxfY29udGVudCkpe1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5jdXJyZW50LmFkZF9tZXNzYWdlKHsgcm9sZTogJ2Fzc2lzdGFudCcsIHRvb2xfY2FsbHM6IFt7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgbmFtZTogdG9vbF9uYW1lLFxyXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX2NvbnRlbnQpLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XSB9KTtcclxuICAgICAgICAgIGNvbnN0IHRvb2xfaGFuZGxlciA9IHRoaXMuZ2V0X3Rvb2xfaGFuZGxlcih0b29sX25hbWUpO1xyXG4gICAgICAgICAgaWYoIXRvb2xfaGFuZGxlcikgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFRvb2wgJHt0b29sX25hbWV9IG5vdCBmb3VuZGApO1xyXG4gICAgICAgICAgY29uc3QgdG9vbF9vdXRwdXQgPSBhd2FpdCB0b29sX2hhbmRsZXIodGhpcy5lbnYsIHRvb2xfY2FsbF9jb250ZW50KTtcclxuICAgICAgICAgIGlmKHRvb2xfb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudC5hZGRfdG9vbF9vdXRwdXQodG9vbF9uYW1lLCB0b29sX291dHB1dCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC50b29sX2Nob2ljZSA9ICdub25lJzsgLy8gcHJldmVudCBzdWJzZXF1ZW50IGZ4X2NhbGwgZnJvbSBwcmV2ZW50aW5nIGNvbXBsZXRpb25cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUoe30pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgLy8gRE86IHVzZSB0b29sIHNwZWNzIHRvIGNvZXJjZSB0b29sX2NhbGwgdG8gbWF0Y2ggdG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzXHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHRvb2wgY2FsbDogJHt0b29sX2NhbGx9YCk7XHJcbiAgICAgICAgICBpZihyZW5kZXIpIHRoaXMuZG9uZV9oYW5kbGVyKFwiKkludmFsaWQgdG9vbCBjYWxsLiBTZWUgY29uc29sZSBsb2dzIGZvciBkZXRhaWxzLipcIik7XHJcbiAgICAgICAgICByZXR1cm4gXCIqSW52YWxpZCB0b29sIGNhbGwuIFNlZSBjb25zb2xlIGxvZ3MgZm9yIGRldGFpbHMuKlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYocmVuZGVyKSB0aGlzLmRvbmVfaGFuZGxlcih0aGlzLmdldF9tZXNzYWdlX2NvbnRlbnQocmVzcF9qc29uKSk7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldF9tZXNzYWdlX2NvbnRlbnQocmVzcF9qc29uKTtcclxuICAgICAgLy8gY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgLy8gbmV3IE5vdGljZShgU21hcnQgQ29ubmVjdGlvbnMgQVBJIEVycm9yIDo6ICR7ZXJyfWApO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBIQU5ETEUgVE9PTFNcclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgdGhlIHRvb2wgaGFuZGxlciBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgdG9vbCBuYW1lIGZyb20gdGhlIGVudmlyb25tZW50J3MgYWN0aW9ucy5cclxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byB1c2UgY3VzdG9tIGxvZ2ljIGZvciBoYW5kbGluZyB0b29scy5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbF9uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRvb2wgZm9yIHdoaWNoIHRoZSBoYW5kbGVyIGlzIHRvIGJlIHJldHJpZXZlZC5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIHRvb2wuXHJcbiAgICovXHJcbiAgZ2V0X3Rvb2xfaGFuZGxlcih0b29sX25hbWUpIHsgcmV0dXJuIHRoaXMuZW52LmFjdGlvbnMuYWN0aW9uc1t0b29sX25hbWVdLmhhbmRsZXI7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdHMgdGhlIHRvb2wgY2FsbCBpbmZvcm1hdGlvbiBmcm9tIGEgSlNPTiByZXNwb25zZS4gVGhpcyBtZXRob2Qgc3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBsb2dpYy5cclxuICAgKiBJZiBubyBhZGFwdGVyIG1ldGhvZCBpcyBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gdGhlIGV4cGVjdGVkIE9wZW5BSSBKU09OIGZvcm1hdC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdG9vbCBjYWxsLlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmaXJzdCB0b29sIGNhbGwgZm91bmQgaW4gdGhlIHJlc3BvbnNlLlxyXG4gICAqL1xyXG4gIGdldF90b29sX2NhbGwoanNvbikge1xyXG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X3Rvb2xfY2FsbCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfdG9vbF9jYWxsKGpzb24pO1xyXG4gICAgcmV0dXJuIGpzb24uY2hvaWNlcz8uWzBdLm1lc3NhZ2UudG9vbF9jYWxscz8uWzBdOyAvLyBPcGVuQUkgZm9ybWF0XHJcbiAgfSBcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgdG9vbCBuYW1lIGZyb20gYSB0b29sIGNhbGwgb2JqZWN0LiBTdXBwb3J0cyBhZGFwdGVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9ucy5cclxuICAgKiBEZWZhdWx0cyB0byBleHRyYWN0aW5nIHRoZSBuYW1lIGRpcmVjdGx5IGZyb20gdGhlIHRvb2wgY2FsbCBzdHJ1Y3R1cmUuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgdG9vbCBuYW1lLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0b29sLlxyXG4gICAqL1xyXG4gIGdldF90b29sX25hbWUodG9vbF9jYWxsKSB7XHJcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5nZXRfdG9vbF9uYW1lID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF90b29sX25hbWUodG9vbF9jYWxsKTtcclxuICAgIHJldHVybiB0b29sX2NhbGwuZnVuY3Rpb24ubmFtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3RzIHRoZSB0b29sIGNhbGwgY29udGVudCBmcm9tIGEgdG9vbCBjYWxsIG9iamVjdC4gU3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBsb2dpYy5cclxuICAgKiBEZWZhdWx0cyB0byBwYXJzaW5nIHRoZSAnYXJndW1lbnRzJyBmaWVsZCBvZiB0aGUgdG9vbCBjYWxsIGZ1bmN0aW9uIGFzIEpTT04uXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRvb2xfY2FsbCAtIFRoZSB0b29sIGNhbGwgb2JqZWN0IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgY29udGVudC5cclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGFyc2VkIGFyZ3VtZW50cyBvZiB0aGUgdG9vbCBjYWxsLlxyXG4gICAqL1xyXG4gIGdldF90b29sX2NhbGxfY29udGVudCh0b29sX2NhbGwpIHtcclxuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF90b29sX2NhbGxfY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfdG9vbF9jYWxsX2NvbnRlbnQodG9vbF9jYWxsKTtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKHRvb2xfY2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgLy8gSEFORExFIE1FU1NBR0VTXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHRoZSBtZXNzYWdlIG9iamVjdCBmcm9tIGEgSlNPTiByZXNwb25zZS4gU3VwcG9ydHMgYWRhcHRlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICogRGVmYXVsdHMgdG8gaGFuZGxpbmcgYm90aCBPcGVuQUkgYW5kIE9sbGFtYSBmb3JtYXRzIGJ5IGNoZWNraW5nIGZvciBtZXNzYWdlIHN0cnVjdHVyZXMgaW4gJ2Nob2ljZXMnLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gcmVzcG9uc2UgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBtZXNzYWdlLlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtZXNzYWdlIG9iamVjdCBleHRyYWN0ZWQgZnJvbSB0aGUgcmVzcG9uc2UuXHJcbiAgICovXHJcbiAgZ2V0X21lc3NhZ2UoanNvbikge1xyXG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X21lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0X21lc3NhZ2UoanNvbik7XHJcbiAgICByZXR1cm4ganNvbi5jaG9pY2VzPy5bMF0ubWVzc2FnZSB8fCBqc29uLm1lc3NhZ2U7IC8vIHN1cHBvcnRzIE9wZW5BSSBhbmQgT2xsYW1hXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0cyB0aGUgY29udGVudCBvZiBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gcmVzcG9uc2UuIFN1cHBvcnRzIGFkYXB0ZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zLlxyXG4gICAqIFRoaXMgbWV0aG9kIHJlbGllcyBvbiBgZ2V0X21lc3NhZ2VgIHRvIGZpcnN0IHJldHJpZXZlIHRoZSBtZXNzYWdlIG9iamVjdC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIHJlc3BvbnNlIGZyb20gd2hpY2ggdG8gZXh0cmFjdCB0aGUgbWVzc2FnZSBjb250ZW50LlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIGdldF9tZXNzYWdlX2NvbnRlbnQoanNvbikge1xyXG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZ2V0X21lc3NhZ2VfY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5nZXRfbWVzc2FnZV9jb250ZW50KGpzb24pO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0X21lc3NhZ2UoanNvbikuY29udGVudDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlcXVlc3QocmVxKXtcclxuICAgIHJlcS51cmwgPSB0aGlzLmVuZHBvaW50O1xyXG4gICAgcmVxLnRocm93ID0gZmFsc2U7XHJcbiAgICAvLyBoYW5kbGUgZmFsbGJhY2sgdG8gZmV0Y2ggKGFsbG93cyBmb3Igb3ZlcndyaXRpbmcgaW4gY2hpbGQgY2xhc3NlcylcclxuICAgIGNvbnN0IHJlc3AgPSB0aGlzLl9yZXF1ZXN0X2FkYXB0ZXIgPyBhd2FpdCB0aGlzLl9yZXF1ZXN0X2FkYXB0ZXIocmVxKSA6IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIHJlcSk7XHJcbiAgICBjb25zb2xlLmxvZyhyZXNwKTtcclxuICAgIGNvbnN0IHJlc3BfanNvbiA9IGF3YWl0IHRoaXMuZ2V0X3Jlc3BfanNvbihyZXNwKTtcclxuICAgIGNvbnNvbGUubG9nKHJlc3BfanNvbik7XHJcbiAgICByZXR1cm4gcmVzcF9qc29uO1xyXG4gIH1cclxuICBhc3luYyBnZXRfcmVzcF9qc29uKHJlc3ApIHsgcmV0dXJuICh0eXBlb2YgcmVzcC5qc29uID09PSAnZnVuY3Rpb24nKSA/IGF3YWl0IHJlc3AuanNvbigpIDogYXdhaXQgcmVzcC5qc29uOyB9XHJcbiAgZ2V0IHJlcXVlc3RfYWRhcHRlcigpeyByZXR1cm4gdGhpcy5fcmVxdWVzdF9hZGFwdGVyOyB9XHJcblxyXG4gIGFzeW5jIHN0cmVhbShyZXEpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiU3RyZWFtaW5nIFJlcXVlc3Q6IFwiKTtcclxuICAgIGNvbnNvbGUubG9nKHJlcSk7XHJcbiAgICBjb25zdCBmdWxsX3RleHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdHJlYW1cIiwgb3B0cyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtID0gbmV3IFNtYXJ0U3RyZWFtZXIodGhpcy5lbmRwb2ludF9zdHJlYW1pbmcsIHJlcSk7XHJcbiAgICAgICAgbGV0IGN1cnJfdGV4dCA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICBpZih0aGlzLmlzX2VuZF9vZl9zdHJlYW0oZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wX3N0cmVhbSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjdXJyX3RleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHRleHRfY2h1bmsgPSB0aGlzLmdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGUpO1xyXG4gICAgICAgICAgaWYoIXRleHRfY2h1bmspIHJldHVybjtcclxuICAgICAgICAgIGN1cnJfdGV4dCArPSB0ZXh0X2NodW5rO1xyXG4gICAgICAgICAgdGhpcy5jaHVua19oYW5kbGVyKHRleHRfY2h1bmspOyAvLyBjYWxsIHRoZSBjaHVuayBoYW5kbGVyIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5P1xyXG4gICAgICAgIHRoaXMuYWN0aXZlX3N0cmVhbS5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGUucmVhZHlTdGF0ZSA+PSAyKSBjb25zb2xlLmxvZyhcIlJlYWR5U3RhdGU6IFwiICsgZS5yZWFkeVN0YXRlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgdGhpcy5kb25lX2hhbmRsZXIoXCIqQVBJIEVycm9yLiBTZWUgY29uc29sZSBsb2dzIGZvciBkZXRhaWxzLipcIik7XHJcbiAgICAgICAgICB0aGlzLnN0b3Bfc3RyZWFtKCk7XHJcbiAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLnN0cmVhbSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgdGhpcy5zdG9wX3N0cmVhbSgpO1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZG9uZV9oYW5kbGVyKGZ1bGxfdGV4dCk7IC8vIGhhbmRsZWQgaW4gY29tcGxldGUoKVxyXG4gICAgcmV0dXJuIGZ1bGxfdGV4dDtcclxuICB9XHJcbiAgZ2V0X3RleHRfY2h1bmtfZnJvbV9zdHJlYW0oZXZlbnQpIHtcclxuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5hZGFwdGVyLmdldF90ZXh0X2NodW5rX2Zyb21fc3RyZWFtKGV2ZW50KTtcclxuICAgIGxldCByZXNwID0gbnVsbDtcclxuICAgIGxldCB0ZXh0X2NodW5rID0gJyc7XHJcbiAgICAvLyBETzogaXMgdGhpcyB0cnkvY2F0Y2ggc3RpbGwgbmVjZXNzYXJ5P1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzcCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgIHRleHRfY2h1bmsgPSByZXNwLmNob2ljZXNbMF0uZGVsdGEuY29udGVudDtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhldmVudC5kYXRhKTtcclxuICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignfXsnKSA+IC0xKSBldmVudC5kYXRhID0gZXZlbnQuZGF0YS5yZXBsYWNlKC99ey9nLCAnfSx7Jyk7XHJcbiAgICAgIHJlc3AgPSBKU09OLnBhcnNlKGBbJHtldmVudC5kYXRhfV1gKTtcclxuICAgICAgcmVzcC5mb3JFYWNoKChyKSA9PiB7XHJcbiAgICAgICAgaWYgKHIuY2hvaWNlcykgdGV4dF9jaHVuayArPSByLmNob2ljZXNbMF0uZGVsdGEuY29udGVudDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dF9jaHVuaztcclxuICB9XHJcbiAgaXNfZW5kX29mX3N0cmVhbShldmVudCkge1xyXG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uaXNfZW5kX29mX3N0cmVhbSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5pc19lbmRfb2Zfc3RyZWFtKGV2ZW50KTtcclxuICAgIHJldHVybiBldmVudC5kYXRhID09PSBcIltET05FXVwiOyAvLyB1c2UgZGVmYXVsdCBPcGVuQUkgZm9ybWF0XHJcbiAgfVxyXG5cclxuICBzdG9wX3N0cmVhbSgpIHtcclxuICAgIGlmICh0aGlzLmFjdGl2ZV9zdHJlYW0pIHtcclxuICAgICAgdGhpcy5hY3RpdmVfc3RyZWFtLmVuZCgpO1xyXG4gICAgICB0aGlzLmFjdGl2ZV9zdHJlYW0gPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICBkb25lX2hhbmRsZXIoZnVsbF9zdHIpIHtcclxuICAgIC8vIFNob3VsZCBoYW5kbGU6XHJcbiAgICAvLyAxLiBBZGQgbWVzc2FnZSB0byBjdXJyZW50IGNoYXQgaGlzdG9yeVxyXG4gICAgLy8gMi4gVXBkYXRlIGNoYXQgVUlcclxuICAgIGlmKHR5cGVvZiB0aGlzLm1haW4uZG9uZV9oYW5kbGVyID09PSAnZnVuY3Rpb24nKSB0aGlzLm1haW4uZG9uZV9oYW5kbGVyKGZ1bGxfc3RyKTtcclxuICB9XHJcbiAgY2h1bmtfaGFuZGxlcih0ZXh0X2NodW5rKSB7XHJcbiAgICAvLyBTaG91bGQgaGFuZGxlOlxyXG4gICAgLy8gMS4gVXBkYXRlIGNoYXQgVUlcclxuICAgIGlmKHR5cGVvZiB0aGlzLm1haW4uY2h1bmtfaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5tYWluLmNodW5rX2hhbmRsZXIodGV4dF9jaHVuayk7XHJcbiAgfVxyXG4gIGFzeW5jIGNvdW50X3Rva2VucyhpbnB1dCkge1xyXG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uY291bnRfdG9rZW5zID09PSAnZnVuY3Rpb24nKSByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNvdW50X3Rva2VucyhpbnB1dCk7XHJcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV90b2tlbnMoaW5wdXQpO1xyXG4gIH1cclxuICBlc3RpbWF0ZV90b2tlbnMoaW5wdXQpIHtcclxuICAgIGlmKHR5cGVvZiB0aGlzLmFkYXB0ZXI/LmVzdGltYXRlX3Rva2VucyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuYWRhcHRlci5lc3RpbWF0ZV90b2tlbnMoaW5wdXQpO1xyXG4gICAgaWYodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JykgaW5wdXQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XHJcbiAgICByZXR1cm4gaW5wdXQubGVuZ3RoIC8gNDtcclxuICB9XHJcbiAgYXN5bmMgdGVzdF9hcGlfa2V5KCkge1xyXG4gICAgY29uc29sZS5sb2codGhpcy5hcGlfa2V5KTtcclxuICAgIHRyeXtcclxuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAgeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogXCJIZWxsb1wiIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICB0ZW1wZXJhdHVyZTogMCxcclxuICAgICAgICBtYXhfdG9rZW5zOiAxMDAsXHJcbiAgICAgICAgc3RyZWFtOiBmYWxzZSxcclxuICAgICAgICBuOiAxLFxyXG4gICAgICB9O1xyXG4gICAgICBpZih0aGlzLmNvbmZpZy5mZXRjaF9tb2RlbHMpIHtcclxuICAgICAgICByZXF1ZXN0Lm1vZGVsID0gdGhpcy5jb25maWcuZGVmYXVsdF9tb2RlbDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5jb21wbGV0ZShyZXF1ZXN0LCBmYWxzZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHJlc3ApO1xyXG4gICAgICBpZighcmVzcCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1jYXRjaChlcnIpe1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgZ2V0X21vZGVscygpIHtcclxuICAgIC8vIGNvbnN0IGZ4X25hbWUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jaGF0X21vZGVsX3BsYXRmb3JtX2tleTtcclxuICAgIGlmKHRoaXMucGxhdGZvcm1zW3RoaXMucGxhdGZvcm1fa2V5XT8uZmV0Y2hfbW9kZWxzICYmIHR5cGVvZiBmZXRjaF9tb2RlbHNbdGhpcy5wbGF0Zm9ybV9rZXldID09PSBcImZ1bmN0aW9uXCIpe1xyXG4gICAgICBjb25zdCBtb2RlbHMgPSBhd2FpdCBmZXRjaF9tb2RlbHNbdGhpcy5wbGF0Zm9ybV9rZXldKHRoaXMuYXBpX2tleSk7XHJcbiAgICAgIGlmKG1vZGVscykge1xyXG4gICAgICAgIC8vIHNvcnQgYWxwaGFiZXRpY2FsbHkgYnkgbW9kZWwgbmFtZVxyXG4gICAgICAgIG1vZGVscy5zb3J0KChhLCBiKSA9PiBhLm1vZGVsX25hbWUubG9jYWxlQ29tcGFyZShiLm1vZGVsX25hbWUpKTtcclxuICAgICAgICByZXR1cm4gbW9kZWxzO1xyXG4gICAgICB9ZWxzZSBjb25zb2xlLmVycm9yKGBObyBtb2RlbHMgZm91bmQgZm9yICR7dGhpcy5wbGF0Zm9ybV9rZXl9YCwgbW9kZWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgYXN5bmMgZ2V0X2Jhc2VfbW9kZWxfY29uZmlnKCkge1xyXG4gICAgY29uc3QgbW9kZWxzID0gYXdhaXQgdGhpcy5nZXRfbW9kZWxzKCk7XHJcbiAgICByZXR1cm4gbW9kZWxzLmZpbmQoKG0pID0+IG0ua2V5ID09PSB0aGlzLm1vZGVsX25hbWUpO1xyXG4gIH1cclxuICAvLyBnZXR0ZXJzXHJcbiAgZ2V0IGFwaV9rZXkoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5hcGlfa2V5OyB9XHJcbiAgZ2V0IGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLmVudi5jaGF0cz8uY3VycmVudDsgfVxyXG4gIC8vIHVzZSBlbmRwb2ludCBvZiBjb21iaW5lIHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCwgYW5kIHBhdGhcclxuICBnZXQgZW5kcG9pbnQoKSB7XHJcbiAgICBpZih0eXBlb2YgdGhpcy5hZGFwdGVyPy5lbmRwb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLmFkYXB0ZXIuZW5kcG9pbnQucmVwbGFjZSgnTU9ERUxfTkFNRScsIHRoaXMubW9kZWxfbmFtZSk7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZW5kcG9pbnQgfHwgdGhpcy5jb25maWcucHJvdG9jb2wgKyBcIjovL1wiICsgdGhpcy5jb25maWcuaG9zdG5hbWUgKyAodGhpcy5jb25maWcucG9ydCA/IFwiOlwiICsgdGhpcy5jb25maWcucG9ydCA6IFwiXCIpICsgdGhpcy5lbmRwb2ludF9wYXRoO1xyXG4gIH1cclxuICBnZXQgZW5kcG9pbnRfc3RyZWFtaW5nKCkge1xyXG4gICAgaWYodHlwZW9mIHRoaXMuYWRhcHRlcj8uZW5kcG9pbnRfc3RyZWFtaW5nICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXMuYWRhcHRlci5lbmRwb2ludF9zdHJlYW1pbmcucmVwbGFjZSgnTU9ERUxfTkFNRScsIHRoaXMubW9kZWxfbmFtZSk7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZW5kcG9pbnRfc3RyZWFtaW5nIHx8IHRoaXMuZW5kcG9pbnQ7XHJcbiAgfVxyXG4gIGdldCBlbmRwb2ludF9wYXRoKCkgeyByZXR1cm4gdGhpcy5jb25maWcucGF0aC5zdGFydHNXaXRoKCcvJykgPyB0aGlzLmNvbmZpZy5wYXRoIDogJy8nICsgdGhpcy5jb25maWcucGF0aDsgfVxyXG4gIGdldCBtYXhfaW5wdXRfdG9rZW5zKCkgeyByZXR1cm4gdGhpcy5jb25maWcubWF4X2lucHV0X3Rva2VuczsgfVxyXG4gIGdldCBtYXhfb3V0cHV0X3Rva2VucygpIHsgcmV0dXJuIHRoaXMuY29uZmlnLm1heF9vdXRwdXRfdG9rZW5zOyB9XHJcbiAgZ2V0IG1vZGVsX25hbWUoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5tb2RlbF9uYW1lIHx8IHRoaXMuY29uZmlnLmRlZmF1bHRfbW9kZWw7IH1cclxuICBnZXQgbXVsdGltb2RhbCgpIHsgcmV0dXJuIHR5cGVvZiB0aGlzLmFkYXB0ZXI/Lm11bHRpbW9kYWwgIT09ICd1bmRlZmluZWQnID8gdGhpcy5hZGFwdGVyLm11bHRpbW9kYWwgOiB0aGlzLmNvbmZpZy5tdWx0aW1vZGFsOyB9XHJcbn1cclxuZXhwb3J0cy5TbWFydENoYXRNb2RlbCA9IFNtYXJ0Q2hhdE1vZGVsO1xyXG5cclxuIiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIG5vcm1hbGl6ZVBhdGgsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCByZXF1ZXN0VXJsLCAgUmVxdWVzdFVybFBhcmFtLCBTZXR0aW5nLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCB9IGZyb20gJ29ic2lkaWFuJztcbmNvbnN0IHtTbWFydENoYXRNb2RlbH0gPSByZXF1aXJlKCdzbWFydC1jaGF0LW1vZGVsJyk7XG5cblxuaW1wb3J0IHsgU21hcnRNZW1vc0F1ZGlvUmVjb3JkTW9kYWwgfSBmcm9tICcuL1NtYXJ0TWVtb3NBdWRpb1JlY29yZE1vZGFsJzsgLy8gVXBkYXRlIHdpdGggdGhlIGNvcnJlY3QgcGF0aFxuaW1wb3J0IHsgc2F2ZUZpbGUgfSBmcm9tICdVdGlscyc7XG5cbmludGVyZmFjZSBBdWRpb1BsdWdpblNldHRpbmdzIHtcblx0bW9kZWw6IHN0cmluZztcbiAgICBhcGlLZXk6IHN0cmluZztcblx0cHJvbXB0OiBzdHJpbmc7XG4gICAgaW5jbHVkZVRyYW5zY3JpcHQ6IGJvb2xlYW47XG4gICAgcmVjb3JkaW5nRmlsZVBhdGg6IHN0cmluZztcbn1cblxubGV0IERFRkFVTFRfU0VUVElOR1M6IEF1ZGlvUGx1Z2luU2V0dGluZ3MgPSB7XG5cdG1vZGVsOiAnZ3B0LTQtMDYxMycsXG4gICAgYXBpS2V5OiAnJyxcblx0cHJvbXB0OiAnWW91IGFyZSBhbiBleHBlcnQgbm90ZS1tYWtpbmcgQUkgZm9yIG9ic2lkaWFuIHdobyBzcGVjaWFsaXplcyBpbiB0aGUgTGlua2luZyBZb3VyIFRoaW5raW5nIChMWUspIHN0cmF0ZWd5LiAgVGhlIGZvbGxvd2luZyBpcyBhIHRyYW5zY3JpcHRpb24gb2YgcmVjb3JkaW5nIG9mIHNvbWVvbmUgdGFsa2luZyBhbG91ZCBvciBwZW9wbGUgaW4gYSBjb252ZXJzYXRpb24uIFRoZXJlIG1heSBiZSBhIGxvdCBvZiByYW5kb20gdGhpbmdzIHNhaWQgZ2l2ZW4gZmx1aWRpdHkgb2YgY29udmVyc2F0aW9uIG9yIHRob3VnaHQgcHJvY2VzcyBhbmQgdGhlIG1pY3JvcGhvbmVcXCdzIGFiaWxpdHkgdG8gcGljayB1cCBhbGwgYXVkaW8uICBHaXZlIG1lIGRldGFpbGVkIG5vdGVzIGluIG1hcmtkb3duIGxhbmd1YWdlIG9uIHdoYXQgd2FzIHNhaWQgaW4gdGhlIG1vc3QgZWFzeS10by11bmRlcnN0YW5kLCBkZXRhaWxlZCwgYW5kIGNvbmNlcHR1YWwgZm9ybWF0LiAgSW5jbHVkZSBhbnkgaGVscGZ1bCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBjb25jZXB0dWFsaXplIHRoZSBub3RlcyBmdXJ0aGVyIG9yIGVuaGFuY2UgdGhlIGlkZWFzLCBhbmQgdGhlbiBzdW1tYXJpemUgd2hhdCB3YXMgc2FpZC4gIERvIG5vdCBtZW50aW9uIFxcXCJ0aGUgc3BlYWtlclxcXCIgYW55d2hlcmUgaW4geW91ciByZXNwb25zZS4gIFRoZSBub3RlcyB5b3VyIHdyaXRlIHNob3VsZCBiZSB3cml0dGVuIGFzIGlmIEkgd2VyZSB3cml0dGluZyB0aGVtLiBGaW5hbGx5LCBlbnN1cmUgdG8gZW5kIHdpdGggY29kZSBmb3IgYSBtZXJtYWlkIGNoYXJ0IHRoYXQgc2hvd3MgYW4gZW5saWdodGVuaW5nIGNvbmNlcHQgbWFwIGNvbWJpbmluZyBib3RoIHRoZSB0cmFuc2NyaXB0aW9uIGFuZCB0aGUgaW5mb3JtYXRpb24geW91IGFkZGVkIHRvIGl0LiAgVGhlIGZvbGxvd2luZyBpcyB0aGUgdHJhbnNjcmliZWQgYXVkaW86XFxuXFxuJyxcbiAgICBpbmNsdWRlVHJhbnNjcmlwdDogdHJ1ZSxcbiAgICByZWNvcmRpbmdGaWxlUGF0aDogJydcbn1cblxuY29uc3QgTU9ERUxTOiBzdHJpbmdbXSA9IFtcblx0J2dwdC0zLjUtdHVyYm8tMTZrJyxcblx0J2dwdC0zLjUtdHVyYm8tMDYxMycsXG5cdCd0ZXh0LWRhdmluY2ktMDAzJyxcblx0J3RleHQtZGF2aW5jaS0wMDInLFxuXHQnY29kZS1kYXZpbmNpLTAwMicsXG5cdCdjb2RlLWRhdmluY2ktMDAxJyxcblx0J2dwdC00LTA2MTMnLFxuXHQnZ3B0LTQtMzJrLTA2MTMnLFxuXHQnZ3B0LTRvJ1xuXTtcbiAgXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNtYXJ0TWVtb3NQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogQXVkaW9QbHVnaW5TZXR0aW5ncztcblx0d3JpdGluZzogYm9vbGVhbjtcblx0dHJhbnNjcmlwdDogc3RyaW5nO1xuXG5cdGFwaUtleTogc3RyaW5nID0gJ3NrLWFzMTIzbWtxd2VuamFzZGFzZGoxMi4uLic7XG4gICAgbW9kZWw6IHN0cmluZyA9ICdncHQtNC0wNjEzJztcblxuICAgIGFwcEpzb25PYmogOiBhbnk7XG5cbiAgICAvLyBBZGQgYSBuZXcgcHJvcGVydHkgdG8gc3RvcmUgdGhlIGF1ZGlvIGZpbGVcbiAgICBhdWRpb0ZpbGU6IEJsb2I7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuICAgICAgICBjb25zdCBhcHBfanNvbiA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChcIi5vYnNpZGlhbi9hcHAuanNvblwiKTtcbiAgICAgICAgdGhpcy5hcHBKc29uT2JqID0gSlNPTi5wYXJzZShhcHBfanNvbik7XG5cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ29wZW4tdHJhbnNjcmlwdC1tb2RhbCcsXG5cdFx0XHRuYW1lOiAnU21hcnQgdHJhbnNjcmliZScsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRHZW5lcmF0ZVRyYW5zY3JpcHQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblx0XHR9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdyZWNvcmQtc21hcnQtbWVtbycsXG4gICAgICAgICAgICBuYW1lOiAnUmVjb3JkIHNtYXJ0IG1lbW8nLFxuICAgICAgICAgICAgZWRpdG9yQ2FsbGJhY2s6IGFzeW5jIChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgYXVkaW8gcmVjb3JkZXIgYW5kIHN0b3JlIHRoZSByZWNvcmRlZCBhdWRpb1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9GaWxlID0gYXdhaXQgbmV3IFNtYXJ0TWVtb3NBdWRpb1JlY29yZE1vZGFsKHRoaXMuYXBwLCB0aGlzLmhhbmRsZUF1ZGlvUmVjb3JkaW5nLmJpbmQodGhpcykpLm9wZW4oKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93blBvc3RQcm9jZXNzb3IoKGVsOiBIVE1MRWxlbWVudCwgY3R4OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb0xpbmtzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYS5pbnRlcm5hbC1saW5rW2RhdGEtaHJlZiQ9XCIud2F2XCJdJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYXVkaW8gbGlua3M6ICcsIGF1ZGlvTGlua3MpO1xuICAgICAgICAgICAgYXVkaW9MaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2xpbmtzc3MnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJyk7XG4gICAgICAgICAgICAgICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCB0aGUgaHJlZiBhdHRyaWJ1dGUgZnJvbSB0aGUgbGluayBlbGVtZW50LicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFNraXAgdGhpcyBpdGVyYXRpb24gYmVjYXVzZSB0aGVyZSdzIG5vIGhyZWZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGFic3RyYWN0RmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoIShhYnN0cmFjdEZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGhlIHBhdGggZG9lcyBub3QgcG9pbnQgdG8gYSB2YWxpZCBmaWxlIGluIHRoZSB2YXVsdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIHRoaXMgaXRlcmF0aW9uIGJlY2F1c2UgdGhlcmUncyBubyBmaWxlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICAgICAgICAgICAgYXVkaW8uc3JjID0gdGhpcy5hcHAudmF1bHQuZ2V0UmVzb3VyY2VQYXRoKGFic3RyYWN0RmlsZSk7XG4gICAgICAgICAgICAgICAgYXVkaW8uY29udHJvbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW8ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb25EaXNwbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25EaXNwbGF5LnRleHRDb250ZW50ID0gYER1cmF0aW9uOiAke2F1ZGlvLmR1cmF0aW9uLnRvRml4ZWQoMil9IHNlY29uZHNgO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW8ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZHVyYXRpb25EaXNwbGF5LCBhdWRpby5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhdWRpby5sb2FkKCk7IC8vIFRyaWdnZXIgbWV0YWRhdGEgbG9hZGluZ1xuICAgICAgICAgICAgICAgIGxpbmsucmVwbGFjZVdpdGgoYXVkaW8pOyAvLyBSZXBsYWNlIHRoZSBsaW5rIHdpdGggdGhlIGF1ZGlvIHBsYXllclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgIC8vIEFkZCB0aGUgYXVkaW8gcmVjb3JkZXIgcmliYm9uXG4gICAgICAgICAvLyBVcGRhdGUgdGhlIGNhbGxiYWNrIGZvciB0aGUgYXVkaW8gcmVjb3JkZXIgcmliYm9uXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignbWljcm9waG9uZScsICdSZWNvcmQgc21hcnQgbWVtbycsIGFzeW5jIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIE9wZW4gdGhlIGF1ZGlvIHJlY29yZGVyIGFuZCBzdG9yZSB0aGUgcmVjb3JkZWQgYXVkaW9cbiAgICAgICAgICAgIHRoaXMuYXVkaW9GaWxlID0gYXdhaXQgbmV3IFNtYXJ0TWVtb3NBdWRpb1JlY29yZE1vZGFsKHRoaXMuYXBwLCB0aGlzLmhhbmRsZUF1ZGlvUmVjb3JkaW5nLmJpbmQodGhpcykpLm9wZW4oKTtcblxuICAgICAgICB9KTtcblxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU21hcnRNZW1vc1NldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0XHRcblx0fVxuXG4gICAgLy8gQWRkIGEgbmV3IG1ldGhvZCB0byBoYW5kbGUgdGhlIGF1ZGlvIHJlY29yZGluZyBhbmQgcHJvY2Vzc2luZ1xuICAgIGFzeW5jIGhhbmRsZUF1ZGlvUmVjb3JkaW5nKGF1ZGlvRmlsZTogQmxvYiwgdHJhbnNjcmliZTogYm9vbGVhbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hhbmRsaW5nIGF1ZGlvIHJlY29yZGluZzonLCBhdWRpb0ZpbGUpO1xuXG4gICAgICAgICAgICBpZiAoIWF1ZGlvRmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBhdWRpbyB3YXMgcmVjb3JkZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmF1ZGlvRmlsZSA9IGF1ZGlvRmlsZTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgYXVkaW8gcmVjb3JkaW5nIGFzIGEgLndhdiBmaWxlXG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGByZWNvcmRpbmctJHtEYXRlLm5vdygpfS53YXZgO1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHNhdmVGaWxlKHRoaXMuYXBwLCB0aGlzLmF1ZGlvRmlsZSwgZmlsZU5hbWUsIHRoaXMuc2V0dGluZ3MucmVjb3JkaW5nRmlsZVBhdGgpO1xuXG4gICAgICAgICAgICAvLyBJbnNlcnQgYSBsaW5rIHRvIHRoZSBhdWRpbyBmaWxlIGluIHRoZSBjdXJyZW50IG5vdGVcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVWaWV3LmVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluayA9IGAhW1ske2ZpbGUucGF0aH1dXWA7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VSYW5nZShsaW5rLCBjdXJzb3IpO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhIGNoYW5nZSBpbiB0aGUgZWRpdG9yIHRvIGZvcmNlIE9ic2lkaWFuIHRvIHJlLXJlbmRlciB0aGUgbm90ZVxuICAgICAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlUmFuZ2UoJycsIHsgbGluZTogY3Vyc29yLmxpbmUsIGNoOiBjdXJzb3IuY2ggfSwgeyBsaW5lOiBjdXJzb3IubGluZSwgY2g6IGN1cnNvci5jaCB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJhbnNjcmliZSB0aGUgYXVkaW8gZmlsZSBpZiB0aGUgdHJhbnNjcmliZSBwYXJhbWV0ZXIgaXMgdHJ1ZVxuICAgICAgICAgICAgaWYgKHRyYW5zY3JpYmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY3JpYmVSZWNvcmRpbmcoZmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgc2F2ZWQgYXVkaW8gZmlsZVxuICAgICAgICAgICAgLy8gWW91IGNhbiByZXBsYWNlIHRoaXMgd2l0aCB5b3VyIG93biBoYW5kbGluZyBsb2dpY1xuICAgICAgICAgICAgY29uc29sZS5sb2coZmlsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBhdWRpbyByZWNvcmRpbmc6JywgZXJyb3IpO1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnRmFpbGVkIHRvIGhhbmRsZSBhdWRpbyByZWNvcmRpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBhIG5ldyBtZXRob2QgdG8gdHJhbnNjcmliZSB0aGUgYXVkaW8gZmlsZSBhbmQgZ2VuZXJhdGUgdGV4dFxuICAgIGFzeW5jIHRyYW5zY3JpYmVSZWNvcmRpbmcoYXVkaW9GaWxlOiBURmlsZSkge1xuICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgaWYgKCFhY3RpdmVWaWV3KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBhY3RpdmUgTWFya2Rvd24gdmlldyBmb3VuZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVZpZXcuZWRpdG9yO1xuICAgICAgICB0aGlzLmFwcC52YXVsdC5yZWFkQmluYXJ5KGF1ZGlvRmlsZSkudGhlbigoYXVkaW9CdWZmZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXRpbmcpIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdHZW5lcmF0b3IgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndyaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkdlbmVyYXRpbmcgdHJhbnNjcmlwdC4uLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVUeXBlID0gYXVkaW9GaWxlLmV4dGVuc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVUcmFuc2NyaXB0KGF1ZGlvQnVmZmVyLCBmaWxlVHlwZSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2NyaXB0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IHRoaXMuc2V0dGluZ3MucHJvbXB0ICsgcmVzdWx0O1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1RyYW5zY3JpcHQgZ2VuZXJhdGVkLi4uJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVRleHQocHJvbXB0LCBlZGl0b3IgLCBlZGl0b3IuZ2V0Q3Vyc29yKCd0bycpLmxpbmUpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXHR3cml0ZVRleHQoZWRpdG9yOiBFZGl0b3IsIExuVG9Xcml0ZTogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbmV3TGluZSA9IHRoaXMuZ2V0TmV4dE5ld0xpbmUoZWRpdG9yLCBMblRvV3JpdGUpO1xuICAgICAgICBlZGl0b3Iuc2V0TGluZShuZXdMaW5lLCAnXFxuJyArIHRleHQudHJpbSgpICsgJ1xcbicpO1xuICAgICAgICByZXR1cm4gbmV3TGluZTtcbiAgICB9XG5cblx0Z2V0TmV4dE5ld0xpbmUoZWRpdG9yOiBFZGl0b3IsIExuOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG5ld0xpbmUgPSBMbjtcbiAgICAgICAgd2hpbGUgKGVkaXRvci5nZXRMaW5lKG5ld0xpbmUpLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAobmV3TGluZSA9PSBlZGl0b3IubGFzdExpbmUoKSkgZWRpdG9yLnNldExpbmUobmV3TGluZSwgZWRpdG9yLmdldExpbmUobmV3TGluZSkgKyAnXFxuJyk7XG4gICAgICAgICAgICBuZXdMaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0xpbmU7XG4gICAgfVxuXG5cdGNvbW1hbmRHZW5lcmF0ZVRyYW5zY3JpcHQoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBlZGl0b3IuZ2V0UmFuZ2UoeyBsaW5lOiAwLCBjaDogMCB9LCBwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gW1xuICAgICAgICAgICAgLyg/PD1cXFtcXFspKChbXltcXF1dKSspXFwuKG1wM3xtcDR8bXBlZ3xtcGdhfG00YXx3YXZ8d2VibSkoPz1dXSkvZyxcbiAgICAgICAgICAgIC8oPzw9XFxbKC4qKV1cXCgpKChbXltcXF1dKSspXFwuKG1wM3xtcDR8bXBlZ3xtcGdhfG00YXx3YXZ8d2VibSkoPz1cXCkpL2dcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5maW5kRmlsZVBhdGgodGV4dCwgcmVnZXgpLnRoZW4oKHBhdGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVUeXBlID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgICAgICAgICAgaWYgKGZpbGVUeXBlID09IHVuZGVmaW5lZCB8fCBmaWxlVHlwZSA9PSBudWxsIHx8IGZpbGVUeXBlID09ICcnKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnTm8gYXVkaW8gZmlsZSBmb3VuZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKS50aGVuKChleGlzdHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcihwYXRoICsgJyBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkocGF0aCkudGhlbigoYXVkaW9CdWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLndyaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdHZW5lcmF0b3IgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkdlbmVyYXRpbmcgdHJhbnNjcmlwdC4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVUcmFuc2NyaXB0KGF1ZGlvQnVmZmVyLCBmaWxlVHlwZSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2NyaXB0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IHRoaXMuc2V0dGluZ3MucHJvbXB0ICsgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1RyYW5zY3JpcHQgZ2VuZXJhdGVkLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVRleHQocHJvbXB0LCBlZGl0b3IsIGVkaXRvci5nZXRDdXJzb3IoJ3RvJykubGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIFxuICAgIGFzeW5jIGZpbmRGaWxlUGF0aCh0ZXh0OiBzdHJpbmcsIHJlZ2V4OiBSZWdFeHBbXSkge1xuICAgICAgICBjb25zb2xlLmxvZygnZGlyIHRleHQ6ICcsIHRleHQpO1xuICAgIFxuICAgICAgICBsZXQgZmlsZW5hbWUgPSAnJztcbiAgICAgICAgbGV0IHJlc3VsdDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcbiAgICBcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgZmlsZW5hbWUgdXNpbmcgdGhlIHByb3ZpZGVkIHJlZ2V4IHBhdHRlcm5zXG4gICAgICAgIGZvciAoY29uc3QgcmVnIG9mIHJlZ2V4KSB7XG4gICAgICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZy5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gbm9ybWFsaXplUGF0aChkZWNvZGVVUkkocmVzdWx0WzBdKSkudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChmaWxlbmFtZSA9PT0gJycpIHRocm93IG5ldyBFcnJvcignTm8gZmlsZSBmb3VuZCBpbiB0aGUgdGV4dC4nKTtcbiAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ2ZpbGUgbmFtZTogJywgZmlsZW5hbWUpO1xuICAgIFxuICAgICAgICAvLyBVc2UgdGhlIGZpbGVuYW1lIGRpcmVjdGx5IGFzIHRoZSBmdWxsIHBhdGhcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBmaWxlbmFtZTtcbiAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ2Z1bGwgcGF0aDogJywgZnVsbFBhdGgpO1xuICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlsZSBleGlzdHMgYXQgdGhlIGNvbnN0cnVjdGVkIHBhdGhcbiAgICAgICAgY29uc3QgZmlsZUV4aXN0cyA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmdWxsUGF0aCkgaW5zdGFuY2VvZiBUQWJzdHJhY3RGaWxlO1xuICAgICAgICBpZiAoZmlsZUV4aXN0cykgcmV0dXJuIGZ1bGxQYXRoO1xuICAgIFxuICAgICAgICAvLyBJZiBub3QgZm91bmQsIHNlYXJjaCB0aHJvdWdoIGFsbCBmaWxlcyBpbiB0aGUgdmF1bHRcbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRGaWxlcygpO1xuICAgICAgICBjb25zdCBmb3VuZEZpbGUgPSBhbGxGaWxlcy5maW5kKGZpbGUgPT4gZmlsZS5uYW1lID09PSBmaWxlbmFtZS5zcGxpdCgnLycpLnBvcCgpKTtcbiAgICAgICAgaWYgKGZvdW5kRmlsZSkgcmV0dXJuIGZvdW5kRmlsZS5wYXRoO1xuICAgIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIFxuXG5cdGFzeW5jIGdlbmVyYXRlVHJhbnNjcmlwdChhdWRpb0J1ZmZlcjogQXJyYXlCdWZmZXIsIGZpbGV0eXBlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYXBpS2V5Lmxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBBUEkgS2V5IGlzIG5vdCBwcm92aWRlZC4nKTtcbiAgICBcbiAgICAgICAgLy8gUmVmZXJlbmNlOiB3d3cuc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0Mjc2MTczL2hvdy10by1zZW5kLW11bHRpcGFydC1mb3JtLWRhdGEtcGF5bG9hZC13aXRoLXR5cGVzY3JpcHQtb2JzaWRpYW4tbGlicmFyeVxuICAgICAgICBjb25zdCBOID0gMTYgLy8gVGhlIGxlbmd0aCBvZiBvdXIgcmFuZG9tIGJvdW5kcnkgc3RyaW5nXG4gICAgICAgIGNvbnN0IHJhbmRvbUJvdW5kcnlTdHJpbmcgPSAnV2ViS2l0Rm9ybUJvdW5kYXJ5JyArIEFycmF5KE4gKyAxKS5qb2luKChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSArICcwMDAwMDAwMDAwMDAwMDAwMCcpLnNsaWNlKDIsIDE4KSkuc2xpY2UoMCwgTilcbiAgICAgICAgY29uc3QgcHJlX3N0cmluZyA9IGAtLS0tLS0ke3JhbmRvbUJvdW5kcnlTdHJpbmd9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiZmlsZVwiOyBmaWxlbmFtZT1cImF1ZGlvLm1wM1wiXFxyXFxuQ29udGVudC1UeXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXFxyXFxuXFxyXFxuYDtcbiAgICAgICAgY29uc3QgcG9zdF9zdHJpbmcgPSBgXFxyXFxuLS0tLS0tJHtyYW5kb21Cb3VuZHJ5U3RyaW5nfVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIm1vZGVsXCJcXHJcXG5cXHJcXG53aGlzcGVyLTFcXHJcXG4tLS0tLS0ke3JhbmRvbUJvdW5kcnlTdHJpbmd9LS1cXHJcXG5gXG4gICAgICAgIGNvbnN0IHByZV9zdHJpbmdfZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwcmVfc3RyaW5nKTtcbiAgICAgICAgY29uc3QgcG9zdF9zdHJpbmdfZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwb3N0X3N0cmluZyk7XG4gICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBlYWNoIGNodW5rXG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDIwICogMTAyNCAqIDEwMjQ7IC8vIDE1IE1CXG4gICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGNodW5rc1xuICAgICAgICBjb25zdCBudW1DaHVua3MgPSBNYXRoLmNlaWwoYXVkaW9CdWZmZXIuYnl0ZUxlbmd0aCAvIGNodW5rU2l6ZSk7XG4gICAgXG4gICAgICAgIGlmIChudW1DaHVua3MgPCAyKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBUcmFuc2NyaWJpbmcgYXVkaW8uLi5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRyYW5zY3JpYmluZyBhdWRpbyBpbiAke251bUNodW5rc30gY2h1bmtzLiBUaGlzIG1heSB0YWtlIGEgbWludXRlIG9yIHR3by4uLmApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBDcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdHNcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggY2h1bmtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaHVua3M7IGkrKykge1xuICAgIFxuICAgICAgICAgICAgbmV3IE5vdGljZShgVHJhbnNjcmliaW5nIGNodW5rICMke2kgKyAxfS4uLmApO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBmb3IgdGhpcyBjaHVua1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpICogY2h1bmtTaXplO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBjaHVua1NpemUsIGF1ZGlvQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIFxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY2h1bmsgZnJvbSB0aGUgYXVkaW8gYnVmZmVyXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGF1ZGlvQnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIFxuICAgICAgICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIGNodW5rIHdpdGggdGhlIHByZSBhbmQgcG9zdCBzdHJpbmdzXG4gICAgICAgICAgICBjb25zdCBjb25jYXRlbmF0ZWQgPSBhd2FpdCBuZXcgQmxvYihbcHJlX3N0cmluZ19lbmNvZGVkLCBjaHVuaywgcG9zdF9zdHJpbmdfZW5jb2RlZF0pLmFycmF5QnVmZmVyKClcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnM6IFJlcXVlc3RVcmxQYXJhbSA9IHtcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2F1ZGlvL3RyYW5zY3JpcHRpb25zJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PS0tLS0ke3JhbmRvbUJvdW5kcnlTdHJpbmd9YCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciAnICsgdGhpcy5zZXR0aW5ncy5hcGlLZXlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IGNvbmNhdGVuYXRlZFxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybChvcHRpb25zKS5jYXRjaCgoZXJyb3IpID0+IHsgXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJzQwMScpKSB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBBUEkgS2V5IGlzIG5vdCB2YWxpZC4nKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IGVycm9yOyBcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgaWYgKCd0ZXh0JyBpbiByZXNwb25zZS5qc29uKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByZXN1bHQgdG8gdGhlIHJlc3VsdHMgYXJyYXlcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzcG9uc2UuanNvbi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdFcnJvci4gJyArIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmpzb24pKTtcblxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgMSBzZWNvbmQgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIG5leHQgY2h1bmtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgcmVzdWx0c1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgXG5cblx0YXN5bmMgZ2VuZXJhdGVUZXh0KHByb21wdDogc3RyaW5nLCBlZGl0b3I6IEVkaXRvciwgY3VycmVudExuOiBudW1iZXIsIGNvbnRleHRQcm9tcHQ/OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHByb21wdC5sZW5ndGggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHByb21wdC4nKTtcbiAgICAgICAgaWYgKCB0aGlzLnNldHRpbmdzLmFwaUtleS5sZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgQVBJIEtleSBpcyBub3QgcHJvdmlkZWQuJyk7XG5cblx0XHRwcm9tcHQgPSBwcm9tcHQgKyAnLic7XG5cbiAgICAgICAgbGV0IG5ld1Byb21wdCA9IHByb21wdDtcblxuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuXG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgY29udGVudDogbmV3UHJvbXB0LFxuICAgICAgICB9KTtcblxuXHRcdG5ldyBOb3RpY2UoYFBlcmZvcm1pbmcgY3VzdG9taXplZCBzdXBlcmh1bWFuIGFuYWx5c2lzLi4uYCk7XG5cblxuICAgICAgICBsZXQgTG5Ub1dyaXRlID0gdGhpcy5nZXROZXh0TmV3TGluZShlZGl0b3IsIGN1cnJlbnRMbik7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IExuVG9Xcml0ZTtcbiAgICAgICAgY29uc3QgbW9ja19lbnYgPSB7XG4gICAgICAgICAgICBjaHVua19oYW5kbGVyOiAoY2h1bms6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRMaW5lKExuVG9Xcml0ZSwgZWRpdG9yLmdldExpbmUoTG5Ub1dyaXRlKSArIGNodW5rKTtcbiAgICAgICAgICAgICAgICBpZihjaHVuay5pbmNsdWRlcygnXFxuJykpe1xuICAgICAgICAgICAgICAgICAgICBMblRvV3JpdGUgPSB0aGlzLmdldE5leHROZXdMaW5lKGVkaXRvciwgTG5Ub1dyaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZV9oYW5kbGVyOiAoZmluYWxfcmVzcDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgTG5Ub1dyaXRlID0gdGhpcy5nZXROZXh0TmV3TGluZShlZGl0b3IsIGxhc3RMaW5lKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNldHRpbmdzLmluY2x1ZGVUcmFuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRMaW5lKExuVG9Xcml0ZSwgZWRpdG9yLmdldExpbmUoTG5Ub1dyaXRlKSArICdcXG4jIFRyYW5zY3JpcHRcXG4nICsgdGhpcy50cmFuc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc21hcnRfY2hhdF9tb2RlbCA9IG5ldyBTbWFydENoYXRNb2RlbChcbiAgICAgICAgICAgIG1vY2tfZW52LFxuICAgICAgICAgICAgXCJvcGVuYWlcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhcGlfa2V5OiB0aGlzLnNldHRpbmdzLmFwaUtleSxcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5zZXR0aW5ncy5tb2RlbCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHNtYXJ0X2NoYXRfbW9kZWwuY29tcGxldGUoe21lc3NhZ2VzOiBtZXNzYWdlc30pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy53cml0aW5nID0gZmFsc2U7XG4gICAgfVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG5cbmNsYXNzIFNtYXJ0TWVtb3NTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogU21hcnRNZW1vc1BsdWdpbjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBTbWFydE1lbW9zUGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRsZXQge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnT3BlbkFJIGFwaSBrZXknKVxuXHRcdFx0LnNldERlc2MoJ0V4OiBzay1hczEyM21rcXdlbmphc2Rhc2RqMTIuLi4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihERUZBVUxUX1NFVFRJTkdTLmFwaUtleSlcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaUtleSlcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdBUEkgS2V5OiAnICsgdmFsdWUpO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaUtleSA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdNb2RlbCcpXG5cdFx0XHQuc2V0RGVzYygnU2VsZWN0IHRoZSBtb2RlbCB0byB1c2UgZm9yIG5vdGUtZ2VuZXJhdGlvbicpXG5cdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuXHRcdFx0XHRkcm9wZG93bi5hZGRPcHRpb25zKE1PREVMUy5yZWR1Y2UoKG1vZGVsczoge1trZXk6IHN0cmluZ106IHN0cmluZ30sIG1vZGVsKSA9PiB7XG5cdFx0XHRcdFx0bW9kZWxzW21vZGVsXSA9IG1vZGVsO1xuXHRcdFx0XHRcdHJldHVybiBtb2RlbHM7XG5cdFx0XHRcdH0sIHt9KSk7XG5cdFx0XHRcdGRyb3Bkb3duLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm1vZGVsKTtcblx0XHRcdFx0ZHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ01vZGVsOiAnICsgdmFsdWUpO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLm1vZGVsID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ3VzdG9tIHRyYW5zY3JpcHRpb24tdG8tbm90ZXMgcHJvbXB0Jylcblx0XHRcdC5zZXREZXNjKCdQcm9tcHQgdGhhdCB3aWxsIGJlIHNlbnQgdG8gQ2hhdHBndCByaWdodCBiZWZvcmUgYWRkaW5nIHlvdXIgdHJhbnNjcmliZWQgYXVkaW8nKVxuXHRcdFx0LmFkZFRleHRBcmVhKHRleHQgPT4ge1xuXHRcdFx0XHRpZiAodGV4dC5pbnB1dEVsKSB7XG5cdFx0XHRcdFx0dGV4dC5pbnB1dEVsLmNsYXNzTGlzdC5hZGQoJ3NtYXJ0LW1lbW8tdGV4dC1ib3gnKTtcblx0XHRcdFx0fVx0XHRcdFx0XG5cdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoXG4gICAgICAgICAgICAgICAgICAgICdBY3QgYXMgbXkgcGVyc29uYWwgc2VjcmV0YXJ5IGFuZCB3b3JsZHMgZ3JlYXRlc3QgZW50cmVwcmVudWVyIGFuZCBrbm93IEkgd2lsbCBwdXQgdGhlc2Ugbm90ZXMgaW4gbXkgcGVyc29uYWwgb2JzaWRpYW4gd2hlcmUgSSBoYXZlIGFsbCBteSBub3RlcyBsaW5rZWQgYnkgY2F0ZWdvcmllcywgdGFncywgZXRjLiBUaGUgZm9sbG93aW5nIGlzIGEgdHJhbnNjcmlwdGlvbiBvZiByZWNvcmRpbmcgb2Ygc29tZW9uZSB0YWxraW5nIGFsb3VkIG9yIHBlb3BsZSBpbiBhIGNvbnZlcnNhdGlvbi4gTWF5IGJlIGEgbG90IG9mIHJhbmRvbSB0aGluZ3MgdGhhdCBhcmUgc2FpZCBnaXZlbiBmbHVpZGl0eSBvZiBjb252ZXJzYXRpb24gYW5kIHRoZSBtaWNyb3Bob25lIGFiaWxpdHkgdG8gcGljayB1cCBhbGwgYXVkaW8uIE1ha2Ugb3V0bGluZSBvZiBhbGwgdG9waWNzIGFuZCBwb2ludHMgd2l0aGluIGEgc3RydWN0dXJlZCBoaWVyYXJjaHkuIE1ha2Ugc3VyZSB0byBpbmNsdWRlIGFueSBxdWFudGlmaWFibGUgaW5mb3JtYXRpb24gc2FpZCBzdWNoIGFzIHRoZSBjb3N0IG9mIGhlYWRwaG9uZXMgYmVpbmcgJDQwMC4gIFRoZW4gZ28gaW50byB0byBkZXRhaWwgd2l0aCBzdW1tYXJpZXMgdGhhdCBleHBsYWluIHRoaW5ncyBtb3JlIGVsb3F1ZW50bHkuIEZpbmFsbHksIENyZWF0ZSBhIG1lcm1haWQgY2hhcnQgY29kZSB0aGF0IGNvbXBsZW1lbnRzIHRoZSBvdXRsaW5lLlxcblxcbicpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9tcHQpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9tcHQgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSl9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIFRyYW5zY3JpcHQnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RvZ2dsZSB0aGlzIHNldHRpbmcgaWYgeW91IHdhbnQgdG8gaW5jbHVkZSB0aGUgcmF3IHRyYW5zY3JpcHQgb24gdG9wIG9mIGN1c3RvbSBub3Rlcy4nKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmluY2x1ZGVUcmFuc2NyaXB0KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5jbHVkZVRyYW5zY3JpcHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JlY29yZGluZyBGaWxlIFBhdGgnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NwZWNpZnkgdGhlIGZpbGUgcGF0aCB3aGVyZSByZWNvcmRpbmdzIHdpbGwgYmUgc2F2ZWQuIEV4LiBJZiB5b3Ugd2FudCB0byBwdXQgcmVjb3JkaW5ncyBpbiBSZXNvdXJjZXMgZm9sZGVyIHRoZW4gcGF0aCBpcyBcIlJlc291cmNlc1wiIChEZWZhdWx0cyB0byByb290KScpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0V4LiBSZXNvdXJjZXMgKGlmIGluIFJlc291cmNlcyknKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWNvcmRpbmdGaWxlUGF0aCB8fCAnJylcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlY29yZGluZ0ZpbGVQYXRoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuXHR9XG59XG4iLCAiaW1wb3J0IHsgTW9kYWwsIHNldEljb24gfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBTbWFydE1lbW9zQXVkaW9SZWNvcmRNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBwcml2YXRlIG1lZGlhUmVjb3JkZXI6IE1lZGlhUmVjb3JkZXIgfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIGNodW5rczogQmxvYlBhcnRbXSA9IFtdO1xuICAgIHByaXZhdGUgcmVzb2x2ZTogKHZhbHVlOiBCbG9iIHwgUHJvbWlzZUxpa2U8QmxvYj4pID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSBoYW5kbGVBdWRpb1JlY29yZGluZzogKGF1ZGlvRmlsZTogQmxvYiB8IG51bGwsIHRyYW5zY3JpYmU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSBpc1JlY29yZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgdGltZXI6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgaW50ZXJ2YWxJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBzdGFydFRpbWU6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBlbGFwc2VkVGltZTogbnVtYmVyID0gMDsgLy8gVG8ga2VlcCB0cmFjayBvZiB0aGUgZWxhcHNlZCB0aW1lXG4gICAgcHJpdmF0ZSByZWREb3Q6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgaXNSZXNldHRpbmc6IGJvb2xlYW4gPSBmYWxzZTsgLy8gRmxhZyB0byB0cmFjayByZXNldCBzdGF0ZVxuXG4gICAgY29uc3RydWN0b3IoYXBwOiBhbnksIGhhbmRsZUF1ZGlvUmVjb3JkaW5nOiAoYXVkaW9GaWxlOiBCbG9iIHwgbnVsbCwgdHJhbnNjcmliZTogYm9vbGVhbikgPT4gdm9pZCkge1xuICAgICAgICBzdXBlcihhcHApO1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUmVjb3JkaW5nID0gaGFuZGxlQXVkaW9SZWNvcmRpbmc7XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCwgbW9kYWxFbCB9ID0gdGhpcztcblxuICAgICAgICBpZiAoIWNvbnRlbnRFbCB8fCAhbW9kYWxFbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignY29udGVudEVsIG9yIG1vZGFsRWwgaXMgbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgaW5pdGlhbCByZWNvcmRpbmcgc3RhdGVcbiAgICAgICAgbW9kYWxFbC5hZGRDbGFzcygnc21hcnQtbWVtby1yZWNvcmRpbmcnKTtcblxuICAgICAgICAvLyBIZWFkZXIgYW5kIHRpbWVyIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBoZWFkZXJUaW1lckNvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdzbWFydC1tZW1vLWhlYWRlci10aW1lci1jb250YWluZXInIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJUaW1lckNvbnRhaW5lci5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdSZWNvcmRpbmcuLi4nLCBjbHM6ICdzbWFydC1tZW1vLXJlY29yZGluZy1oZWFkZXInIH0pO1xuICAgICAgICB0aGlzLnRpbWVyID0gaGVhZGVyVGltZXJDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnc21hcnQtbWVtby10aW1lcicsIHRleHQ6ICcwMDowMCcgfSk7XG5cbiAgICAgICAgLy8gQWRkIHNwZWNpZmljIGNsYXNzIHRvIG1vZGFsLWNvbnRlbnRcbiAgICAgICAgY29udGVudEVsLmFkZENsYXNzKCdzbWFydC1tZW1vLWF1ZGlvLXJlY29yZC1tb2RhbC1jb250ZW50Jyk7XG5cbiAgICAgICAgLy8gUmVkIGRvdCBhbmltYXRpb24gY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHJlZERvdENvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdzbWFydC1tZW1vLXJlZC1kb3QtY29udGFpbmVyJyB9KTtcbiAgICAgICAgdGhpcy5yZWREb3QgPSByZWREb3RDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnc21hcnQtbWVtby1yZWQtZG90JyB9KTtcblxuICAgICAgICAvLyBDb250cm9sIGJ1dHRvbnMgZ3JvdXBcbiAgICAgICAgY29uc3QgY29udHJvbEdyb3VwV3JhcHBlciA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6ICdzbWFydC1tZW1vLWNvbnRyb2wtZ3JvdXAtd3JhcHBlcicgfSk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xHcm91cCA9IGNvbnRyb2xHcm91cFdyYXBwZXIuY3JlYXRlRGl2KHsgY2xzOiAnc21hcnQtbWVtby1tb2RhbC1idXR0b24tZ3JvdXAnIH0pO1xuICAgICAgICBjb25zdCBwbGF5UGF1c2VCdXR0b24gPSBjb250cm9sR3JvdXAuY3JlYXRlRWwoJ2J1dHRvbicsIHsgY2xzOiAnc21hcnQtbWVtby1tb2RhbC1idXR0b24gc21hcnQtbWVtby1mbGV4JyB9KTtcbiAgICAgICAgY29uc3Qgc3RvcEJ1dHRvbiA9IGNvbnRyb2xHcm91cC5jcmVhdGVFbCgnYnV0dG9uJywgeyBjbHM6ICdzbWFydC1tZW1vLW1vZGFsLWJ1dHRvbiBzbWFydC1tZW1vLWZsZXgnIH0pO1xuXG4gICAgICAgIHNldEljb24ocGxheVBhdXNlQnV0dG9uLCAncGF1c2UnKTsgLy8gSW5pdGlhbGx5IHNldCB0byBwYXVzZVxuICAgICAgICBzZXRJY29uKHN0b3BCdXR0b24sICdzcXVhcmUnKTsgLy8gU3RvcCBpY29uXG5cbiAgICAgICAgc3RvcEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvRmlsZSA9IGF3YWl0IHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1JlY29yZGluZyhhdWRpb0ZpbGUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGxheVBhdXNlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlUmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgc2V0SWNvbihwbGF5UGF1c2VCdXR0b24sICdjaXJjbGUnKTtcbiAgICAgICAgICAgICAgICBoZWFkZXIudGV4dENvbnRlbnQgPSAnUGF1c2VkJztcbiAgICAgICAgICAgICAgICBtb2RhbEVsLmFkZENsYXNzKCdzbWFydC1tZW1vLXBhdXNlZCcpO1xuICAgICAgICAgICAgICAgIG1vZGFsRWwucmVtb3ZlQ2xhc3MoJ3NtYXJ0LW1lbW8tcmVjb3JkaW5nJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lT3JTdGFydFJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgIHNldEljb24ocGxheVBhdXNlQnV0dG9uLCAncGF1c2UnKTtcbiAgICAgICAgICAgICAgICBoZWFkZXIudGV4dENvbnRlbnQgPSAnUmVjb3JkaW5nLi4uJztcbiAgICAgICAgICAgICAgICBtb2RhbEVsLnJlbW92ZUNsYXNzKCdzbWFydC1tZW1vLXBhdXNlZCcpO1xuICAgICAgICAgICAgICAgIG1vZGFsRWwuYWRkQ2xhc3MoJ3NtYXJ0LW1lbW8tcmVjb3JkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUmVjb3JkaW5nID0gIXRoaXMuaXNSZWNvcmRpbmc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpYmVCdXR0b24gPSBjb250cm9sR3JvdXBXcmFwcGVyLmNyZWF0ZUVsKCdidXR0b24nLCB7IGNsczogJ3NtYXJ0LW1lbW8tbW9kYWwtYnV0dG9uIHNtYXJ0LW1lbW8tZnVsbC13aWR0aC1idXR0b24gc21hcnQtbWVtby10cmFuc2NyaWJlLWJ1dHRvbicgfSk7XG5cbiAgICAgICAgdHJhbnNjcmliZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvRmlsZSA9IGF3YWl0IHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1JlY29yZGluZyhhdWRpb0ZpbGUsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzZXRJY29uKHRyYW5zY3JpYmVCdXR0b24sICdmaWxlLXRleHQnKTsgLy8gSW5pdGlhbGx5IHNldCB0byBidWxiXG5cbiAgICAgICAgLy8gQXBwZW5kIHRleHQgdG8gdGhlIGJ1dHRvblxuICAgICAgICBjb25zdCBidXR0b25UZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyBTbWFydCBUcmFuc2NyaWJlJyk7XG4gICAgICAgIHRyYW5zY3JpYmVCdXR0b24uYXBwZW5kQ2hpbGQoYnV0dG9uVGV4dCk7XG5cbiAgICAgICAgLy8gQWRkIG1hcmdpbi1yaWdodCB0byB0aGUgU1ZHIGVsZW1lbnRcbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRyYW5zY3JpYmVCdXR0b24ucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG4gICAgICAgIGlmIChzdmdFbGVtZW50KSB7XG4gICAgICAgICAgICBzdmdFbGVtZW50LnN0eWxlLm1hcmdpblJpZ2h0ID0gJzEwcHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzZXRCdXR0b24gPSBjb250ZW50RWwuY3JlYXRlRWwoJ2J1dHRvbicsIHsgY2xzOiAnc21hcnQtbWVtby1tb2RhbC1idXR0b24gc21hcnQtbWVtby1mdWxsLXdpZHRoLWJ1dHRvbiBzbWFydC1tZW1vLXJlc2V0LWJ1dHRvbicsIHRleHQ6ICdSZXN0YXJ0JyB9KTtcbiAgICAgICAgcmVzZXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhcmRSZXNldCgpO1xuICAgICAgICAgICAgc2V0SWNvbihwbGF5UGF1c2VCdXR0b24sICdjaXJjbGUnKTtcbiAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9ICdSZWFkeSB0byBSZWNvcmQnO1xuICAgICAgICAgICAgdGhpcy5pc1JlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbW9kYWxFbC5hZGRDbGFzcygnc21hcnQtbWVtby1wYXVzZWQnKTtcbiAgICAgICAgICAgIG1vZGFsRWwucmVtb3ZlQ2xhc3MoJ3NtYXJ0LW1lbW8tcmVjb3JkaW5nJyk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcmVkIGRvdCBzdG9wcyBwdWxzaW5nXG4gICAgICAgICAgICB0aGlzLnJlZERvdC5jbGFzc0xpc3QucmVtb3ZlKCdzbWFydC1tZW1vLXB1bHNlLWFuaW1hdGlvbicpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdGFydCByZWNvcmRpbmcgaW1tZWRpYXRlbHkgdXBvbiBvcGVuaW5nIHRoZSBtb2RhbFxuICAgICAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nKCk7XG4gICAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlZERvdC5jbGFzc0xpc3QuYWRkKCdzbWFydC1tZW1vLXB1bHNlLWFuaW1hdGlvbicpO1xuXG4gICAgICAgIC8vIEJsdXIgYW55IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRSZWNvcmRpbmcoKSB7XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSlcbiAgICAgICAgICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHVwTWVkaWFSZWNvcmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5zdGFydCgxMDAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2RhdGFhdmFpbGFibGUnLCB0aGlzLm9uRGF0YUF2YWlsYWJsZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBtaWNyb3Bob25lOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXR1cE1lZGlhUmVjb3JkZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhUmVjb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5hZGRFdmVudExpc3RlbmVyKCdzdG9wJywgdGhpcy5vblN0b3AuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkRhdGFBdmFpbGFibGUoZXZlbnQ6IEJsb2JFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc1Jlc2V0dGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goZXZlbnQuZGF0YSk7XG4gICAgfVxuXG4gICAgb25TdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Jlc2V0dGluZykge1xuICAgICAgICAgICAgdGhpcy5pc1Jlc2V0dGluZyA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZyBhZnRlciByZXNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYih0aGlzLmNodW5rcywgeyB0eXBlOiAnYXVkaW8vd2F2JyB9KTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlKGJsb2IpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmVzb2x2ZSBmdW5jdGlvbiBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2VSZWNvcmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhUmVjb3JkZXIgJiYgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXRlID09PSAncmVjb3JkaW5nJykge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3BUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7IC8vIEFjY3VtdWxhdGUgZWxhcHNlZCB0aW1lXG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSByZWQgZG90IHN0b3BzIHB1bHNpbmdcbiAgICAgICAgICAgIHRoaXMucmVkRG90LmNsYXNzTGlzdC5yZW1vdmUoJ3NtYXJ0LW1lbW8tcHVsc2UtYW5pbWF0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bWVPclN0YXJ0UmVjb3JkaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5tZWRpYVJlY29yZGVyICYmIHRoaXMubWVkaWFSZWNvcmRlci5zdGF0ZSA9PT0gJ3BhdXNlZCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5yZXN1bWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7IC8vIFJlc2V0IHN0YXJ0IHRpbWUgdG8gbm93XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lcigpO1xuXG4gICAgICAgIC8vIEVuc3VyZSByZWQgZG90IHN0YXJ0cyBwdWxzaW5nXG4gICAgICAgIHRoaXMucmVkRG90LmNsYXNzTGlzdC5hZGQoJ3NtYXJ0LW1lbW8tcHVsc2UtYW5pbWF0aW9uJyk7XG4gICAgfVxuXG4gICAgaGFyZFJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5tZWRpYVJlY29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLm9uc3RvcCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUmVjb3JkZXIub25kYXRhYXZhaWxhYmxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWVkaWFSZWNvcmRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Jlc2V0dGluZyA9IHRydWU7IC8vIFNldCB0aGUgcmVzZXQgZmxhZ1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdOyAvLyBDbGVhciB0aGUgY2h1bmtzXG4gICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwOyAvLyBSZXNldCBlbGFwc2VkIHRpbWVcbiAgICAgICAgdGhpcy5zdG9wVGltZXIoKTtcbiAgICAgICAgdGhpcy50aW1lci50ZXh0Q29udGVudCA9ICcwMDowMCc7XG4gICAgICAgIC8vIEVuc3VyZSByZWQgZG90IHN0b3BzIHB1bHNpbmdcbiAgICAgICAgdGhpcy5yZWREb3QuY2xhc3NMaXN0LnJlbW92ZSgnc21hcnQtbWVtby1wdWxzZS1hbmltYXRpb24nKTsgLy8gRW5zdXJlIGl0J3MgcmVtb3ZlZCBvbiByZXNldFxuICAgIH1cblxuICAgIHN0b3BSZWNvcmRpbmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxCbG9iIHwgbnVsbD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFSZWNvcmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5hZGRFdmVudExpc3RlbmVyKCdzdG9wJywgdGhpcy5vblN0b3AuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGFydFRpbWVyKCkge1xuICAgICAgICB0aGlzLnN0b3BUaW1lcigpOyAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXJcbiAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lSW5TZWNvbmRzID0gTWF0aC5mbG9vcih0aGlzLmVsYXBzZWRUaW1lIC8gMTAwMCkgKyBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMCk7XG4gICAgICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihlbGFwc2VkVGltZUluU2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZHMgPSBlbGFwc2VkVGltZUluU2Vjb25kcyAlIDYwO1xuICAgICAgICAgICAgdGhpcy50aW1lci50ZXh0Q29udGVudCA9IGAke3RoaXMucGFkTnVtYmVyKG1pbnV0ZXMpfToke3RoaXMucGFkTnVtYmVyKHNlY29uZHMpfWA7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cblxuICAgIHN0b3BUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYWROdW1iZXIobnVtOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gbnVtLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB9XG5cblxuICAgIG9wZW4oKSB7XG4gICAgICAgIHN1cGVyLm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPEJsb2I+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUsIFRGb2xkZXIsIG5vcm1hbGl6ZVBhdGggfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlRmlsZShhcHA6IEFwcCwgYXVkaW9CbG9iOiBCbG9iLCBmaWxlTmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFRGaWxlPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpO1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGAke25vcm1hbGl6ZWRQYXRofS8ke2ZpbGVOYW1lfWA7XG5cbiAgICAgICAgYXdhaXQgZW5zdXJlRGlyZWN0b3J5RXhpc3RzKGFwcCwgbm9ybWFsaXplZFBhdGgpO1xuXG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYXVkaW9CbG9iLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IGFwcC52YXVsdC5jcmVhdGVCaW5hcnkoZmlsZVBhdGgsIHVpbnQ4QXJyYXkpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBjcmVhdGlvbiBmYWlsZWQgYW5kIHJldHVybmVkIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgYXVkaW8gZmlsZTonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlRGlyZWN0b3J5RXhpc3RzKGFwcDogQXBwLCBmb2xkZXJQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGZvbGRlclBhdGguc3BsaXQoJy8nKTtcbiAgICBsZXQgY3VycmVudFBhdGggPSAnJztcblxuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBjdXJyZW50UGF0aCA9IGN1cnJlbnRQYXRoID8gYCR7Y3VycmVudFBhdGh9LyR7cGFydH1gIDogcGFydDtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIGlmICghZm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm9sZGVyIGFscmVhZHkgZXhpc3RzOiAke2N1cnJlbnRQYXRofWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y3VycmVudFBhdGh9IGlzIG5vdCBhIGZvbGRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0ZvbGRlciBhbHJlYWR5IGV4aXN0cycpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9sZGVyIGFscmVhZHkgZXhpc3RzLCBjb250aW51ZSB0byB0aGUgbmV4dCBwYXJ0XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEhhbmRsZWQgZXhpc3RpbmcgZm9sZGVyOiAke2N1cnJlbnRQYXRofWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBlbnN1cmluZyBkaXJlY3RvcnkgZXhpc3RzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFJQSxRQUFNLG1CQUFOLE1BQXVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTXJCLHFCQUFxQixNQUFNO0FBQUUsZUFBTyxvQkFBb0IsSUFBSTtBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNL0QsTUFBTSxhQUFhLE9BQU87QUFFeEIsZUFBTyxLQUFLLGdCQUFnQixLQUFLO0FBQUEsTUFDbkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxnQkFBZ0IsT0FBTTtBQUNwQixZQUFHLE9BQU8sVUFBVTtBQUFVLGtCQUFRLEtBQUssVUFBVSxLQUFLO0FBRTFELGVBQU8sS0FBSyxLQUFLLE1BQU0sU0FBUyxDQUFDO0FBQUEsTUFDbkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxjQUFjLE1BQUs7QUFDakIsZUFBTyxLQUFLLFFBQVEsS0FBSyxTQUFPLElBQUksU0FBUyxVQUFVO0FBQUEsTUFDekQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxzQkFBc0IsV0FBVTtBQUM5QixlQUFPLFVBQVU7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGNBQWMsV0FBVTtBQUN0QixlQUFPLFVBQVU7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFlBQVksTUFBSztBQTNEbkI7QUEyRHFCLGdCQUFPLFVBQUssWUFBTCxtQkFBZTtBQUFBLE1BQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNN0Msb0JBQW9CLE1BQU07QUFqRTVCO0FBaUU4QixnQkFBTyxVQUFLLFlBQVksSUFBSSxNQUFyQixvQkFBeUIsVUFBSyxZQUFZLElBQUksTUFBckIsbUJBQXdCO0FBQUEsTUFBTztBQUFBLElBQzdGO0FBQ0EsWUFBUSxtQkFBbUI7QUFRM0IsYUFBUyxvQkFBb0IsTUFBTTtBQUNqQyxVQUFJLGVBQWU7QUFDbkIsWUFBTSxXQUFXLEtBQUssU0FDbkIsT0FBTyxTQUFPLElBQUksU0FBUyxRQUFRLEVBQ25DLElBQUksT0FBSztBQUNSLFlBQUcsRUFBRSxTQUFTLFFBQU87QUFDbkIsaUJBQU8sRUFBRSxNQUFNLFFBQVEsU0FBUztBQUFBLFlBQzlCO0FBQUEsY0FDRSxNQUFNO0FBQUEsY0FDTixhQUFhLFFBQVE7QUFBQSxjQUNyQixTQUFTLEVBQUU7QUFBQSxZQUNiO0FBQUEsVUFDRixFQUFDO0FBQUEsUUFDSDtBQUNBLFlBQUcsRUFBRSxTQUFTLGVBQWUsRUFBRSxZQUFXO0FBQ3hDO0FBQ0EsZ0JBQU1BLE9BQU07QUFBQSxZQUNWLE1BQU0sRUFBRTtBQUFBLFlBQ1IsU0FBUyxFQUFFLFdBQVcsSUFBSSxRQUFNO0FBQUEsY0FDOUIsTUFBTTtBQUFBLGNBQ04sSUFBSSxRQUFRO0FBQUEsY0FDWixNQUFNLEVBQUUsU0FBUztBQUFBLGNBQ2pCLE9BQVEsT0FBTyxFQUFFLFNBQVMsY0FBYyxXQUFZLEtBQUssTUFBTSxFQUFFLFNBQVMsU0FBUyxJQUFJLEVBQUUsU0FBUztBQUFBLFlBQ3BHLEVBQUU7QUFBQSxVQUNKO0FBQ0EsY0FBRyxFQUFFLFNBQVE7QUFDWCxnQkFBRyxPQUFPLEVBQUUsWUFBWTtBQUFVLGNBQUFBLEtBQUksUUFBUSxLQUFLLEVBQUMsTUFBTSxRQUFRLE1BQU0sRUFBRSxRQUFPLENBQUM7QUFBQTtBQUM3RSxnQkFBRSxRQUFRLFFBQVEsT0FBS0EsS0FBSSxRQUFRLEtBQUssQ0FBQyxDQUFDO0FBQUEsVUFDakQ7QUFDQSxpQkFBT0E7QUFBQSxRQUNUO0FBQ0EsWUFBRyxPQUFPLEVBQUUsWUFBWTtBQUFVLGlCQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sU0FBUyxFQUFFLFFBQVE7QUFDNUUsWUFBRyxNQUFNLFFBQVEsRUFBRSxPQUFPLEdBQUU7QUFDMUIsZ0JBQU0sVUFBVSxFQUFFLFFBQVEsSUFBSSxPQUFLO0FBQ2pDLGdCQUFHLEVBQUUsU0FBUztBQUFRLHFCQUFPLEVBQUMsTUFBTSxRQUFRLE1BQU0sRUFBRSxLQUFJO0FBQ3hELGdCQUFHLEVBQUUsU0FBUyxhQUFZO0FBQ3hCLG9CQUFNLFlBQVksRUFBRSxVQUFVO0FBQzlCLGtCQUFJLGFBQWEsVUFBVSxNQUFNLEdBQUcsRUFBRSxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNyRCxrQkFBRyxlQUFlO0FBQWEsNkJBQWE7QUFDNUMscUJBQU8sRUFBQyxNQUFNLFNBQVMsUUFBUSxFQUFDLE1BQU0sVUFBVSxZQUF3QixNQUFNLFVBQVUsTUFBTSxHQUFHLEVBQUUsQ0FBQyxFQUFDLEVBQUM7QUFBQSxZQUN4RztBQUFBLFVBQ0YsQ0FBQztBQUNELGlCQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sUUFBUTtBQUFBLFFBQ2pDO0FBQ0EsZUFBTztBQUFBLE1BQ1QsQ0FBQztBQUVILFlBQU0sRUFBRSxPQUFPLFlBQVksYUFBYSxPQUFPLFlBQVksSUFBSTtBQUcvRCxZQUFNLGtCQUFrQixLQUFLLFNBQVMsY0FBYyxTQUFPLElBQUksU0FBUyxZQUFZLElBQUksUUFBUSxTQUFTLFVBQVUsQ0FBQztBQUNwSCxVQUFJLGtCQUFrQixJQUFJO0FBQ3hCLGNBQU0sZ0JBQWdCLGdCQUFnQixLQUFLLFNBQVMsZUFBZSxFQUFFLFVBQVU7QUFDL0UsaUJBQVMsU0FBUyxTQUFTLENBQUMsRUFBRSxVQUFVLGdCQUFnQixTQUFTLFNBQVMsU0FBUyxDQUFDLEVBQUU7QUFBQSxNQUN4RjtBQUNBLGNBQVEsSUFBSSxRQUFRO0FBQ3BCLFlBQU0sTUFBTTtBQUFBLFFBQ1Y7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQ0EsVUFBRyxPQUFNO0FBQ1AsWUFBSSxRQUFRLE1BQU0sSUFBSSxXQUFTO0FBQUEsVUFDN0IsTUFBTSxLQUFLLFNBQVM7QUFBQSxVQUNwQixhQUFhLEtBQUssU0FBUztBQUFBLFVBQzNCLGNBQWMsS0FBSyxTQUFTO0FBQUEsUUFDOUIsRUFBRTtBQUNGLGFBQUcsMkNBQWEsVUFBUyxZQUFXO0FBRWxDLGdCQUFNLGNBQWMsWUFBWSxZQUFZLFNBQVM7QUFDckQsZ0JBQU0sZ0JBQWdCLElBQUksU0FBUyxjQUFjLFNBQU8sSUFBSSxTQUFTLE1BQU07QUFDM0UsY0FBSSxTQUFTLGFBQWEsRUFBRSxXQUFXLE9BQU87QUFDOUMsY0FBSSxTQUFTLHNCQUFzQixZQUFZLFNBQVM7QUFBQSxRQUMxRDtBQUFBLE1BQ0Y7QUFHQSxZQUFNLDhCQUE4QixLQUFLLFNBQVMsY0FBYyxTQUFPLElBQUksU0FBUyxZQUFZLENBQUMsSUFBSSxRQUFRLFNBQVMsVUFBVSxDQUFDO0FBQ2pJLFVBQUcsOEJBQThCO0FBQUksWUFBSSxTQUFTLEtBQUssU0FBUywyQkFBMkIsRUFBRTtBQUM3RixhQUFPO0FBQUEsSUFDVDtBQUNBLFlBQVEsc0JBQXNCO0FBQUE7QUFBQTs7O0FDN0o5QjtBQUFBO0FBSUEsUUFBTSxnQkFBTixNQUFvQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1sQixxQkFBcUIsUUFBUTtBQUFFLGVBQU8saUJBQWlCLE1BQU07QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT2hFLG9CQUFvQixNQUFNO0FBQUUsZUFBTyxLQUFLO0FBQUEsTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUTlDLDJCQUEyQixPQUFPO0FBQ2hDLFlBQUcsQ0FBQyxLQUFLO0FBQWlCLGVBQUssa0JBQWtCO0FBQ2pELHFCQUFhLEtBQUssaUJBQWlCO0FBQ25DLGFBQUssb0JBQW9CLFdBQVcsTUFBTTtBQUN0QyxlQUFLLGtCQUFrQjtBQUFBLFFBQzNCLEdBQUcsR0FBSztBQUNSLGNBQU0sT0FBTyxNQUFNLE9BQU8sSUFBSTtBQUU5QixjQUFNLFFBQVEsS0FBSyxNQUFNLElBQUksRUFBRSxNQUFNLEtBQUssZUFBZTtBQUN6RCxnQkFBUSxJQUFJLEtBQUs7QUFDakIsYUFBSyxtQkFBbUIsTUFBTTtBQUM5QixjQUFNLGFBQWEsTUFDZCxPQUFPLENBQUMsU0FBUyxLQUFLLEtBQUssTUFBTSxFQUFFLEVBQ25DLElBQUksQ0FBQyxTQUFTO0FBQ1gsa0JBQVEsSUFBSSxJQUFJO0FBQ2hCLGdCQUFNLE9BQU8sS0FBSyxNQUFNLElBQUk7QUFDNUIsY0FBRyxLQUFLLGVBQWUsY0FBYztBQUNqQyxvQkFBUSxJQUFJLFlBQVk7QUFDeEIsaUJBQUssZ0JBQWdCO0FBQ3JCLHVCQUFXLE1BQU07QUFDYixtQkFBSyxnQkFBZ0I7QUFBQSxZQUN6QixHQUFHLEdBQUk7QUFDUCxtQkFBTztBQUFBLFVBQ1g7QUFDQSxpQkFBTyxLQUFLO0FBQUEsUUFDaEIsQ0FBQyxFQUNBLEtBQUssRUFBRTtBQUNaLGdCQUFRLElBQUksVUFBVTtBQUN0QixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGlCQUFpQixPQUFPO0FBQUUsZUFBTyxLQUFLO0FBQUEsTUFBZTtBQUFBLElBQ3ZEO0FBQ0EsWUFBUSxnQkFBZ0I7QUFVeEIsYUFBUyxpQkFBaUIsUUFBUTtBQUM5QixZQUFNLFNBQVM7QUFBQSxRQUNYLE9BQU8sT0FBTztBQUFBO0FBQUEsUUFFZCxjQUFjLE9BQU8sU0FDaEIsTUFBTSxHQUFHLEVBQUUsRUFDWCxJQUFJLENBQUMsYUFBYTtBQUFBLFVBQ2YsTUFBTSxRQUFRO0FBQUEsVUFDZCxTQUFTLGdDQUFnQyxPQUFPO0FBQUEsUUFDcEQsRUFBRTtBQUFBLFFBRU4sU0FBUyxnQ0FBZ0MsT0FBTyxTQUFTLE9BQU8sU0FBUyxTQUFTLENBQUMsQ0FBQztBQUFBLFFBQ3BGLGFBQWEsT0FBTztBQUFBO0FBQUEsTUFFeEI7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQUNBLFlBQVEsbUJBQW1CO0FBRTNCLGFBQVMsZ0NBQWdDLFNBQVM7QUFDOUMsYUFBTyxNQUFNLFFBQVEsUUFBUSxPQUFPLElBQUksUUFBUSxRQUFRLE9BQU8sT0FBSyxFQUFFLFNBQVMsTUFBTSxFQUFFLElBQUksT0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLElBQUksSUFBSSxRQUFRO0FBQUEsSUFDakk7QUFBQTtBQUFBOzs7QUM5RkE7QUFBQTtBQUlBLFFBQU0sZ0JBQU4sTUFBb0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS2xCLFlBQVksT0FBTztBQUFFLGFBQUssUUFBUTtBQUFBLE1BQU87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPekMscUJBQXFCLE1BQU07QUFBRSxlQUFPLGlCQUFpQixJQUFJO0FBQUEsTUFBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU81RCxjQUFjLE1BQU07QUF2QnRCO0FBdUJ3QixnQkFBTyxrQ0FBSyxlQUFMLG1CQUFrQixPQUFsQixtQkFBc0IsWUFBdEIsbUJBQStCLFVBQS9CLG1CQUF1QyxPQUF2QyxtQkFBMkM7QUFBQSxNQUFjO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT3RGLGNBQWMsV0FBVztBQUFFLGVBQU8sdUNBQVc7QUFBQSxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT25ELHNCQUFzQixXQUFXO0FBQUUsZUFBTyx1Q0FBVztBQUFBLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPM0QsWUFBWSxNQUFNO0FBNUNwQjtBQTRDc0IsZ0JBQU8sVUFBSyxlQUFMLG1CQUFrQjtBQUFBLE1BQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPakQsb0JBQW9CLE1BQU07QUFuRDVCO0FBbUQ4QixnQkFBTyxnQkFBSyxZQUFZLElBQUksTUFBckIsbUJBQXdCLFlBQXhCLG1CQUFpQyxNQUFNLElBQUksVUFBUSxLQUFLLE1BQU0sS0FBSztBQUFBLE1BQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPM0csMkJBQTJCLE9BQU87QUFBRSxlQUFPLE1BQU0sS0FBSyxRQUFRLFFBQVEsSUFBSTtBQUFBLE1BQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPN0UsaUJBQWlCLE9BQU87QUFBRSxlQUFPLE1BQU0sT0FBTyxJQUFJLGVBQWU7QUFBQSxNQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT3BFLE1BQU0sYUFBYSxPQUFPO0FBeEU1QjtBQXlFSSxjQUFNLE1BQU07QUFBQSxVQUNWLEtBQUssc0ZBQXNGLEtBQUssTUFBTTtBQUFBLFVBQ3RHLFFBQVE7QUFBQSxVQUNSLFNBQVMsRUFBRSxnQkFBZ0IsbUJBQW1CO0FBQUEsUUFDaEQ7QUFDQSxZQUFJO0FBQ0osWUFBRyxPQUFPLFVBQVU7QUFBVSxpQkFBTyxpQkFBaUIsRUFBRSxVQUFVLENBQUMsRUFBRSxNQUFNLFFBQVEsU0FBUyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQUEsaUJBQzdGLE1BQU0sUUFBUSxLQUFLO0FBQUcsaUJBQU8saUJBQWlCLEVBQUUsVUFBVSxNQUFNLENBQUM7QUFBQSxpQkFDakUsT0FBTyxVQUFVO0FBQVUsaUJBQU8saUJBQWlCLEtBQUs7QUFBQTtBQUM1RCxpQkFBTyxRQUFRLE1BQU0sa0NBQWtDLEtBQUs7QUFDakUsZUFBTyxLQUFLO0FBQ1osZUFBTyxLQUFLO0FBQ1osWUFBSSxPQUFPLEtBQUssVUFBVSxJQUFJO0FBQzlCLGNBQU0sT0FBTyxNQUFNLEtBQUssTUFBTSxnQkFBZ0IsR0FBRztBQUNqRCxnQkFBTyxrQ0FBTSxTQUFOLG1CQUFZO0FBQUEsTUFDckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsSUFBSSxXQUFXO0FBQUUsZUFBTyxLQUFLLE1BQU0sT0FBTyxTQUFTLFFBQVEsY0FBYyxLQUFLLE1BQU0sVUFBVSxJQUFJLFVBQVUsS0FBSyxNQUFNO0FBQUEsTUFBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNaEksSUFBSSxxQkFBcUI7QUFBRSxlQUFPLEtBQUssTUFBTSxPQUFPLG1CQUFtQixRQUFRLGNBQWMsS0FBSyxNQUFNLFVBQVUsSUFBSSxVQUFVLEtBQUssTUFBTTtBQUFBLE1BQVM7QUFBQSxJQUN0SjtBQUNBLFlBQVEsZ0JBQWdCO0FBUXhCLGFBQVMsaUJBQWlCLE1BQU07QUFXOUIsWUFBTSxXQUFXLEtBQUssU0FBUyxPQUFPLFNBQU8sSUFBSSxTQUFTLFFBQVE7QUFHbEUsWUFBTSxrQkFBa0IsS0FBSyxTQUFTLGNBQWMsU0FBTyxJQUFJLFNBQVMsWUFBWSxJQUFJLFFBQVEsU0FBUyxVQUFVLENBQUM7QUFDcEgsVUFBSSxrQkFBa0IsSUFBSTtBQUN4QixjQUFNLGdCQUFnQixvQ0FBb0MsS0FBSyxTQUFTLGVBQWUsRUFBRSxVQUFVO0FBQ25HLGlCQUFTLFNBQVMsU0FBUyxDQUFDLEVBQUUsVUFBVSxnQkFBZ0IsU0FBUyxTQUFTLFNBQVMsQ0FBQyxFQUFFO0FBQUEsTUFDeEY7QUFDQSxZQUFNLE9BQU87QUFBQSxRQUNYLFVBQVUsU0FDUCxPQUFPLFNBQU8sSUFBSSxTQUFTLFFBQVEsRUFDbkMsSUFBSSxTQUFPO0FBQ1YsZ0JBQU0sVUFBVSxDQUFDO0FBQ2pCLGtCQUFRLE9BQU8sSUFBSSxTQUFTLGNBQWMsVUFBVSxJQUFJO0FBQ3hELGtCQUFRLFFBQVEsQ0FBQyxNQUFNLFFBQVEsSUFBSSxPQUFPLElBQUksQ0FBQyxFQUFDLE1BQU0sSUFBSSxRQUFPLENBQUMsSUFBSSxJQUFJLFFBQVEsSUFBSSxPQUFLO0FBQ3pGLGdCQUFHLEVBQUUsU0FBUyxRQUFPO0FBQ25CLHFCQUFPLEVBQUMsTUFBTSxFQUFFLEtBQUk7QUFBQSxZQUN0QjtBQUNBLGdCQUFHLEVBQUUsU0FBUyxhQUFZO0FBQ3hCLG9CQUFNLFlBQVksRUFBRSxVQUFVO0FBQzlCLGtCQUFJLFlBQVksVUFBVSxNQUFNLEdBQUcsRUFBRSxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNwRCxrQkFBRyxjQUFjO0FBQWEsNEJBQVk7QUFDMUMscUJBQU8sRUFBQyxhQUFhLEVBQUMsV0FBc0IsTUFBTSxVQUFVLE1BQU0sR0FBRyxFQUFFLENBQUMsRUFBQyxFQUFDO0FBQUEsWUFDNUU7QUFBQSxVQUNGLENBQUM7QUFDRCxpQkFBTztBQUNQLFdBQUM7QUFBQSxZQUNDLE1BQU0sSUFBSSxTQUFTLGNBQWMsVUFBVSxJQUFJO0FBQUEsWUFDL0MsT0FBTyxNQUFNLFFBQVEsSUFBSSxPQUFPLElBQUksQ0FBQyxFQUFDLE1BQU0sSUFBSSxRQUFRLE9BQU8sT0FBSyxFQUFFLFNBQVMsTUFBTSxFQUFFLElBQUksT0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLElBQUksRUFBQyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sSUFBSSxRQUFRLENBQUM7QUFBQSxVQUMvSTtBQUFBLFFBQ0YsQ0FBQztBQUFBLFFBRUgsa0JBQWtCO0FBQUEsVUFDaEIsYUFBYSxLQUFLLGVBQWU7QUFBQSxVQUNqQyxNQUFNLEtBQUssUUFBUTtBQUFBLFVBQ25CLE1BQU0sS0FBSyxRQUFRO0FBQUEsVUFDbkIsaUJBQWlCLEtBQUssY0FBYztBQUFBLFVBQ3BDLGVBQWUsS0FBSyxpQkFBaUIsQ0FBQztBQUFBLFVBQ3RDLGlCQUFpQixLQUFLLEtBQUs7QUFBQSxRQUM3QjtBQUFBLFFBQ0EsZ0JBQWdCO0FBQUEsVUFDZDtBQUFBLFlBQ0UsVUFBVTtBQUFBLFlBQ1YsV0FBVztBQUFBLFVBQ2I7QUFBQSxVQUNBO0FBQUEsWUFDRSxVQUFVO0FBQUEsWUFDVixXQUFXO0FBQUEsVUFDYjtBQUFBLFVBQ0E7QUFBQSxZQUNFLFVBQVU7QUFBQSxZQUNWLFdBQVc7QUFBQSxVQUNiO0FBQUEsVUFDQTtBQUFBLFlBQ0UsVUFBVTtBQUFBLFlBQ1YsV0FBVztBQUFBLFVBQ2I7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUNBLFlBQU0sc0JBQXNCLEtBQUssU0FBUyxPQUFPLFNBQU8sSUFBSSxTQUFTLFlBQVksQ0FBQyxJQUFJLFFBQVEsU0FBUyxVQUFVLENBQUM7QUFDbEgsVUFBRyxvQkFBb0IsU0FBUztBQUFHLGFBQUssb0JBQW9CLEVBQUUsT0FBTyxvQkFBb0IsSUFBSSxVQUFRLEVBQUUsTUFBTSxJQUFJLFFBQVEsRUFBRSxFQUFFO0FBQzdILFVBQUcsS0FBSyxPQUFNO0FBQ1osYUFBSyxRQUFRLENBQUM7QUFBQSxVQUNaLHVCQUF1QixLQUFLLE1BQU0sSUFBSSxXQUFTO0FBQUEsWUFDN0MsTUFBTSxLQUFLLFNBQVM7QUFBQSxZQUNwQixhQUFhLEtBQUssU0FBUztBQUFBLFlBQzNCLFlBQVksS0FBSyxTQUFTO0FBQUEsVUFDNUIsRUFBRTtBQUFBLFFBQ0osQ0FBQztBQUNELFlBQUcsS0FBSyxhQUFZO0FBQ2xCLGNBQUcsS0FBSyxnQkFBZ0IsUUFBTztBQUM3QixnQkFBRyxLQUFLLE1BQU0sU0FBUyxTQUFTLEdBQUU7QUFDaEMsbUJBQUssY0FBYztBQUFBLGdCQUNqQix5QkFBeUI7QUFBQSxrQkFDdkIsTUFBTTtBQUFBLGtCQUNOLHdCQUF3QixLQUFLLE1BQU0sSUFBSSxVQUFRLEtBQUssU0FBUyxJQUFJO0FBQUEsZ0JBQ25FO0FBQUEsY0FDRjtBQUFBLFlBQ0YsT0FBSztBQUVILG1CQUFLLG9CQUFvQjtBQUFBLGdCQUN2QixNQUFNO0FBQUEsZ0JBQ04sT0FBTztBQUFBLGtCQUNMO0FBQUEsb0JBQ0UsTUFBTSxnQ0FBZ0MsS0FBSyxNQUFNLENBQUMsRUFBRSxzQkFBc0IsQ0FBQyxFQUFFO0FBQUEsa0JBQy9FO0FBQUEsZ0JBQ0Y7QUFBQSxjQUNGO0FBQ0Esb0JBQU0sY0FBYyxnQ0FBZ0MsS0FBSyxNQUFNLENBQUMsRUFBRSxzQkFBc0IsQ0FBQyxFQUFFO0FBQzNGLG9CQUFNLGdCQUFnQixLQUFLLFNBQVMsY0FBYyxTQUFPLElBQUksU0FBUyxNQUFNO0FBQzVFLG1CQUFLLFNBQVMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxFQUFFLFFBQVEsU0FBUztBQUFBLFlBQ3pEO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFDQSxZQUFRLG1CQUFtQjtBQUFBO0FBQUE7OztBQzFOM0I7QUFBQTtBQUFBLFFBQU0sRUFBRSxpQkFBaUIsSUFBSTtBQUM3QixRQUFNLEVBQUUsY0FBYyxJQUFJO0FBQzFCLFFBQU0sRUFBRSxjQUFjLElBQUk7QUFDMUIsWUFBUSxZQUFZO0FBQ3BCLFlBQVEsU0FBUztBQUNqQixZQUFRLFNBQVM7QUFBQTtBQUFBOzs7QUNMakI7QUFBQSwwREFBQUMsU0FBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxNQUNFLFFBQVU7QUFBQSxRQUNSLGFBQWU7QUFBQSxRQUNmLE1BQVE7QUFBQSxRQUNSLFVBQVk7QUFBQSxRQUNaLFdBQWE7QUFBQSxRQUNiLFNBQVc7QUFBQSxRQUNYLGNBQWdCO0FBQUEsUUFDaEIsZUFBaUI7QUFBQSxRQUNqQixZQUFjO0FBQUEsTUFDaEI7QUFBQSxNQUNBLGVBQWlCO0FBQUEsUUFDZixhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsUUFDUixnQkFBa0I7QUFBQSxRQUNsQixVQUFZO0FBQUEsUUFDWixvQkFBc0I7QUFBQSxRQUN0QixXQUFhO0FBQUEsUUFDYixTQUFXO0FBQUEsUUFDWCxTQUFXO0FBQUEsUUFDWCxjQUFnQjtBQUFBLFFBQ2hCLGVBQWlCO0FBQUEsUUFDakIsWUFBYztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxhQUFlO0FBQUEsUUFDYixhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsUUFDUixVQUFZO0FBQUEsUUFDWixXQUFhO0FBQUEsUUFDYixjQUFnQjtBQUFBLFFBQ2hCLGVBQWlCO0FBQUEsUUFDakIsWUFBYztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxRQUFVO0FBQUEsUUFDUixhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsUUFDUixVQUFZO0FBQUEsUUFDWixXQUFhO0FBQUEsUUFDYixTQUFXO0FBQUEsUUFDWCxjQUFnQjtBQUFBLFFBQ2hCLGVBQWlCO0FBQUEsUUFDakIsWUFBYztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxXQUFhO0FBQUEsUUFDWCxhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsUUFDUixVQUFZO0FBQUEsUUFDWixXQUFhO0FBQUEsUUFDYixnQkFBa0I7QUFBQSxRQUNsQixTQUFXO0FBQUEsVUFDVCxxQkFBcUI7QUFBQSxVQUNyQixrQkFBa0I7QUFBQSxRQUNwQjtBQUFBLFFBQ0EsU0FBVztBQUFBLFFBQ1gsU0FBVztBQUFBLFFBQ1gsY0FBZ0I7QUFBQSxRQUNoQixlQUFpQjtBQUFBLFFBQ2pCLFlBQWM7QUFBQSxNQUNoQjtBQUFBLE1BQ0EsY0FBZ0I7QUFBQSxRQUNkLGFBQWU7QUFBQSxRQUNmLE1BQVE7QUFBQSxNQUNWO0FBQUEsTUFDQSxZQUFjO0FBQUEsUUFDWixhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsTUFDVjtBQUFBLElBQ0Y7QUFBQTtBQUFBOzs7QUNuRUE7QUFBQTtBQWlEQSxhQUFTLG1CQUFtQixNQUFNLG1CQUFtQjtBQWpEckQ7QUFrREUsWUFBTSxRQUFRLEtBQUssU0FBUyxXQUFXO0FBQ3ZDLFVBQUksT0FBTyxVQUFVLGVBQWUsT0FBTyxLQUFLLGlCQUFpQixFQUFFLFdBQVc7QUFBRyxjQUFNLElBQUksTUFBTSxvQ0FBb0M7QUFFckksYUFBTyxRQUFRLGlCQUFpQixFQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssS0FBSyxNQUFNO0FBQzFELFlBQUksQ0FBQyxNQUFNLEdBQUc7QUFBRyxnQkFBTSxJQUFJLE1BQU0sa0NBQWtDLG9CQUFvQixLQUFLO0FBQzVGLFlBQUksTUFBTSxRQUFRLEtBQUssS0FBSyxNQUFNLEdBQUcsRUFBRSxTQUFTLFNBQVM7QUFFdkQsZ0JBQU0sV0FBVyxPQUFPLE1BQU0sQ0FBQztBQUMvQixjQUFJLENBQUMsTUFBTSxNQUFNLFVBQVEsT0FBTyxTQUFTLFFBQVE7QUFBRyxrQkFBTSxJQUFJLE1BQU0seURBQXlEO0FBRTdILGNBQUksTUFBTSxHQUFHLEVBQUUsTUFBTSxTQUFTO0FBQVUsa0JBQU0sSUFBSSxNQUFNLHFFQUFxRTtBQUFBLFFBQy9ILFdBQVcsTUFBTSxHQUFHLEVBQUUsU0FBUyxPQUFPLE9BQU87QUFDM0MsY0FBSSxNQUFNLEdBQUcsRUFBRSxTQUFTLFlBQVksT0FBTyxVQUFVLFVBQVU7QUFFN0QsZ0JBQUksTUFBTSxPQUFPLEtBQUssQ0FBQztBQUFHLG9CQUFNLElBQUksTUFBTSw0QkFBNEIsNkJBQTZCO0FBQ25HLDhCQUFrQixHQUFHLElBQUksT0FBTyxLQUFLO0FBQUEsVUFDdkM7QUFBTyxrQkFBTSxJQUFJLE1BQU0sNEJBQTRCLHdCQUF3QixNQUFNLEdBQUcsRUFBRSxNQUFNO0FBQUEsUUFDOUY7QUFDQSxZQUFJLE1BQU0sR0FBRyxFQUFFLFFBQVEsQ0FBQyxNQUFNLEdBQUcsRUFBRSxLQUFLLFNBQVMsS0FBSztBQUFHLGdCQUFNLElBQUksTUFBTSw0QkFBNEIsd0JBQXdCLE1BQU0sR0FBRyxFQUFFLE1BQU07QUFBQSxNQUNoSixDQUFDO0FBRUQsaUJBQUssU0FBUyxXQUFXLGFBQXpCLG1CQUFtQyxRQUFRLFNBQU87QUFDaEQsWUFBSSxDQUFDLGtCQUFrQixHQUFHO0FBQUcsZ0JBQU0sSUFBSSxNQUFNLDJDQUEyQyxLQUFLO0FBQUEsTUFDL0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUNBLFlBQVEscUJBQXFCO0FBQUE7QUFBQTs7O0FDNUU3QjtBQUFBO0FBQUE7QUFBQSxRQUFNLGdCQUFOLE1BQW9CO0FBQUEsTUFDbEIsWUFBWSxLQUFLLFVBQVUsQ0FBQyxHQUFHO0FBdUcvQjtBQUFBO0FBTUE7QUFNQTtBQUlBO0FBc0JBO0FBS0E7QUEwQkE7QUEzS0UsY0FBTTtBQUFBLFVBQ0osU0FBUztBQUFBLFVBQ1QsVUFBVSxDQUFDO0FBQUEsVUFDWCxPQUFPO0FBQUEsVUFDUCxrQkFBa0I7QUFBQSxRQUNwQixJQUFJO0FBRUosYUFBSyxNQUFNO0FBQ1gsYUFBSyxTQUFTO0FBQ2QsYUFBSyxVQUFVO0FBQ2YsYUFBSyxPQUFPO0FBQ1osYUFBSyxrQkFBa0I7QUFDdkIsYUFBSyxZQUFZLENBQUM7QUFDbEIsYUFBSyxhQUFhLEtBQUs7QUFDdkIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssUUFBUTtBQUNiLGFBQUssZ0JBQWdCO0FBQ3JCLGFBQUssTUFBTTtBQUNYLGFBQUssa0JBQWtCO0FBQ3ZCLGFBQUssZUFBZTtBQUNwQixhQUFLLGFBQWE7QUFDbEIsYUFBSyxPQUFPO0FBQ1osYUFBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGlCQUFpQixNQUFNLFVBQVU7QUFDL0IsWUFBSSxDQUFDLEtBQUssVUFBVSxJQUFJO0FBQUcsZUFBSyxVQUFVLElBQUksSUFBSSxDQUFDO0FBQ25ELFlBQUksQ0FBQyxLQUFLLFVBQVUsSUFBSSxFQUFFLFNBQVMsUUFBUTtBQUFHLGVBQUssVUFBVSxJQUFJLEVBQUUsS0FBSyxRQUFRO0FBQUEsTUFDbEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLG9CQUFvQixNQUFNLFVBQVU7QUFDbEMsWUFBSSxDQUFDLEtBQUssVUFBVSxJQUFJO0FBQUc7QUFDM0IsYUFBSyxVQUFVLElBQUksSUFBSSxLQUFLLFVBQVUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxhQUFhLGFBQWEsUUFBUTtBQUN0RixZQUFJLEtBQUssVUFBVSxJQUFJLEVBQUUsV0FBVztBQUFHLGlCQUFPLEtBQUssVUFBVSxJQUFJO0FBQUEsTUFDbkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGNBQWMsT0FBTztBQUNuQixZQUFJLENBQUM7QUFBTyxpQkFBTztBQUNuQixjQUFNLFNBQVM7QUFDZixjQUFNLFlBQVksT0FBTyxNQUFNO0FBQy9CLFlBQUksT0FBTyxVQUFVLGVBQWUsS0FBSyxNQUFNLFNBQVMsR0FBRztBQUN6RCxlQUFLLFNBQVMsRUFBRSxLQUFLLE1BQU0sS0FBSztBQUNoQyxjQUFJLE1BQU07QUFBa0IsbUJBQU87QUFBQSxRQUNyQztBQUNBLFlBQUksS0FBSyxVQUFVLE1BQU0sSUFBSSxHQUFHO0FBQzlCLGVBQUssVUFBVSxNQUFNLElBQUksRUFBRSxRQUFRLENBQUMsYUFBYTtBQUMvQyxxQkFBUyxLQUFLO0FBQ2QsbUJBQU8sQ0FBQyxNQUFNO0FBQUEsVUFDaEIsQ0FBQztBQUFBLFFBQ0g7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsU0FBUztBQUNQLDhCQUFLLGtDQUFMLFdBQW9CLEtBQUs7QUFDekIsYUFBSyxNQUFNLElBQUksZUFBZTtBQUM5QixhQUFLLElBQUksaUJBQWlCLFlBQVksc0JBQUssd0NBQWtCLEtBQUssSUFBSSxDQUFDO0FBQ3ZFLGFBQUssSUFBSSxpQkFBaUIsUUFBUSxzQkFBSyxvQ0FBZ0IsS0FBSyxJQUFJLENBQUM7QUFDakUsYUFBSyxJQUFJLGlCQUFpQixvQkFBb0Isc0JBQUssMENBQW1CLEtBQUssSUFBSSxDQUFDO0FBQ2hGLGFBQUssSUFBSSxpQkFBaUIsU0FBUyxzQkFBSyxzQ0FBaUIsS0FBSyxJQUFJLENBQUM7QUFDbkUsYUFBSyxJQUFJLGlCQUFpQixTQUFTLHNCQUFLLGtDQUFlLEtBQUssSUFBSSxDQUFDO0FBQ2pFLGFBQUssSUFBSSxLQUFLLEtBQUssUUFBUSxLQUFLLEdBQUc7QUFDbkMsbUJBQVcsVUFBVSxLQUFLLFNBQVM7QUFDakMsZUFBSyxJQUFJLGlCQUFpQixRQUFRLEtBQUssUUFBUSxNQUFNLENBQUM7QUFBQSxRQUN4RDtBQUNBLFlBQUksS0FBSztBQUFlLGVBQUssSUFBSSxpQkFBaUIsaUJBQWlCLEtBQUssYUFBYTtBQUNyRixhQUFLLElBQUksa0JBQWtCLEtBQUs7QUFDaEMsYUFBSyxJQUFJLEtBQUssS0FBSyxJQUFJO0FBQUEsTUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsTUFBTTtBQUNKLFlBQUksS0FBSyxlQUFlLEtBQUs7QUFBUTtBQUNyQyxhQUFLLElBQUksTUFBTTtBQUNmLGFBQUssTUFBTTtBQUNYLDhCQUFLLGtDQUFMLFdBQW9CLEtBQUs7QUFBQSxNQUMzQjtBQUFBLElBNkVGO0FBMUVFO0FBQUEsdUJBQWMsU0FBQyxPQUFPO0FBQ3BCLFlBQU0sUUFBUSxJQUFJLFlBQVksa0JBQWtCO0FBQ2hELFlBQU0sYUFBYTtBQUNuQixXQUFLLGFBQWE7QUFDbEIsV0FBSyxjQUFjLEtBQUs7QUFBQSxJQUMxQjtBQUNBO0FBQUEseUJBQWdCLFNBQUMsR0FBRztBQUNsQixZQUFNLFFBQVEsSUFBSSxZQUFZLE9BQU87QUFDckMsWUFBTSxPQUFPLEVBQUUsY0FBYztBQUM3QixXQUFLLGNBQWMsS0FBSztBQUN4QixXQUFLLElBQUk7QUFBQSxJQUNYO0FBQ0E7QUFBQSx1QkFBYyxTQUFDLEdBQUc7QUFDaEIsWUFBTSxRQUFRLElBQUksWUFBWSxPQUFPO0FBQ3JDLFdBQUssSUFBSTtBQUFBLElBQ1g7QUFDQTtBQUFBLDBCQUFpQixTQUFDLEdBQUc7QUFDbkIsVUFBSSxDQUFDLEtBQUs7QUFBSztBQUNmLFVBQUksS0FBSyxJQUFJLFdBQVcsS0FBSztBQUMzQiw4QkFBSyxzQ0FBTCxXQUFzQjtBQUN0QjtBQUFBLE1BQ0Y7QUFDQSxVQUFJLEtBQUssZUFBZSxLQUFLLFlBQVk7QUFDdkMsYUFBSyxjQUFjLElBQUksWUFBWSxNQUFNLENBQUM7QUFDMUMsOEJBQUssa0NBQUwsV0FBb0IsS0FBSztBQUFBLE1BQzNCO0FBQ0EsWUFBTSxPQUFPLEtBQUssSUFBSSxhQUFhLFVBQVUsS0FBSyxRQUFRO0FBQzFELFdBQUssWUFBWSxLQUFLO0FBRXRCLFdBQUssTUFBTSxlQUFlLEVBQUUsUUFBUSxDQUFDLFNBQVM7QUFDNUMsWUFBSSxLQUFLLEtBQUssRUFBRSxXQUFXLEdBQUc7QUFDNUIsZUFBSyxjQUFjLHNCQUFLLHNDQUFMLFdBQXNCLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDM0QsZUFBSyxRQUFRO0FBQUEsUUFDZixPQUFPO0FBQ0wsZUFBSyxTQUFTO0FBQUEsUUFDaEI7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQ0E7QUFBQSx3QkFBZSxTQUFDLEdBQUc7QUFDakIsNEJBQUssd0NBQUwsV0FBdUI7QUFDdkIsV0FBSyxjQUFjLHNCQUFLLHNDQUFMLFdBQXNCLEtBQUssTUFBTTtBQUNwRCxXQUFLLFFBQVE7QUFBQSxJQUNmO0FBQ0E7QUFBQSx5QkFBZ0IsU0FBQyxPQUFPO0FBQ3RCLFVBQUksQ0FBQyxTQUFTLE1BQU0sV0FBVztBQUFHLGVBQU87QUFDekMsWUFBTSxJQUFJLEVBQUUsSUFBSSxNQUFNLE9BQU8sTUFBTSxNQUFNLElBQUksT0FBTyxXQUFXLE1BQU0sR0FBRztBQUN4RSxZQUFNLE1BQU0sY0FBYyxFQUFFLFFBQVEsQ0FBQyxTQUFTO0FBRTVDLGVBQU8sS0FBSyxLQUFLO0FBQ2pCLGNBQU0sUUFBUSxLQUFLLFFBQVEsS0FBSyxlQUFlO0FBQy9DLFlBQUksU0FBUztBQUFHO0FBR2hCLGNBQU0sUUFBUSxLQUFLLFVBQVUsR0FBRyxLQUFLLEVBQUUsUUFBUSxVQUFVLEVBQUU7QUFDM0QsWUFBRyxDQUFDLENBQUMsTUFBTSxTQUFTLFFBQVEsU0FBUyxNQUFNLEVBQUUsU0FBUyxLQUFLO0FBQUc7QUFHOUQsY0FBTSxRQUFRLEtBQUssVUFBVSxRQUFRLENBQUMsRUFBRSxLQUFLLEVBQUUsUUFBUSxVQUFVLEVBQUU7QUFHbkUsVUFBRSxRQUFRO0FBQUEsTUFDWixDQUFDO0FBQ0QsVUFBSSxFQUFFO0FBQUksYUFBSyxnQkFBZ0IsRUFBRTtBQUNqQyxZQUFNLFFBQVEsSUFBSSxZQUFZLEVBQUUsU0FBUyxTQUFTO0FBQ2xELFlBQU0sS0FBSyxFQUFFO0FBQ2IsWUFBTSxPQUFPLEVBQUUsUUFBUTtBQUN2QixZQUFNLGdCQUFnQixLQUFLO0FBQzNCLGFBQU87QUFBQSxJQUNUO0FBQ0E7QUFBQSwyQkFBa0IsV0FBRztBQUNuQixVQUFJLENBQUMsS0FBSztBQUFLO0FBQ2YsVUFBSSxLQUFLLElBQUksZUFBZSxlQUFlO0FBQU0sOEJBQUssa0NBQUwsV0FBb0IsS0FBSztBQUFBLElBQzVFO0FBSUYsWUFBUSxnQkFBZ0I7QUFBQTtBQUFBOzs7QUNwTHhCO0FBQUE7QUFBQSxtQkFBZSwyQkFBMkI7QUFDeEMsVUFBSTtBQUNGLGNBQU0sV0FBVyxNQUFNLE1BQU0scUNBQXFDO0FBQ2xFLFlBQUksQ0FBQyxTQUFTLElBQUk7QUFDaEIsZ0JBQU0sSUFBSSxNQUFNLDZCQUE2QjtBQUFBLFFBQy9DO0FBQ0EsY0FBTSxPQUFPLE1BQU0sU0FBUyxLQUFLO0FBQ2pDLGdCQUFRLElBQUkseUJBQXlCLElBQUk7QUFDekMsZUFBTyxLQUFLLEtBRVQsSUFBSSxZQUFVO0FBQUEsVUFDYixZQUFZLE1BQU07QUFBQSxVQUNsQixLQUFLLE1BQU07QUFBQSxVQUNYLGtCQUFrQixNQUFNO0FBQUEsVUFDeEIsYUFBYSxNQUFNO0FBQUEsVUFDbkIsU0FBUyxNQUFNLFlBQVksU0FBUyxVQUFVLEtBQUssTUFBTSxZQUFZLFNBQVMsZUFBZTtBQUFBLFVBQzdGLFlBQVksTUFBTSxhQUFhLGFBQWE7QUFBQSxVQUM1QyxLQUFLO0FBQUEsUUFDUCxFQUFFO0FBQUEsTUFFTixTQUFTLE9BQVA7QUFDQSxnQkFBUSxNQUFNLCtCQUErQixLQUFLO0FBQ2xELGVBQU8sQ0FBQztBQUFBLE1BQ1Y7QUFBQSxJQUNGO0FBQ0EsWUFBUSwyQkFBMkI7QUFBQTtBQUFBOzs7QUN6Qm5DO0FBQUE7QUFBQSxRQUFNLGdCQUFnQjtBQUFBLE1BQ3BCLHNCQUFzQjtBQUFBLFFBQ3BCLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSxzQkFBc0I7QUFBQSxRQUNwQixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsTUFDYjtBQUFBLE1BQ0Esc0JBQXNCO0FBQUEsUUFDcEIsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLE1BQ2I7QUFBQSxNQUNBLHNCQUFzQjtBQUFBLFFBQ3BCLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSxxQkFBcUI7QUFBQSxRQUNuQixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsTUFDYjtBQUFBLE1BQ0EsMEJBQTBCO0FBQUEsUUFDeEIsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLE1BQ2I7QUFBQSxNQUNBLHNCQUFzQjtBQUFBLFFBQ3BCLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSxjQUFjO0FBQUEsUUFDWixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsTUFDYjtBQUFBLE1BQ0EsY0FBYztBQUFBLFFBQ1osV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLE1BQ2I7QUFBQSxNQUNBLHNCQUFzQjtBQUFBLFFBQ3BCLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSw2QkFBNkI7QUFBQSxRQUMzQixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsTUFDYjtBQUFBLE1BQ0Esa0JBQWtCO0FBQUEsUUFDaEIsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLE1BQ2I7QUFBQSxNQUNBLGtCQUFrQjtBQUFBLFFBQ2hCLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSwwQkFBMEI7QUFBQSxRQUN4QixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsTUFDYjtBQUFBLE1BQ0EsdUJBQXVCO0FBQUEsUUFDckIsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLE1BQ2I7QUFBQSxNQUNBLHdCQUF3QjtBQUFBLFFBQ3RCLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSxpQkFBaUI7QUFBQSxRQUNmLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSxlQUFlO0FBQUEsUUFDYixXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsTUFDYjtBQUFBLE1BQ0EsYUFBYTtBQUFBLFFBQ1gsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLE1BQ2I7QUFBQSxNQUNBLFVBQVU7QUFBQSxRQUNSLFdBQVc7QUFBQSxRQUNYLFdBQVc7QUFBQSxNQUNiO0FBQUEsTUFDQSxTQUFTO0FBQUEsUUFDUCxXQUFXO0FBQUEsUUFDWCxXQUFXO0FBQUEsTUFDYjtBQUFBLElBQ0Y7QUFDQSxtQkFBZSxvQkFBb0IsU0FBUztBQUMxQyxVQUFJLENBQUMsU0FBUztBQUNaLGdCQUFRLE1BQU0scUJBQXFCO0FBQ25DLGVBQU8sQ0FBQztBQUFBLE1BQ1Y7QUFDQSxVQUFJO0FBQ0YsY0FBTSxXQUFXLE1BQU0sTUFBTSxvQ0FBb0M7QUFBQSxVQUMvRCxTQUFTO0FBQUEsWUFDUCxpQkFBaUIsVUFBVTtBQUFBLFVBQzdCO0FBQUEsUUFDRixDQUFDO0FBQ0QsWUFBSSxDQUFDLFNBQVMsSUFBSTtBQUNoQixnQkFBTSxJQUFJLE1BQU0sNkJBQTZCO0FBQUEsUUFDL0M7QUFDQSxjQUFNLE9BQU8sTUFBTSxTQUFTLEtBQUs7QUFDakMsZ0JBQVEsSUFBSSx5QkFBeUIsSUFBSTtBQUN6QyxlQUFPLEtBQUssS0FDVCxPQUFPLFdBQVMsTUFBTSxHQUFHLFdBQVcsTUFBTSxLQUFLLENBQUMsTUFBTSxHQUFHLFNBQVMsV0FBVyxDQUFDLEVBQzlFLElBQUksV0FBUztBQUNaLGdCQUFNLE1BQU07QUFBQSxZQUNWLFlBQVksTUFBTTtBQUFBLFlBQ2xCLEtBQUssTUFBTTtBQUFBLFlBQ1gsWUFBWSxNQUFNLEdBQUcsU0FBUyxRQUFRLEtBQUssTUFBTSxHQUFHLFNBQVMsYUFBYTtBQUFBLFVBQzVFO0FBQ0EsZ0JBQU0sSUFBSSxPQUFPLFFBQVEsYUFBYSxFQUFFLEtBQUssQ0FBQUMsT0FBS0EsR0FBRSxDQUFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sR0FBRyxXQUFXQSxHQUFFLENBQUMsSUFBSSxHQUFHLENBQUM7QUFDdEcsY0FBRyxHQUFHO0FBQ0osZ0JBQUksbUJBQW1CLEVBQUUsQ0FBQyxFQUFFO0FBQzVCLGdCQUFJLGNBQWMsWUFBWSxFQUFFLENBQUMsRUFBRSxvQkFBb0IsRUFBRSxDQUFDLEVBQUU7QUFBQSxVQUM5RDtBQUNBLGlCQUFPO0FBQUEsUUFDVCxDQUFDO0FBQUEsTUFFTCxTQUFTLE9BQVA7QUFDQSxnQkFBUSxNQUFNLCtCQUErQixLQUFLO0FBQ2xELGVBQU8sQ0FBQztBQUFBLE1BQ1Y7QUFBQSxJQUNGO0FBQ0EsWUFBUSxzQkFBc0I7QUFBQTtBQUFBOzs7QUMzSDlCO0FBQUE7QUFBQSxtQkFBZSwyQkFBMkIsU0FBUztBQUNqRCxVQUFJLENBQUMsU0FBUztBQUNaLGdCQUFRLE1BQU0scUJBQXFCO0FBQ25DLGVBQU8sQ0FBQztBQUFBLE1BQ1Y7QUFDQSxVQUFJO0FBQ0YsY0FBTSxXQUFXLE1BQU0sTUFBTSxpRUFBaUUsT0FBTztBQUNyRyxZQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxRQUMvQztBQUNBLGNBQU0sT0FBTyxNQUFNLFNBQVMsS0FBSztBQUNqQyxnQkFBUSxJQUFJLHlCQUF5QixJQUFJO0FBQ3pDLGVBQU8sS0FBSyxPQUNULE9BQU8sV0FBUyxNQUFNLEtBQUssV0FBVyxlQUFlLENBQUMsRUFDdEQsSUFBSSxXQUFTO0FBQ1osZ0JBQU0sTUFBTTtBQUFBLFlBQ1YsWUFBWSxNQUFNLEtBQUssTUFBTSxHQUFHLEVBQUUsSUFBSTtBQUFBLFlBQ3RDLEtBQUssTUFBTSxLQUFLLE1BQU0sR0FBRyxFQUFFLElBQUk7QUFBQSxZQUMvQixrQkFBa0IsTUFBTTtBQUFBLFlBQ3hCLG1CQUFtQixNQUFNO0FBQUEsWUFDekIsYUFBYSxNQUFNO0FBQUEsWUFDbkIsWUFBWSxNQUFNLEtBQUssU0FBUyxRQUFRLEtBQUssTUFBTSxZQUFZLFNBQVMsWUFBWTtBQUFBLFlBQ3BGLEtBQUs7QUFBQSxVQUNQO0FBQ0EsaUJBQU87QUFBQSxRQUNULENBQUM7QUFBQSxNQUNMLFNBQVMsT0FBUDtBQUNBLGdCQUFRLE1BQU0sK0JBQStCLEtBQUs7QUFDbEQsZUFBTyxDQUFDO0FBQUEsTUFDVjtBQUFBLElBQ0Y7QUFDQSxZQUFRLDZCQUE2QjtBQUFBO0FBQUE7OztBQy9CckMsSUFBQUMsa0JBQUE7QUFBQTtBQUtBLG1CQUFlLG9CQUFvQixTQUFTO0FBQzFDLFVBQUksQ0FBQyxTQUFTO0FBQ1osZ0JBQVEsTUFBTSxxQkFBcUI7QUFDbkMsZUFBTyxDQUFDO0FBQUEsTUFDVjtBQUNBLFVBQUk7QUFDRixjQUFNLFdBQVcsTUFBTSxNQUFNLG1DQUFtQztBQUFBLFVBQzlELFNBQVM7QUFBQSxZQUNQLGlCQUFpQixVQUFVO0FBQUEsVUFDN0I7QUFBQSxRQUNGLENBQUM7QUFDRCxZQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFBQSxRQUMvQztBQUNBLGNBQU0sT0FBTyxNQUFNLFNBQVMsS0FBSztBQUNqQyxnQkFBUSxJQUFJLHlCQUF5QixJQUFJO0FBQ3pDLGVBQU8sS0FBSyxPQUNULE9BQU8sV0FBUyxNQUFNLEtBQUssV0FBVyxVQUFVLENBQUMsRUFDakQsSUFBSSxXQUFTO0FBQ1osZ0JBQU0sTUFBTTtBQUFBLFlBQ1YsWUFBWSxNQUFNO0FBQUEsWUFDbEIsS0FBSyxNQUFNO0FBQUEsWUFDWCxrQkFBa0IsTUFBTTtBQUFBLFlBQ3hCLGVBQWUsTUFBTTtBQUFBLFlBQ3JCLFdBQVcsTUFBTTtBQUFBLFlBQ2pCLGFBQWEscUJBQXFCLE1BQU0sOEJBQThCLE1BQU07QUFBQSxVQUM5RTtBQUNBLGlCQUFPO0FBQUEsUUFDVCxDQUFDO0FBQUEsTUFDTCxTQUFTLE9BQVA7QUFDQSxnQkFBUSxNQUFNLCtCQUErQixLQUFLO0FBQ2xELGVBQU8sQ0FBQztBQUFBLE1BQ1Y7QUFBQSxJQUNGO0FBQ0EsWUFBUSxzQkFBc0I7QUFBQTtBQUFBOzs7QUN2QzlCLElBQUFDLHFCQUFBO0FBQUE7QUFDQSxtQkFBZSx5QkFBeUI7QUFDdEMsYUFBTztBQUFBLFFBQUM7QUFBQSxVQUNOLE9BQU87QUFBQSxVQUNQLGNBQWM7QUFBQSxVQUNkLGVBQWU7QUFBQSxVQUNmLG9CQUFvQjtBQUFBLFVBQ3BCLHFCQUFxQjtBQUFBLFVBQ3JCLGNBQWM7QUFBQSxRQUNoQjtBQUFBLFFBQ0E7QUFBQSxVQUNFLEtBQUs7QUFBQSxVQUNMLGNBQWM7QUFBQSxVQUNkLGVBQWU7QUFBQSxVQUNmLG9CQUFvQjtBQUFBLFVBQ3BCLHFCQUFxQjtBQUFBLFVBQ3JCLGNBQWM7QUFBQSxRQUNoQjtBQUFBLFFBQ0E7QUFBQSxVQUNFLEtBQUs7QUFBQSxVQUNMLGNBQWM7QUFBQSxVQUNkLGVBQWU7QUFBQSxVQUNmLG9CQUFvQjtBQUFBLFVBQ3BCLHFCQUFxQjtBQUFBLFVBQ3JCLGNBQWM7QUFBQSxRQUNoQjtBQUFBLE1BQUM7QUFBQSxJQUNIO0FBQ0EsWUFBUSx5QkFBeUI7QUFBQTtBQUFBOzs7QUMzQmpDO0FBQUE7QUFBQSxRQUFNLEVBQUUseUJBQXlCLElBQUk7QUFDckMsUUFBTSxFQUFFLG9CQUFvQixJQUFJO0FBQ2hDLFFBQU0sRUFBRSwyQkFBMkIsSUFBSTtBQUN2QyxRQUFNLEVBQUUsb0JBQW9CLElBQUk7QUFDaEMsUUFBTSxFQUFFLHVCQUF1QixJQUFJO0FBQ25DLFlBQVEsY0FBYztBQUN0QixZQUFRLFNBQVM7QUFDakIsWUFBUSxnQkFBZ0I7QUFDeEIsWUFBUSxTQUFTO0FBQ2pCLFlBQVEsWUFBWTtBQUFBO0FBQUE7OztBQ1RwQjtBQUFBO0FBcUJBLFFBQU0sV0FBVztBQUNqQixRQUFNLFlBQVk7QUFDbEIsUUFBTSxFQUFFLG1CQUFtQixJQUFJO0FBQy9CLFFBQU0sRUFBRSxjQUFjLElBQUk7QUFDMUIsUUFBTSxlQUFlO0FBS3JCLFFBQU1DLGtCQUFOLE1BQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPbkIsWUFBWSxNQUFNLGNBQWMsZUFBYSxDQUFDLEdBQUc7QUFDL0MsYUFBSyxNQUFNO0FBQ1gsYUFBSyxPQUFPLEtBQUs7QUFDakIsYUFBSyxTQUFTO0FBQUEsVUFDWixHQUFJLFVBQVUsWUFBWSxLQUFLLENBQUM7QUFBQSxVQUNoQyxHQUFHO0FBQUE7QUFBQSxRQUNMO0FBQ0EsYUFBSyxlQUFlO0FBQ3BCLGFBQUssZ0JBQWdCO0FBQ3JCLGFBQUssbUJBQW1CO0FBQ3hCLGFBQUssWUFBWTtBQUNqQixZQUFHLEtBQUssT0FBTztBQUFTLGVBQUssVUFBVSxJQUFJLFNBQVMsS0FBSyxPQUFPLE9BQU8sRUFBRSxJQUFJO0FBQzdFLGdCQUFRLElBQUksS0FBSyxPQUFPO0FBQUEsTUFDMUI7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUFFLGVBQU87QUFBQSxNQUFXO0FBQUEsTUFDeEMsSUFBSSxlQUFlO0FBQ2pCLGVBQU87QUFBQSxVQUNMLGFBQWE7QUFBQSxVQUNiLE9BQU87QUFBQSxVQUNQLGtCQUFrQjtBQUFBLFVBQ2xCLG1CQUFtQjtBQUFBLFVBQ25CLEdBQUc7QUFBQSxVQUNILE9BQU8sS0FBSztBQUFBLFVBQ1osWUFBWSxLQUFLO0FBQUEsUUFDbkI7QUFBQSxNQUNGO0FBQUEsTUFDQSxNQUFNLG9CQUFvQixNQUFNO0FBQUUsZUFBTztBQUFBLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTL0MsTUFBTSxTQUFTLE9BQUssQ0FBQyxHQUFHLFNBQU8sTUFBTTtBQXhFdkM7QUF5RUksWUFBRyxDQUFDLEtBQUssbUJBQWtCO0FBQ3pCLGVBQUssb0JBQW9CLE1BQU0sS0FBSyxzQkFBc0I7QUFDMUQsZUFBSyxTQUFTO0FBQUEsWUFDWixHQUFHLEtBQUs7QUFBQSxZQUNSLEdBQUcsS0FBSztBQUFBLFVBQ1Y7QUFBQSxRQUNGO0FBQ0EsZUFBTztBQUFBLFVBQ0wsR0FBRyxLQUFLO0FBQUEsVUFDUixZQUFXLGFBQU0sVUFBSyxZQUFMLG1CQUFjLG1CQUFwQixtQkFBb0MsYUFBWSxDQUFDO0FBQUEsVUFDNUQsR0FBRztBQUFBLFFBQ0w7QUFDQSxZQUFHLEtBQUssV0FBVyxTQUFTLEtBQUssT0FBTyxhQUFhLEdBQUMsVUFBSyxZQUFMLG1CQUFjO0FBQWEsZUFBSyxTQUFTO0FBQUE7QUFDMUYsZUFBSyxTQUFTO0FBQ25CLGVBQU8sTUFBTSxLQUFLLG9CQUFvQixLQUFLLE1BQU0sS0FBSyxVQUFVLElBQUksQ0FBQyxDQUFDO0FBQ3RFLGNBQU0sTUFBTTtBQUFBLFVBQ1YsU0FBUztBQUFBLFlBQ1AsZ0JBQWdCO0FBQUEsWUFDaEIsZUFBZSxVQUFVLEtBQUs7QUFBQSxVQUNoQztBQUFBLFVBQ0EsUUFBUTtBQUFBLFFBQ1Y7QUFDQSxZQUFJLEtBQUssT0FBTztBQUFTLGNBQUksVUFBVSxFQUFFLEdBQUcsSUFBSSxTQUFTLEdBQUcsS0FBSyxPQUFPLFFBQVE7QUFDaEYsWUFBSSxLQUFLLE9BQU8sZ0JBQWdCO0FBQzlCLGNBQUcsS0FBSyxPQUFPLG1CQUFtQjtBQUFRLGdCQUFJLFFBQVEsS0FBSyxPQUFPLGNBQWMsSUFBSSxLQUFLO0FBQ3pGLGlCQUFPLElBQUksUUFBUTtBQUFBLFFBQ3JCO0FBRUEsY0FBTSxPQUFPLFNBQU8sVUFBSyxJQUFJLFlBQVQsbUJBQWtCLDBCQUF5QixhQUFhLEtBQUssSUFBSSxRQUFRLHFCQUFxQixJQUFJLElBQUksRUFBRSxHQUFHLEtBQUs7QUFFcEksWUFBSSxPQUFPLEtBQUssVUFBVSxTQUFPLFVBQUssWUFBTCxtQkFBYywwQkFBeUIsYUFBYSxLQUFLLFFBQVEscUJBQXFCLElBQUksSUFBSSxJQUFJO0FBQ25JLGdCQUFRLElBQUksR0FBRztBQUNmLFlBQUk7QUFDRixjQUFHLEtBQUs7QUFBUSxtQkFBTyxNQUFNLEtBQUssT0FBTyxHQUFHO0FBRTVDLGdCQUFNLFlBQVksTUFBTSxLQUFLLFFBQVEsR0FBRztBQUN4QyxjQUFHLFVBQVUsT0FBTztBQUNsQixvQkFBUSxNQUFNLFVBQVUsS0FBSztBQUM3QixnQkFBRztBQUFRLG1CQUFLLGFBQWEsNENBQTRDO0FBQ3pFO0FBQUEsVUFDRjtBQUVBLGdCQUFNLFlBQVksS0FBSyxjQUFjLFNBQVM7QUFDOUMsY0FBRyxXQUFVO0FBQ1gsaUJBQUssSUFBSSxNQUFNLFFBQVEsY0FBYztBQUVyQyxrQkFBTSxZQUFZLEtBQUssY0FBYyxTQUFTO0FBQzlDLGtCQUFNLG9CQUFvQixLQUFLLHNCQUFzQixTQUFTO0FBQzlELGtCQUFNLE9BQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxNQUFNLEVBQUUsU0FBUyxTQUFTLFNBQVM7QUFDakUsZ0JBQUcsbUJBQW1CLE1BQU0saUJBQWlCLEdBQUU7QUFDN0Msb0JBQU0sS0FBSyxRQUFRLFlBQVksRUFBRSxNQUFNLGFBQWEsWUFBWSxDQUFDO0FBQUEsZ0JBQy9ELFVBQVU7QUFBQSxrQkFDUixNQUFNO0FBQUEsa0JBQ04sV0FBVyxLQUFLLFVBQVUsaUJBQWlCO0FBQUEsZ0JBQzdDO0FBQUEsY0FDRixDQUFDLEVBQUUsQ0FBQztBQUNKLG9CQUFNLGVBQWUsS0FBSyxpQkFBaUIsU0FBUztBQUNwRCxrQkFBRyxDQUFDO0FBQWMsdUJBQU8sUUFBUSxNQUFNLFFBQVEscUJBQXFCO0FBQ3BFLG9CQUFNLGNBQWMsTUFBTSxhQUFhLEtBQUssS0FBSyxpQkFBaUI7QUFDbEUsa0JBQUcsYUFBYTtBQUNkLHNCQUFNLEtBQUssUUFBUSxnQkFBZ0IsV0FBVyxXQUFXO0FBQ3pELHFCQUFLLFFBQVEsY0FBYztBQUMzQix1QkFBTyxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsY0FDekI7QUFBQSxZQUNGLE9BQUs7QUFFSCxzQkFBUSxNQUFNLHNCQUFzQixXQUFXO0FBQy9DLGtCQUFHO0FBQVEscUJBQUssYUFBYSxvREFBb0Q7QUFDakYscUJBQU87QUFBQSxZQUNUO0FBQUEsVUFDRjtBQUVBLGNBQUc7QUFBUSxpQkFBSyxhQUFhLEtBQUssb0JBQW9CLFNBQVMsQ0FBQztBQUNoRSxpQkFBTyxLQUFLLG9CQUFvQixTQUFTO0FBQUEsUUFFM0MsU0FBUyxLQUFQO0FBQ0Esa0JBQVEsTUFBTSxHQUFHO0FBQUEsUUFFbkI7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsaUJBQWlCLFdBQVc7QUFBRSxlQUFPLEtBQUssSUFBSSxRQUFRLFFBQVEsU0FBUyxFQUFFO0FBQUEsTUFBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTbEYsY0FBYyxNQUFNO0FBMUt0QjtBQTJLSSxZQUFHLFNBQU8sVUFBSyxZQUFMLG1CQUFjLG1CQUFrQjtBQUFZLGlCQUFPLEtBQUssUUFBUSxjQUFjLElBQUk7QUFDNUYsZ0JBQU8sZ0JBQUssWUFBTCxtQkFBZSxHQUFHLFFBQVEsZUFBMUIsbUJBQXVDO0FBQUEsTUFDaEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsY0FBYyxXQUFXO0FBdEwzQjtBQXVMSSxZQUFHLFNBQU8sVUFBSyxZQUFMLG1CQUFjLG1CQUFrQjtBQUFZLGlCQUFPLEtBQUssUUFBUSxjQUFjLFNBQVM7QUFDakcsZUFBTyxVQUFVLFNBQVM7QUFBQSxNQUM1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxzQkFBc0IsV0FBVztBQWxNbkM7QUFtTUksWUFBRyxTQUFPLFVBQUssWUFBTCxtQkFBYywyQkFBMEI7QUFBWSxpQkFBTyxLQUFLLFFBQVEsc0JBQXNCLFNBQVM7QUFDakgsZUFBTyxLQUFLLE1BQU0sVUFBVSxTQUFTLFNBQVM7QUFBQSxNQUNoRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLFlBQVksTUFBTTtBQS9NcEI7QUFnTkksWUFBRyxTQUFPLFVBQUssWUFBTCxtQkFBYyxpQkFBZ0I7QUFBWSxpQkFBTyxLQUFLLFFBQVEsWUFBWSxJQUFJO0FBQ3hGLGlCQUFPLFVBQUssWUFBTCxtQkFBZSxHQUFHLFlBQVcsS0FBSztBQUFBLE1BQzNDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLG9CQUFvQixNQUFNO0FBM041QjtBQTROSSxZQUFHLFNBQU8sVUFBSyxZQUFMLG1CQUFjLHlCQUF3QjtBQUFZLGlCQUFPLEtBQUssUUFBUSxvQkFBb0IsSUFBSTtBQUN4RyxlQUFPLEtBQUssWUFBWSxJQUFJLEVBQUU7QUFBQSxNQUNoQztBQUFBLE1BRUEsTUFBTSxRQUFRLEtBQUk7QUFDaEIsWUFBSSxNQUFNLEtBQUs7QUFDZixZQUFJLFFBQVE7QUFFWixjQUFNLE9BQU8sS0FBSyxtQkFBbUIsTUFBTSxLQUFLLGlCQUFpQixHQUFHLElBQUksTUFBTSxNQUFNLEtBQUssVUFBVSxHQUFHO0FBQ3RHLGdCQUFRLElBQUksSUFBSTtBQUNoQixjQUFNLFlBQVksTUFBTSxLQUFLLGNBQWMsSUFBSTtBQUMvQyxnQkFBUSxJQUFJLFNBQVM7QUFDckIsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLE1BQU0sY0FBYyxNQUFNO0FBQUUsZUFBUSxPQUFPLEtBQUssU0FBUyxhQUFjLE1BQU0sS0FBSyxLQUFLLElBQUksTUFBTSxLQUFLO0FBQUEsTUFBTTtBQUFBLE1BQzVHLElBQUksa0JBQWlCO0FBQUUsZUFBTyxLQUFLO0FBQUEsTUFBa0I7QUFBQSxNQUVyRCxNQUFNLE9BQU8sS0FBSztBQUNoQixnQkFBUSxJQUFJLHFCQUFxQjtBQUNqQyxnQkFBUSxJQUFJLEdBQUc7QUFDZixjQUFNLFlBQVksTUFBTSxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDdkQsY0FBSTtBQUVGLGlCQUFLLGdCQUFnQixJQUFJLGNBQWMsS0FBSyxvQkFBb0IsR0FBRztBQUNuRSxnQkFBSSxZQUFZO0FBQ2hCLGlCQUFLLGNBQWMsaUJBQWlCLFdBQVcsQ0FBQyxNQUFNO0FBQ3BELGtCQUFHLEtBQUssaUJBQWlCLENBQUMsR0FBRztBQUMzQixxQkFBSyxZQUFZO0FBQ2pCLHVCQUFPLFFBQVEsU0FBUztBQUFBLGNBQzFCO0FBQ0Esa0JBQUksYUFBYSxLQUFLLDJCQUEyQixDQUFDO0FBQ2xELGtCQUFHLENBQUM7QUFBWTtBQUNoQiwyQkFBYTtBQUNiLG1CQUFLLGNBQWMsVUFBVTtBQUFBLFlBQy9CLENBQUM7QUFFRCxpQkFBSyxjQUFjLGlCQUFpQixvQkFBb0IsQ0FBQyxNQUFNO0FBQzdELGtCQUFJLEVBQUUsY0FBYztBQUFHLHdCQUFRLElBQUksaUJBQWlCLEVBQUUsVUFBVTtBQUFBLFlBQ2xFLENBQUM7QUFDRCxpQkFBSyxjQUFjLGlCQUFpQixTQUFTLENBQUMsTUFBTTtBQUNsRCxzQkFBUSxNQUFNLENBQUM7QUFDZixtQkFBSyxhQUFhLDRDQUE0QztBQUM5RCxtQkFBSyxZQUFZO0FBQ2pCLHFCQUFPLENBQUM7QUFBQSxZQUNWLENBQUM7QUFDRCxpQkFBSyxjQUFjLE9BQU87QUFBQSxVQUM1QixTQUFTLEtBQVA7QUFDQSxvQkFBUSxNQUFNLEdBQUc7QUFDakIsaUJBQUssWUFBWTtBQUNqQixtQkFBTyxHQUFHO0FBQUEsVUFDWjtBQUFBLFFBQ0YsQ0FBQztBQUNELGFBQUssYUFBYSxTQUFTO0FBQzNCLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFDQSwyQkFBMkIsT0FBTztBQW5ScEM7QUFvUkksWUFBRyxTQUFPLFVBQUssWUFBTCxtQkFBYyxnQ0FBK0I7QUFBWSxpQkFBTyxLQUFLLFFBQVEsMkJBQTJCLEtBQUs7QUFDdkgsWUFBSSxPQUFPO0FBQ1gsWUFBSSxhQUFhO0FBRWpCLFlBQUk7QUFDRixpQkFBTyxLQUFLLE1BQU0sTUFBTSxJQUFJO0FBQzVCLHVCQUFhLEtBQUssUUFBUSxDQUFDLEVBQUUsTUFBTTtBQUFBLFFBQ3JDLFNBQVMsS0FBUDtBQUNBLGtCQUFRLElBQUksR0FBRztBQUNmLGtCQUFRLElBQUksTUFBTSxJQUFJO0FBQ3RCLGNBQUksTUFBTSxLQUFLLFFBQVEsSUFBSSxJQUFJO0FBQUksa0JBQU0sT0FBTyxNQUFNLEtBQUssUUFBUSxPQUFPLEtBQUs7QUFDL0UsaUJBQU8sS0FBSyxNQUFNLElBQUksTUFBTSxPQUFPO0FBQ25DLGVBQUssUUFBUSxDQUFDLE1BQU07QUFDbEIsZ0JBQUksRUFBRTtBQUFTLDRCQUFjLEVBQUUsUUFBUSxDQUFDLEVBQUUsTUFBTTtBQUFBLFVBQ2xELENBQUM7QUFBQSxRQUNIO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLGlCQUFpQixPQUFPO0FBdFMxQjtBQXVTSSxZQUFHLFNBQU8sVUFBSyxZQUFMLG1CQUFjLHNCQUFxQjtBQUFZLGlCQUFPLEtBQUssUUFBUSxpQkFBaUIsS0FBSztBQUNuRyxlQUFPLE1BQU0sU0FBUztBQUFBLE1BQ3hCO0FBQUEsTUFFQSxjQUFjO0FBQ1osWUFBSSxLQUFLLGVBQWU7QUFDdEIsZUFBSyxjQUFjLElBQUk7QUFDdkIsZUFBSyxnQkFBZ0I7QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLGFBQWEsVUFBVTtBQUlyQixZQUFHLE9BQU8sS0FBSyxLQUFLLGlCQUFpQjtBQUFZLGVBQUssS0FBSyxhQUFhLFFBQVE7QUFBQSxNQUNsRjtBQUFBLE1BQ0EsY0FBYyxZQUFZO0FBR3hCLFlBQUcsT0FBTyxLQUFLLEtBQUssa0JBQWtCO0FBQVksZUFBSyxLQUFLLGNBQWMsVUFBVTtBQUFBLE1BQ3RGO0FBQUEsTUFDQSxNQUFNLGFBQWEsT0FBTztBQTVUNUI7QUE2VEksWUFBRyxTQUFPLFVBQUssWUFBTCxtQkFBYyxrQkFBaUI7QUFBWSxpQkFBTyxNQUFNLEtBQUssUUFBUSxhQUFhLEtBQUs7QUFDakcsZUFBTyxLQUFLLGdCQUFnQixLQUFLO0FBQUEsTUFDbkM7QUFBQSxNQUNBLGdCQUFnQixPQUFPO0FBaFV6QjtBQWlVSSxZQUFHLFNBQU8sVUFBSyxZQUFMLG1CQUFjLHFCQUFvQjtBQUFZLGlCQUFPLEtBQUssUUFBUSxnQkFBZ0IsS0FBSztBQUNqRyxZQUFHLE9BQU8sVUFBVTtBQUFVLGtCQUFRLEtBQUssVUFBVSxLQUFLO0FBQzFELGVBQU8sTUFBTSxTQUFTO0FBQUEsTUFDeEI7QUFBQSxNQUNBLE1BQU0sZUFBZTtBQUNuQixnQkFBUSxJQUFJLEtBQUssT0FBTztBQUN4QixZQUFHO0FBQ0QsZ0JBQU0sVUFBVTtBQUFBLFlBQ2QsVUFBVTtBQUFBLGNBQ1IsRUFBRSxNQUFNLFFBQVEsU0FBUyxRQUFRO0FBQUEsWUFDbkM7QUFBQSxZQUNBLGFBQWE7QUFBQSxZQUNiLFlBQVk7QUFBQSxZQUNaLFFBQVE7QUFBQSxZQUNSLEdBQUc7QUFBQSxVQUNMO0FBQ0EsY0FBRyxLQUFLLE9BQU8sY0FBYztBQUMzQixvQkFBUSxRQUFRLEtBQUssT0FBTztBQUFBLFVBQzlCO0FBQ0EsZ0JBQU0sT0FBTyxNQUFNLEtBQUssU0FBUyxTQUFTLEtBQUs7QUFDL0Msa0JBQVEsSUFBSSxJQUFJO0FBQ2hCLGNBQUcsQ0FBQztBQUFNLG1CQUFPO0FBQ2pCLGlCQUFPO0FBQUEsUUFDVCxTQUFPLEtBQU47QUFDQyxrQkFBUSxNQUFNLEdBQUc7QUFDakIsaUJBQU87QUFBQSxRQUNUO0FBQUEsTUFDRjtBQUFBLE1BQ0EsTUFBTSxhQUFhO0FBN1ZyQjtBQStWSSxjQUFHLFVBQUssVUFBVSxLQUFLLFlBQVksTUFBaEMsbUJBQW1DLGlCQUFnQixPQUFPLGFBQWEsS0FBSyxZQUFZLE1BQU0sWUFBVztBQUMxRyxnQkFBTSxTQUFTLE1BQU0sYUFBYSxLQUFLLFlBQVksRUFBRSxLQUFLLE9BQU87QUFDakUsY0FBRyxRQUFRO0FBRVQsbUJBQU8sS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFdBQVcsY0FBYyxFQUFFLFVBQVUsQ0FBQztBQUM5RCxtQkFBTztBQUFBLFVBQ1Q7QUFBTSxvQkFBUSxNQUFNLHVCQUF1QixLQUFLLGdCQUFnQixNQUFNO0FBQUEsUUFDeEU7QUFDQSxlQUFPLENBQUM7QUFBQSxNQUNWO0FBQUEsTUFDQSxNQUFNLHdCQUF3QjtBQUM1QixjQUFNLFNBQVMsTUFBTSxLQUFLLFdBQVc7QUFDckMsZUFBTyxPQUFPLEtBQUssQ0FBQyxNQUFNLEVBQUUsUUFBUSxLQUFLLFVBQVU7QUFBQSxNQUNyRDtBQUFBO0FBQUEsTUFFQSxJQUFJLFVBQVU7QUFBRSxlQUFPLEtBQUssT0FBTztBQUFBLE1BQVM7QUFBQSxNQUM1QyxJQUFJLFVBQVU7QUEvV2hCO0FBK1drQixnQkFBTyxVQUFLLElBQUksVUFBVCxtQkFBZ0I7QUFBQSxNQUFTO0FBQUE7QUFBQSxNQUVoRCxJQUFJLFdBQVc7QUFqWGpCO0FBa1hJLFlBQUcsU0FBTyxVQUFLLFlBQUwsbUJBQWMsY0FBYTtBQUFhLGlCQUFPLEtBQUssUUFBUSxTQUFTLFFBQVEsY0FBYyxLQUFLLFVBQVU7QUFDcEgsZUFBTyxLQUFLLE9BQU8sWUFBWSxLQUFLLE9BQU8sV0FBVyxRQUFRLEtBQUssT0FBTyxZQUFZLEtBQUssT0FBTyxPQUFPLE1BQU0sS0FBSyxPQUFPLE9BQU8sTUFBTSxLQUFLO0FBQUEsTUFDL0k7QUFBQSxNQUNBLElBQUkscUJBQXFCO0FBclgzQjtBQXNYSSxZQUFHLFNBQU8sVUFBSyxZQUFMLG1CQUFjLHdCQUF1QjtBQUFhLGlCQUFPLEtBQUssUUFBUSxtQkFBbUIsUUFBUSxjQUFjLEtBQUssVUFBVTtBQUN4SSxlQUFPLEtBQUssT0FBTyxzQkFBc0IsS0FBSztBQUFBLE1BQ2hEO0FBQUEsTUFDQSxJQUFJLGdCQUFnQjtBQUFFLGVBQU8sS0FBSyxPQUFPLEtBQUssV0FBVyxHQUFHLElBQUksS0FBSyxPQUFPLE9BQU8sTUFBTSxLQUFLLE9BQU87QUFBQSxNQUFNO0FBQUEsTUFDM0csSUFBSSxtQkFBbUI7QUFBRSxlQUFPLEtBQUssT0FBTztBQUFBLE1BQWtCO0FBQUEsTUFDOUQsSUFBSSxvQkFBb0I7QUFBRSxlQUFPLEtBQUssT0FBTztBQUFBLE1BQW1CO0FBQUEsTUFDaEUsSUFBSSxhQUFhO0FBQUUsZUFBTyxLQUFLLE9BQU8sY0FBYyxLQUFLLE9BQU87QUFBQSxNQUFlO0FBQUEsTUFDL0UsSUFBSSxhQUFhO0FBN1huQjtBQTZYcUIsZUFBTyxTQUFPLFVBQUssWUFBTCxtQkFBYyxnQkFBZSxjQUFjLEtBQUssUUFBUSxhQUFhLEtBQUssT0FBTztBQUFBLE1BQVk7QUFBQSxJQUNoSTtBQUNBLFlBQVEsaUJBQWlCQTtBQUFBO0FBQUE7OztBQy9YekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLG1CQUFzTDs7O0FDQXRMLHNCQUErQjtBQUV4QixJQUFNLDZCQUFOLGNBQXlDLHNCQUFNO0FBQUE7QUFBQSxFQWNsRCxZQUFZLEtBQVUsc0JBQTZFO0FBQy9GLFVBQU0sR0FBRztBQWRiLFNBQVEsZ0JBQXNDO0FBQzlDLFNBQVEsU0FBcUIsQ0FBQztBQUk5QixTQUFRLGNBQXVCO0FBRS9CLFNBQVEsYUFBNEI7QUFDcEMsU0FBUSxZQUFvQjtBQUM1QixTQUFRLGNBQXNCO0FBRTlCLFNBQVEsY0FBdUI7QUFJM0IsU0FBSyx1QkFBdUI7QUFBQSxFQUNoQztBQUFBLEVBRUEsU0FBUztBQUNMLFVBQU0sRUFBRSxXQUFXLFFBQVEsSUFBSTtBQUUvQixRQUFJLENBQUMsYUFBYSxDQUFDLFNBQVM7QUFDeEIsY0FBUSxNQUFNLDhCQUE4QjtBQUM1QztBQUFBLElBQ0o7QUFHQSxZQUFRLFNBQVMsc0JBQXNCO0FBR3ZDLFVBQU0sdUJBQXVCLFVBQVUsVUFBVSxFQUFFLEtBQUssb0NBQW9DLENBQUM7QUFDN0YsVUFBTSxTQUFTLHFCQUFxQixTQUFTLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixLQUFLLDhCQUE4QixDQUFDO0FBQy9HLFNBQUssUUFBUSxxQkFBcUIsU0FBUyxPQUFPLEVBQUUsS0FBSyxvQkFBb0IsTUFBTSxRQUFRLENBQUM7QUFHNUYsY0FBVSxTQUFTLHVDQUF1QztBQUcxRCxVQUFNLGtCQUFrQixVQUFVLFVBQVUsRUFBRSxLQUFLLCtCQUErQixDQUFDO0FBQ25GLFNBQUssU0FBUyxnQkFBZ0IsVUFBVSxFQUFFLEtBQUsscUJBQXFCLENBQUM7QUFHckUsVUFBTSxzQkFBc0IsVUFBVSxVQUFVLEVBQUUsS0FBSyxtQ0FBbUMsQ0FBQztBQUMzRixVQUFNLGVBQWUsb0JBQW9CLFVBQVUsRUFBRSxLQUFLLGdDQUFnQyxDQUFDO0FBQzNGLFVBQU0sa0JBQWtCLGFBQWEsU0FBUyxVQUFVLEVBQUUsS0FBSywwQ0FBMEMsQ0FBQztBQUMxRyxVQUFNLGFBQWEsYUFBYSxTQUFTLFVBQVUsRUFBRSxLQUFLLDBDQUEwQyxDQUFDO0FBRXJHLGlDQUFRLGlCQUFpQixPQUFPO0FBQ2hDLGlDQUFRLFlBQVksUUFBUTtBQUU1QixlQUFXLGlCQUFpQixTQUFTLFlBQVk7QUFDN0MsWUFBTSxZQUFZLE1BQU0sS0FBSyxjQUFjO0FBQzNDLFdBQUsscUJBQXFCLFdBQVcsS0FBSztBQUFBLElBQzlDLENBQUM7QUFFRCxvQkFBZ0IsaUJBQWlCLFNBQVMsTUFBTTtBQUM1QyxVQUFJLEtBQUssYUFBYTtBQUNsQixhQUFLLGVBQWU7QUFDcEIscUNBQVEsaUJBQWlCLFFBQVE7QUFDakMsZUFBTyxjQUFjO0FBQ3JCLGdCQUFRLFNBQVMsbUJBQW1CO0FBQ3BDLGdCQUFRLFlBQVksc0JBQXNCO0FBQUEsTUFDOUMsT0FBTztBQUNILGFBQUssdUJBQXVCO0FBQzVCLHFDQUFRLGlCQUFpQixPQUFPO0FBQ2hDLGVBQU8sY0FBYztBQUNyQixnQkFBUSxZQUFZLG1CQUFtQjtBQUN2QyxnQkFBUSxTQUFTLHNCQUFzQjtBQUFBLE1BQzNDO0FBQ0EsV0FBSyxjQUFjLENBQUMsS0FBSztBQUFBLElBQzdCLENBQUM7QUFFRCxVQUFNLG1CQUFtQixvQkFBb0IsU0FBUyxVQUFVLEVBQUUsS0FBSyxvRkFBb0YsQ0FBQztBQUU1SixxQkFBaUIsaUJBQWlCLFNBQVMsWUFBWTtBQUNuRCxZQUFNLFlBQVksTUFBTSxLQUFLLGNBQWM7QUFDM0MsV0FBSyxxQkFBcUIsV0FBVyxJQUFJO0FBQUEsSUFDN0MsQ0FBQztBQUVELGlDQUFRLGtCQUFrQixXQUFXO0FBR3JDLFVBQU0sYUFBYSxTQUFTLGVBQWUsbUJBQW1CO0FBQzlELHFCQUFpQixZQUFZLFVBQVU7QUFHdkMsVUFBTSxhQUFhLGlCQUFpQixjQUFjLEtBQUs7QUFDdkQsUUFBSSxZQUFZO0FBQ1osaUJBQVcsTUFBTSxjQUFjO0FBQUEsSUFDbkM7QUFFQSxVQUFNLGNBQWMsVUFBVSxTQUFTLFVBQVUsRUFBRSxLQUFLLGdGQUFnRixNQUFNLFVBQVUsQ0FBQztBQUN6SixnQkFBWSxpQkFBaUIsU0FBUyxNQUFNO0FBQ3hDLFdBQUssVUFBVTtBQUNmLG1DQUFRLGlCQUFpQixRQUFRO0FBQ2pDLGFBQU8sY0FBYztBQUNyQixXQUFLLGNBQWM7QUFDbkIsY0FBUSxTQUFTLG1CQUFtQjtBQUNwQyxjQUFRLFlBQVksc0JBQXNCO0FBRTFDLFdBQUssT0FBTyxVQUFVLE9BQU8sNEJBQTRCO0FBQUEsSUFDN0QsQ0FBQztBQUdELFNBQUssZUFBZTtBQUNwQixTQUFLLGNBQWM7QUFDbkIsU0FBSyxPQUFPLFVBQVUsSUFBSSw0QkFBNEI7QUFHdEQsVUFBTSxnQkFBZ0IsU0FBUztBQUMvQixRQUFJLGVBQWU7QUFDZixvQkFBYyxLQUFLO0FBQUEsSUFDdkI7QUFBQSxFQUNKO0FBQUEsRUFFQSxpQkFBaUI7QUFDYixjQUFVLGFBQWEsYUFBYSxFQUFFLE9BQU8sS0FBSyxDQUFDLEVBQzlDLEtBQUssWUFBVTtBQUNaLFdBQUssZ0JBQWdCLElBQUksY0FBYyxNQUFNO0FBQzdDLFdBQUssbUJBQW1CO0FBQ3hCLFdBQUssY0FBYyxNQUFNLEdBQUk7QUFDN0IsV0FBSyxZQUFZLEtBQUssSUFBSTtBQUMxQixXQUFLLFdBQVc7QUFDaEIsV0FBSyxjQUFjLGlCQUFpQixpQkFBaUIsS0FBSyxnQkFBZ0IsS0FBSyxJQUFJLENBQUM7QUFBQSxJQUN4RixDQUFDLEVBQ0EsTUFBTSxXQUFTO0FBQ1osY0FBUSxNQUFNLCtCQUErQixLQUFLO0FBQ2xELFdBQUssT0FBTyxLQUFLO0FBQUEsSUFDckIsQ0FBQztBQUFBLEVBQ1Q7QUFBQSxFQUVBLHFCQUFxQjtBQUNqQixRQUFJLEtBQUssZUFBZTtBQUNwQixXQUFLLGNBQWMsaUJBQWlCLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSSxDQUFDO0FBQUEsSUFDdEU7QUFBQSxFQUNKO0FBQUEsRUFFQSxnQkFBZ0IsT0FBa0I7QUFDOUIsUUFBSSxLQUFLLGFBQWE7QUFDbEI7QUFBQSxJQUNKO0FBQ0EsU0FBSyxPQUFPLEtBQUssTUFBTSxJQUFJO0FBQUEsRUFDL0I7QUFBQSxFQUVBLFNBQVM7QUFDTCxRQUFJLEtBQUssYUFBYTtBQUNsQixXQUFLLGNBQWM7QUFDbkI7QUFBQSxJQUNKO0FBQ0EsVUFBTSxPQUFPLElBQUksS0FBSyxLQUFLLFFBQVEsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUN4RCxRQUFJLEtBQUssU0FBUztBQUNkLFdBQUssUUFBUSxJQUFJO0FBQ2pCLFdBQUssTUFBTTtBQUFBLElBQ2YsT0FBTztBQUNILGNBQVEsTUFBTSxpQ0FBaUM7QUFBQSxJQUNuRDtBQUFBLEVBQ0o7QUFBQSxFQUVBLGlCQUFpQjtBQUNiLFFBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFVBQVUsYUFBYTtBQUNoRSxXQUFLLGNBQWMsTUFBTTtBQUN6QixXQUFLLFVBQVU7QUFDZixXQUFLLGVBQWUsS0FBSyxJQUFJLElBQUksS0FBSztBQUd0QyxXQUFLLE9BQU8sVUFBVSxPQUFPLDRCQUE0QjtBQUFBLElBQzdEO0FBQUEsRUFDSjtBQUFBLEVBRUEseUJBQXlCO0FBQ3JCLFFBQUksS0FBSyxpQkFBaUIsS0FBSyxjQUFjLFVBQVUsVUFBVTtBQUM3RCxXQUFLLGNBQWMsT0FBTztBQUFBLElBQzlCLE9BQU87QUFDSCxXQUFLLGVBQWU7QUFBQSxJQUN4QjtBQUNBLFNBQUssWUFBWSxLQUFLLElBQUk7QUFDMUIsU0FBSyxXQUFXO0FBR2hCLFNBQUssT0FBTyxVQUFVLElBQUksNEJBQTRCO0FBQUEsRUFDMUQ7QUFBQSxFQUVBLFlBQVk7QUFDUixRQUFJLEtBQUssZUFBZTtBQUNwQixXQUFLLGNBQWMsS0FBSztBQUN4QixXQUFLLGNBQWMsU0FBUztBQUM1QixXQUFLLGNBQWMsa0JBQWtCO0FBQ3JDLFdBQUssZ0JBQWdCO0FBQUEsSUFDekI7QUFDQSxTQUFLLGNBQWM7QUFDbkIsU0FBSyxTQUFTLENBQUM7QUFDZixTQUFLLGNBQWM7QUFDbkIsU0FBSyxVQUFVO0FBQ2YsU0FBSyxNQUFNLGNBQWM7QUFFekIsU0FBSyxPQUFPLFVBQVUsT0FBTyw0QkFBNEI7QUFBQSxFQUM3RDtBQUFBLEVBRUEsZ0JBQWdCO0FBQ1osV0FBTyxJQUFJLFFBQXFCLENBQUMsU0FBUyxXQUFXO0FBQ2pELFdBQUssVUFBVTtBQUNmLFdBQUssU0FBUztBQUNkLFVBQUksS0FBSyxlQUFlO0FBQ3BCLGFBQUssY0FBYyxpQkFBaUIsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJLENBQUM7QUFDbEUsYUFBSyxjQUFjLEtBQUs7QUFDeEIsYUFBSyxVQUFVO0FBQUEsTUFDbkIsT0FBTztBQUNILGdCQUFRLElBQUk7QUFBQSxNQUNoQjtBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUVBLGFBQWE7QUFDVCxTQUFLLFVBQVU7QUFDZixTQUFLLGFBQWEsT0FBTyxZQUFZLE1BQU07QUFDdkMsWUFBTSx1QkFBdUIsS0FBSyxNQUFNLEtBQUssY0FBYyxHQUFJLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSSxJQUFJLEtBQUssYUFBYSxHQUFJO0FBQ2xILFlBQU0sVUFBVSxLQUFLLE1BQU0sdUJBQXVCLEVBQUU7QUFDcEQsWUFBTSxVQUFVLHVCQUF1QjtBQUN2QyxXQUFLLE1BQU0sY0FBYyxHQUFHLEtBQUssVUFBVSxPQUFPLEtBQUssS0FBSyxVQUFVLE9BQU87QUFBQSxJQUNqRixHQUFHLEdBQUk7QUFBQSxFQUNYO0FBQUEsRUFFQSxZQUFZO0FBQ1IsUUFBSSxLQUFLLGVBQWUsTUFBTTtBQUMxQixhQUFPLGNBQWMsS0FBSyxVQUFVO0FBQ3BDLFdBQUssYUFBYTtBQUFBLElBQ3RCO0FBQUEsRUFDSjtBQUFBLEVBRUEsVUFBVSxLQUFxQjtBQUMzQixXQUFPLElBQUksU0FBUyxFQUFFLFNBQVMsR0FBRyxHQUFHO0FBQUEsRUFDekM7QUFBQSxFQUdBLE9BQU87QUFDSCxVQUFNLEtBQUs7QUFDWCxXQUFPLElBQUksUUFBYyxDQUFDLFNBQVMsV0FBVztBQUMxQyxXQUFLLFVBQVU7QUFDZixXQUFLLFNBQVM7QUFBQSxJQUNsQixDQUFDO0FBQUEsRUFDTDtBQUNKOzs7QUNwUEEsSUFBQUMsbUJBQW1EO0FBRW5ELGVBQXNCLFNBQVMsS0FBVSxXQUFpQixVQUFrQixNQUE4QjtBQUN0RyxNQUFJO0FBQ0EsVUFBTSxxQkFBaUIsZ0NBQWMsSUFBSTtBQUN6QyxVQUFNLFdBQVcsR0FBRyxrQkFBa0I7QUFFdEMsVUFBTSxzQkFBc0IsS0FBSyxjQUFjO0FBRS9DLFVBQU0sY0FBYyxNQUFNLFVBQVUsWUFBWTtBQUNoRCxVQUFNLGFBQWEsSUFBSSxXQUFXLFdBQVc7QUFFN0MsVUFBTSxPQUFPLE1BQU0sSUFBSSxNQUFNLGFBQWEsVUFBVSxVQUFVO0FBQzlELFFBQUksQ0FBQyxNQUFNO0FBQ1AsWUFBTSxJQUFJLE1BQU0sd0NBQXdDO0FBQUEsSUFDNUQ7QUFDQSxXQUFPO0FBQUEsRUFDWCxTQUFTLE9BQVA7QUFDRSxZQUFRLE1BQU0sNEJBQTRCLEtBQUs7QUFDL0MsVUFBTTtBQUFBLEVBQ1Y7QUFDSjtBQUVBLGVBQWUsc0JBQXNCLEtBQVUsWUFBb0I7QUFDL0QsUUFBTSxRQUFRLFdBQVcsTUFBTSxHQUFHO0FBQ2xDLE1BQUksY0FBYztBQUVsQixhQUFXLFFBQVEsT0FBTztBQUN0QixrQkFBYyxjQUFjLEdBQUcsZUFBZSxTQUFTO0FBRXZELFFBQUk7QUFDQSxZQUFNLFNBQVMsSUFBSSxNQUFNLHNCQUFzQixXQUFXO0FBQzFELFVBQUksQ0FBQyxRQUFRO0FBQ1QsY0FBTSxJQUFJLE1BQU0sYUFBYSxXQUFXO0FBQUEsTUFDNUMsV0FBVyxrQkFBa0IsMEJBQVM7QUFDbEMsZ0JBQVEsSUFBSSwwQkFBMEIsYUFBYTtBQUFBLE1BQ3ZELE9BQU87QUFDSCxjQUFNLElBQUksTUFBTSxHQUFHLDZCQUE2QjtBQUFBLE1BQ3BEO0FBQUEsSUFDSixTQUFTLE9BQVA7QUFDRSxVQUFJLE1BQU0sUUFBUSxTQUFTLHVCQUF1QixHQUFHO0FBRWpELGdCQUFRLElBQUksNEJBQTRCLGFBQWE7QUFBQSxNQUN6RCxPQUFPO0FBQ0gsZ0JBQVEsTUFBTSxvQ0FBb0MsTUFBTSxTQUFTO0FBQ2pFLGNBQU07QUFBQSxNQUNWO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDSjs7O0FGaERBLElBQU0sRUFBQyxlQUFjLElBQUk7QUFjekIsSUFBSSxtQkFBd0M7QUFBQSxFQUMzQyxPQUFPO0FBQUEsRUFDSixRQUFRO0FBQUEsRUFDWCxRQUFRO0FBQUE7QUFBQTtBQUFBLEVBQ0wsbUJBQW1CO0FBQUEsRUFDbkIsbUJBQW1CO0FBQ3ZCO0FBRUEsSUFBTSxTQUFtQjtBQUFBLEVBQ3hCO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRDtBQUdBLElBQXFCLG1CQUFyQixjQUE4Qyx3QkFBTztBQUFBLEVBQXJEO0FBQUE7QUFLQyxrQkFBaUI7QUFDZCxpQkFBZ0I7QUFBQTtBQUFBLEVBT25CLE1BQU0sU0FBUztBQUVkLFVBQU0sS0FBSyxhQUFhO0FBRWxCLFVBQU0sV0FBVyxNQUFNLEtBQUssSUFBSSxNQUFNLFFBQVEsS0FBSyxvQkFBb0I7QUFDdkUsU0FBSyxhQUFhLEtBQUssTUFBTSxRQUFRO0FBRzNDLFNBQUssV0FBVztBQUFBLE1BQ2YsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sZ0JBQWdCLENBQUMsUUFBZ0IsU0FBdUI7QUFDM0MsYUFBSywwQkFBMEIsTUFBTTtBQUFBLE1BQ3pDO0FBQUEsSUFDVixDQUFDO0FBRUssU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixnQkFBZ0IsT0FBTyxRQUFnQixTQUF1QjtBQUUxRCxhQUFLLFlBQVksTUFBTSxJQUFJLDJCQUEyQixLQUFLLEtBQUssS0FBSyxxQkFBcUIsS0FBSyxJQUFJLENBQUMsRUFBRSxLQUFLO0FBQUEsTUFFL0c7QUFBQSxJQUNKLENBQUM7QUFHRCxTQUFLLDhCQUE4QixDQUFDLElBQWlCLFFBQXNDO0FBQ3ZGLFlBQU0sYUFBYSxHQUFHLGlCQUFpQixvQ0FBb0M7QUFDM0UsY0FBUSxJQUFJLGlCQUFpQixVQUFVO0FBQ3ZDLGlCQUFXLFFBQVEsVUFBUTtBQUV2QixnQkFBUSxJQUFJLFNBQVM7QUFFckIsY0FBTSxPQUFPLEtBQUssYUFBYSxXQUFXO0FBQzFDLFlBQUksU0FBUyxNQUFNO0FBQ2Ysa0JBQVEsTUFBTSx5REFBeUQ7QUFDdkU7QUFBQSxRQUNKO0FBRUEsY0FBTSxlQUFlLEtBQUssSUFBSSxNQUFNLHNCQUFzQixJQUFJO0FBQzlELFlBQUksRUFBRSx3QkFBd0IseUJBQVE7QUFDbEMsa0JBQVEsTUFBTSx1REFBdUQ7QUFDckU7QUFBQSxRQUNKO0FBRUEsY0FBTSxRQUFRLFNBQVMsY0FBYyxPQUFPO0FBQzVDLGNBQU0sTUFBTSxLQUFLLElBQUksTUFBTSxnQkFBZ0IsWUFBWTtBQUN2RCxjQUFNLFdBQVc7QUFDakIsY0FBTSxpQkFBaUIsa0JBQWtCLE1BQU07QUFDM0MsY0FBSSxNQUFNLFlBQVk7QUFDbEIsa0JBQU0sa0JBQWtCLFNBQVMsY0FBYyxNQUFNO0FBQ3JELDRCQUFnQixjQUFjLGFBQWEsTUFBTSxTQUFTLFFBQVEsQ0FBQztBQUNuRSxrQkFBTSxXQUFXLGFBQWEsaUJBQWlCLE1BQU0sV0FBVztBQUFBLFVBQ3BFO0FBQUEsUUFDSixDQUFDO0FBQ0QsY0FBTSxLQUFLO0FBQ1gsYUFBSyxZQUFZLEtBQUs7QUFBQSxNQUMxQixDQUFDO0FBQUEsSUFDTCxDQUFDO0FBS0QsU0FBSyxjQUFjLGNBQWMscUJBQXFCLE9BQU8sUUFBb0I7QUFFN0UsV0FBSyxZQUFZLE1BQU0sSUFBSSwyQkFBMkIsS0FBSyxLQUFLLEtBQUsscUJBQXFCLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSztBQUFBLElBRS9HLENBQUM7QUFFUCxTQUFLLGNBQWMsSUFBSSxxQkFBcUIsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLEVBRTVEO0FBQUE7QUFBQSxFQUdHLE1BQU0scUJBQXFCLFdBQWlCLFlBQXFCO0FBQzdELFFBQUk7QUFDQSxjQUFRLElBQUksNkJBQTZCLFNBQVM7QUFFbEQsVUFBSSxDQUFDLFdBQVc7QUFDWixnQkFBUSxJQUFJLHdCQUF3QjtBQUNwQztBQUFBLE1BQ0o7QUFFQSxXQUFLLFlBQVk7QUFHakIsWUFBTSxXQUFXLGFBQWEsS0FBSyxJQUFJO0FBQ3ZDLFlBQU0sT0FBTyxNQUFNLFNBQVMsS0FBSyxLQUFLLEtBQUssV0FBVyxVQUFVLEtBQUssU0FBUyxpQkFBaUI7QUFHL0YsWUFBTSxhQUFhLEtBQUssSUFBSSxVQUFVLG9CQUFvQiw2QkFBWTtBQUN0RSxVQUFJLFlBQVk7QUFDWixjQUFNLFNBQVMsV0FBVztBQUMxQixjQUFNLFNBQVMsT0FBTyxVQUFVO0FBQ2hDLGNBQU0sT0FBTyxNQUFNLEtBQUs7QUFDeEIsZUFBTyxhQUFhLE1BQU0sTUFBTTtBQUdoQyxlQUFPLGFBQWEsSUFBSSxFQUFFLE1BQU0sT0FBTyxNQUFNLElBQUksT0FBTyxHQUFHLEdBQUcsRUFBRSxNQUFNLE9BQU8sTUFBTSxJQUFJLE9BQU8sR0FBRyxDQUFDO0FBQUEsTUFDdEc7QUFHQSxVQUFJLFlBQVk7QUFDWixhQUFLLG9CQUFvQixJQUFJO0FBQUEsTUFDakM7QUFJQSxjQUFRLElBQUksSUFBSTtBQUFBLElBQ3BCLFNBQVMsT0FBUDtBQUNFLGNBQVEsTUFBTSxtQ0FBbUMsS0FBSztBQUN0RCxVQUFJLHdCQUFPLGtDQUFrQztBQUFBLElBQ2pEO0FBQUEsRUFDSjtBQUFBO0FBQUEsRUFHQSxNQUFNLG9CQUFvQixXQUFrQjtBQUN4QyxVQUFNLGFBQWEsS0FBSyxJQUFJLFVBQVUsb0JBQW9CLDZCQUFZO0FBQ3RFLFFBQUksQ0FBQyxZQUFZO0FBQ2IsY0FBUSxNQUFNLGdDQUFnQztBQUM5QztBQUFBLElBQ0o7QUFFQSxVQUFNLFNBQVMsV0FBVztBQUMxQixTQUFLLElBQUksTUFBTSxXQUFXLFNBQVMsRUFBRSxLQUFLLENBQUMsZ0JBQWdCO0FBQ3ZELFVBQUksS0FBSyxTQUFTO0FBQ2QsWUFBSSx3QkFBTyxtQ0FBbUM7QUFDOUM7QUFBQSxNQUNKO0FBQ0EsV0FBSyxVQUFVO0FBQ2YsVUFBSSx3QkFBTywwQkFBMEI7QUFDckMsWUFBTSxXQUFXLFVBQVU7QUFDM0IsV0FBSyxtQkFBbUIsYUFBYSxRQUFRLEVBQUUsS0FBSyxDQUFDLFdBQVc7QUFDNUQsYUFBSyxhQUFhO0FBQ2xCLGNBQU0sU0FBUyxLQUFLLFNBQVMsU0FBUztBQUN0QyxZQUFJLHdCQUFPLHlCQUF5QjtBQUNwQyxhQUFLLGFBQWEsUUFBUSxRQUFTLE9BQU8sVUFBVSxJQUFJLEVBQUUsSUFBSTtBQUFBLE1BQ2xFLENBQUMsRUFBRSxNQUFNLFdBQVM7QUFDZCxnQkFBUSxLQUFLLE1BQU0sT0FBTztBQUMxQixZQUFJLHdCQUFPLE1BQU0sT0FBTztBQUN4QixhQUFLLFVBQVU7QUFBQSxNQUNuQixDQUFDO0FBQUEsSUFDTCxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBRUgsVUFBVSxRQUFnQixXQUFtQixNQUFjO0FBQ3BELFVBQU0sVUFBVSxLQUFLLGVBQWUsUUFBUSxTQUFTO0FBQ3JELFdBQU8sUUFBUSxTQUFTLE9BQU8sS0FBSyxLQUFLLElBQUksSUFBSTtBQUNqRCxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUgsZUFBZSxRQUFnQixJQUFZO0FBQ3BDLFFBQUksVUFBVTtBQUNkLFdBQU8sT0FBTyxRQUFRLE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxHQUFHO0FBQzlDLFVBQUksV0FBVyxPQUFPLFNBQVM7QUFBRyxlQUFPLFFBQVEsU0FBUyxPQUFPLFFBQVEsT0FBTyxJQUFJLElBQUk7QUFDeEY7QUFBQSxJQUNKO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVILDBCQUEwQixRQUFnQjtBQUNuQyxVQUFNLFdBQVcsT0FBTyxVQUFVO0FBQ2xDLFVBQU0sT0FBTyxPQUFPLFNBQVMsRUFBRSxNQUFNLEdBQUcsSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUN6RCxVQUFNLFFBQVE7QUFBQSxNQUNWO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFDQSxTQUFLLGFBQWEsTUFBTSxLQUFLLEVBQUUsS0FBSyxDQUFDLFNBQVM7QUFDMUMsWUFBTSxXQUFXLEtBQUssTUFBTSxHQUFHLEVBQUUsSUFBSTtBQUNyQyxVQUFJLFlBQVksVUFBYSxZQUFZLFFBQVEsWUFBWSxJQUFJO0FBQzdELFlBQUksd0JBQU8scUJBQXFCO0FBQUEsTUFDcEMsT0FBTztBQUNILGFBQUssSUFBSSxNQUFNLFFBQVEsT0FBTyxJQUFJLEVBQUUsS0FBSyxDQUFDLFdBQVc7QUFDakQsY0FBSSxDQUFDO0FBQVEsa0JBQU0sSUFBSSxNQUFNLE9BQU8saUJBQWlCO0FBQ3JELGVBQUssSUFBSSxNQUFNLFFBQVEsV0FBVyxJQUFJLEVBQUUsS0FBSyxDQUFDLGdCQUFnQjtBQUMxRCxnQkFBSSxLQUFLLFNBQVM7QUFDZCxrQkFBSSx3QkFBTyxtQ0FBbUM7QUFDOUM7QUFBQSxZQUNKO0FBQ0EsaUJBQUssVUFBVTtBQUNmLGdCQUFJLHdCQUFPLDBCQUEwQjtBQUNyQyxpQkFBSyxtQkFBbUIsYUFBYSxRQUFRLEVBQUUsS0FBSyxDQUFDLFdBQVc7QUFDNUQsbUJBQUssYUFBYTtBQUNsQixvQkFBTSxTQUFTLEtBQUssU0FBUyxTQUFTO0FBQ3RDLGtCQUFJLHdCQUFPLHlCQUF5QjtBQUNwQyxtQkFBSyxhQUFhLFFBQVEsUUFBUSxPQUFPLFVBQVUsSUFBSSxFQUFFLElBQUk7QUFBQSxZQUNqRSxDQUFDLEVBQUUsTUFBTSxXQUFTO0FBQ2Qsc0JBQVEsS0FBSyxNQUFNLE9BQU87QUFDMUIsa0JBQUksd0JBQU8sTUFBTSxPQUFPO0FBQ3hCLG1CQUFLLFVBQVU7QUFBQSxZQUNuQixDQUFDO0FBQUEsVUFDTCxDQUFDO0FBQUEsUUFDTCxDQUFDO0FBQUEsTUFDTDtBQUFBLElBQ0osQ0FBQyxFQUFFLE1BQU0sV0FBUztBQUNkLGNBQVEsS0FBSyxNQUFNLE9BQU87QUFDMUIsVUFBSSx3QkFBTyxNQUFNLE9BQU87QUFBQSxJQUM1QixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBR0EsTUFBTSxhQUFhLE1BQWMsT0FBaUI7QUFDOUMsWUFBUSxJQUFJLGNBQWMsSUFBSTtBQUU5QixRQUFJLFdBQVc7QUFDZixRQUFJO0FBR0osZUFBVyxPQUFPLE9BQU87QUFDckIsY0FBUSxTQUFTLElBQUksS0FBSyxJQUFJLE9BQU8sTUFBTTtBQUN2Qyx1QkFBVyxnQ0FBYyxVQUFVLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLO0FBQUEsTUFDeEQ7QUFBQSxJQUNKO0FBRUEsUUFBSSxhQUFhO0FBQUksWUFBTSxJQUFJLE1BQU0sNEJBQTRCO0FBRWpFLFlBQVEsSUFBSSxlQUFlLFFBQVE7QUFHbkMsVUFBTSxXQUFXO0FBRWpCLFlBQVEsSUFBSSxlQUFlLFFBQVE7QUFHbkMsVUFBTSxhQUFhLEtBQUssSUFBSSxNQUFNLHNCQUFzQixRQUFRLGFBQWE7QUFDN0UsUUFBSTtBQUFZLGFBQU87QUFHdkIsVUFBTSxXQUFXLEtBQUssSUFBSSxNQUFNLFNBQVM7QUFDekMsVUFBTSxZQUFZLFNBQVMsS0FBSyxVQUFRLEtBQUssU0FBUyxTQUFTLE1BQU0sR0FBRyxFQUFFLElBQUksQ0FBQztBQUMvRSxRQUFJO0FBQVcsYUFBTyxVQUFVO0FBRWhDLFVBQU0sSUFBSSxNQUFNLGdCQUFnQjtBQUFBLEVBQ3BDO0FBQUEsRUFHSCxNQUFNLG1CQUFtQixhQUEwQixVQUFrQjtBQUM5RCxRQUFJLEtBQUssU0FBUyxPQUFPLFVBQVU7QUFBRyxZQUFNLElBQUksTUFBTSxpQ0FBaUM7QUFHdkYsVUFBTSxJQUFJO0FBQ1YsVUFBTSxzQkFBc0IsdUJBQXVCLE1BQU0sSUFBSSxDQUFDLEVBQUUsTUFBTSxLQUFLLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxxQkFBcUIsTUFBTSxHQUFHLEVBQUUsQ0FBQyxFQUFFLE1BQU0sR0FBRyxDQUFDO0FBQ2hKLFVBQU0sYUFBYSxTQUFTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDNUIsVUFBTSxjQUFjO0FBQUEsUUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBQWlHO0FBQUE7QUFDbEksVUFBTSxxQkFBcUIsSUFBSSxZQUFZLEVBQUUsT0FBTyxVQUFVO0FBQzlELFVBQU0sc0JBQXNCLElBQUksWUFBWSxFQUFFLE9BQU8sV0FBVztBQUdoRSxVQUFNLFlBQVksS0FBSyxPQUFPO0FBRzlCLFVBQU0sWUFBWSxLQUFLLEtBQUssWUFBWSxhQUFhLFNBQVM7QUFFOUQsUUFBSSxZQUFZLEdBQUc7QUFDZixVQUFJLHdCQUFPLHVCQUF1QjtBQUFBLElBQ3RDLE9BQU87QUFDSCxVQUFJLHdCQUFPLHlCQUF5QixvREFBb0Q7QUFBQSxJQUM1RjtBQUlBLFFBQUksVUFBVSxDQUFDO0FBR2YsYUFBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLEtBQUs7QUFFaEMsVUFBSSx3QkFBTyx1QkFBdUIsSUFBSSxNQUFNO0FBRzVDLFlBQU0sUUFBUSxJQUFJO0FBQ2xCLFlBQU0sTUFBTSxLQUFLLElBQUksUUFBUSxXQUFXLFlBQVksVUFBVTtBQUc5RCxZQUFNLFFBQVEsWUFBWSxNQUFNLE9BQU8sR0FBRztBQUcxQyxZQUFNLGVBQWUsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsT0FBTyxtQkFBbUIsQ0FBQyxFQUFFLFlBQVk7QUFFbEcsWUFBTSxVQUEyQjtBQUFBLFFBQzdCLEtBQUs7QUFBQSxRQUNMLFFBQVE7QUFBQSxRQUNSLGFBQWEscUNBQXFDO0FBQUEsUUFDbEQsU0FBUztBQUFBLFVBQ0wsaUJBQWlCLFlBQVksS0FBSyxTQUFTO0FBQUEsUUFDL0M7QUFBQSxRQUNBLE1BQU07QUFBQSxNQUNWO0FBRUEsWUFBTSxXQUFXLFVBQU0sNkJBQVcsT0FBTyxFQUFFLE1BQU0sQ0FBQyxVQUFVO0FBQ3hELFlBQUksTUFBTSxRQUFRLFNBQVMsS0FBSztBQUFHLGdCQUFNLElBQUksTUFBTSw4QkFBOEI7QUFBQTtBQUM1RSxnQkFBTTtBQUFBLE1BQ2YsQ0FBQztBQUVELFVBQUksVUFBVSxTQUFTLE1BQU07QUFFekIsZ0JBQVEsS0FBSyxTQUFTLEtBQUssSUFBSTtBQUFBLE1BQ25DO0FBQ0ssY0FBTSxJQUFJLE1BQU0sWUFBWSxLQUFLLFVBQVUsU0FBUyxJQUFJLENBQUM7QUFHOUQsWUFBTSxJQUFJLFFBQVEsYUFBVyxXQUFXLFNBQVMsR0FBSSxDQUFDO0FBQUEsSUFDMUQ7QUFFQSxXQUFPLFFBQVEsS0FBSyxHQUFHO0FBQUEsRUFDM0I7QUFBQSxFQUlILE1BQU0sYUFBYSxRQUFnQixRQUFnQixXQUFtQixlQUF3QjtBQUN2RixRQUFJLE9BQU8sU0FBUztBQUFHLFlBQU0sSUFBSSxNQUFNLHFCQUFxQjtBQUM1RCxRQUFLLEtBQUssU0FBUyxPQUFPLFVBQVU7QUFBRyxZQUFNLElBQUksTUFBTSxpQ0FBaUM7QUFFOUYsYUFBUyxTQUFTO0FBRVosUUFBSSxZQUFZO0FBRWhCLFVBQU0sV0FBVyxDQUFDO0FBRWxCLGFBQVMsS0FBSztBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ04sU0FBUztBQUFBLElBQ2IsQ0FBQztBQUVQLFFBQUksd0JBQU8sOENBQThDO0FBR25ELFFBQUksWUFBWSxLQUFLLGVBQWUsUUFBUSxTQUFTO0FBQ3JELFFBQUksV0FBVztBQUNmLFVBQU0sV0FBVztBQUFBLE1BQ2IsZUFBZSxDQUFDLFVBQWtCO0FBQzlCLGVBQU8sUUFBUSxXQUFXLE9BQU8sUUFBUSxTQUFTLElBQUksS0FBSztBQUMzRCxZQUFHLE1BQU0sU0FBUyxJQUFJLEdBQUU7QUFDcEIsc0JBQVksS0FBSyxlQUFlLFFBQVEsU0FBUztBQUFBLFFBQ3JEO0FBQUEsTUFDSjtBQUFBLE1BQ0EsY0FBYyxDQUFDLGVBQXVCO0FBQ2xDLG9CQUFZLEtBQUssZUFBZSxRQUFRLFFBQVE7QUFDaEQsWUFBRyxLQUFLLFNBQVMsbUJBQW1CO0FBQ2hDLGlCQUFPLFFBQVEsV0FBVyxPQUFPLFFBQVEsU0FBUyxJQUFJLHFCQUFxQixLQUFLLFVBQVU7QUFBQSxRQUM5RjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsVUFBTSxtQkFBbUIsSUFBSTtBQUFBLE1BQ3pCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxRQUNJLFNBQVMsS0FBSyxTQUFTO0FBQUEsUUFDdkIsT0FBTyxLQUFLLFNBQVM7QUFBQSxNQUN6QjtBQUFBLElBQ0o7QUFDQSxVQUFNLE9BQU8sTUFBTSxpQkFBaUIsU0FBUyxFQUFDLFNBQWtCLENBQUM7QUFFakUsU0FBSyxVQUFVO0FBQUEsRUFDbkI7QUFBQSxFQUVILE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbEM7QUFDRDtBQUVBLElBQU0sdUJBQU4sY0FBbUMsa0NBQWlCO0FBQUEsRUFHbkQsWUFBWSxLQUFVLFFBQTBCO0FBQy9DLFVBQU0sS0FBSyxNQUFNO0FBQ2pCLFNBQUssU0FBUztBQUFBLEVBQ2Y7QUFBQSxFQUVBLFVBQWdCO0FBQ2YsUUFBSSxFQUFDLFlBQVcsSUFBSTtBQUVwQixnQkFBWSxNQUFNO0FBRWxCLFFBQUkseUJBQVEsV0FBVyxFQUNyQixRQUFRLGdCQUFnQixFQUN4QixRQUFRLGlDQUFpQyxFQUN6QyxRQUFRLFVBQVEsS0FDZixlQUFlLGlCQUFpQixNQUFNLEVBQ3RDLFNBQVMsS0FBSyxPQUFPLFNBQVMsTUFBTSxFQUNwQyxTQUFTLE9BQU8sVUFBVTtBQUUxQixXQUFLLE9BQU8sU0FBUyxTQUFTO0FBQzlCLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNoQyxDQUFDLENBQUM7QUFFSixRQUFJLHlCQUFRLFdBQVcsRUFDckIsUUFBUSxPQUFPLEVBQ2YsUUFBUSw2Q0FBNkMsRUFDckQsWUFBWSxjQUFZO0FBQ3hCLGVBQVMsV0FBVyxPQUFPLE9BQU8sQ0FBQyxRQUFpQyxVQUFVO0FBQzdFLGVBQU8sS0FBSyxJQUFJO0FBQ2hCLGVBQU87QUFBQSxNQUNSLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDTixlQUFTLFNBQVMsS0FBSyxPQUFPLFNBQVMsS0FBSztBQUM1QyxlQUFTLFNBQVMsT0FBTyxVQUFVO0FBRWxDLGFBQUssT0FBTyxTQUFTLFFBQVE7QUFDN0IsY0FBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLE1BQ2hDLENBQUM7QUFBQSxJQUNGLENBQUM7QUFFSSxRQUFJLHlCQUFRLFdBQVcsRUFDM0IsUUFBUSxzQ0FBc0MsRUFDOUMsUUFBUSxnRkFBZ0YsRUFDeEYsWUFBWSxVQUFRO0FBQ3BCLFVBQUksS0FBSyxTQUFTO0FBQ2pCLGFBQUssUUFBUSxVQUFVLElBQUkscUJBQXFCO0FBQUEsTUFDakQ7QUFDQSxXQUFLO0FBQUEsUUFDVztBQUFBLE1BQTRzQixFQUMzdEIsU0FBUyxLQUFLLE9BQU8sU0FBUyxNQUFNLEVBQ3BDLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGFBQUssT0FBTyxTQUFTLFNBQVM7QUFDOUIsY0FBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLE1BQ2hDLENBQUM7QUFBQSxJQUFDLENBQUM7QUFFQyxRQUFJLHlCQUFRLFdBQVcsRUFDbEIsUUFBUSxvQkFBb0IsRUFDNUIsUUFBUSx1RkFBdUYsRUFDL0YsVUFBVSxZQUFVLE9BQ2hCLFNBQVMsS0FBSyxPQUFPLFNBQVMsaUJBQWlCLEVBQy9DLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFdBQUssT0FBTyxTQUFTLG9CQUFvQjtBQUN6QyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDbkMsQ0FBQyxDQUFDO0FBRVYsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEscUJBQXFCLEVBQzdCLFFBQVEseUpBQXlKLEVBQ2pLLFFBQVEsVUFBUSxLQUNaLGVBQWUsaUNBQWlDLEVBQ2hELFNBQVMsS0FBSyxPQUFPLFNBQVMscUJBQXFCLEVBQUUsRUFDckQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsV0FBSyxPQUFPLFNBQVMsb0JBQW9CO0FBQ3pDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFBQSxFQUVqQjtBQUNEOyIsCiAgIm5hbWVzIjogWyJvdXQiLCAibW9kdWxlIiwgIm0iLCAicmVxdWlyZV9jb2hlcmUiLCAicmVxdWlyZV9hbnRocm9waWMiLCAiU21hcnRDaGF0TW9kZWwiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiJdCn0K
